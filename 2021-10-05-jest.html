<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/39537df1dfa69610d89e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/39537df1dfa69610d89e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-1a8a258926ecde76681b.js" defer=""></script><script src="/_next/static/chunks/framework-b97a0ed4f13ff8397343.js" defer=""></script><script src="/_next/static/chunks/main-1f2c591c5d3bfcfc95e6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-72a03db9ecdc52193d45.js" defer=""></script><script src="/_next/static/chunks/pages/2021-10-05-jest-6a1f70d2be5032eedf5e.js" defer=""></script><script src="/_next/static/8-QlfOkNwV-WU6y7-Gqhe/_buildManifest.js" defer=""></script><script src="/_next/static/8-QlfOkNwV-WU6y7-Gqhe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div><a href="/">Return home</a><img src="/avatar.png" style="height:2em;margin-left:1em"/></div><div class="blog"><h1>Jest parallelization, globals, mocks, and squawkless tests</h1><p>I found that there is a little bit of confusion and misunderstanding around how
things like parallelization work in jest, which sometimes leads to additional
hacking around problems that may not exist or speculating incorrectly about
test failure. This is also of course a point of concern when you have code that
for some reason or another uses global variables. Here are a short summary of
things that may cause confusion.</p><h2>Tests in a single file are NOT run in parallel</h2><p>Simple example, the global variable r is included in the test condition, but it
is accurately run in all cases because the tests are not run in parallel.</p><pre><code class="language-js">let r = 0;

function timeout(ms) {
  return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}

describe(&quot;tests&quot;, () =&gt; {
  it(&quot;t1&quot;, async () =&gt; {
    await timeout(1000);
    expect(r).toBe(0);
    r++;
  });
  it(&quot;t2&quot;, async () =&gt; {
    await timeout(1000);
    expect(r).toBe(1);
    r++;
  });
  it(&quot;t3&quot;, async () =&gt; {
    await timeout(1000);
    expect(r).toBe(2);
    r++;
  });
});
</code></pre><p>This test will take 3 seconds, and will accurately count the global variable.
If it was in parallel, it may only take 1 second, and would inaccurately count
the global variable due to race conditions</p><h2>Tests in different files ARE run in parallel</h2><p>Let&#x27;s take another example where we use a global variable, and then two
different tests use the global variable.</p><p>file_using_some_globals.js</p><pre><code class="language-js">let myGlobal = 0;

export function doStuff() {
  myGlobal++;
  return myGlobal;
}

export function resetMyGlobal() {
  myGlobal = 0;
}

export function timeout(ms) {
  return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}
</code></pre><p>test_global_vars1.test.js</p><pre><code class="language-js">import { doStuff, timeout } from &quot;./dostuff&quot;;
test(&quot;file1&quot;, async () =&gt; {
  doStuff();
  await timeout(1000);
  expect(doStuff()).toEqual(2);
});
</code></pre><p>test_global_vars2.test.js</p><pre><code class="language-js">
import { doStuff, timeout } from &quot;./dostuff&quot;;

test(&quot;file1&quot;, async () =&gt; {
  await timeout(1000);
  expect(doStuff()).toEqual(1);
});
</code></pre><p>This test completes in less than 2 seconds, and these tests are run in
parallel. They use different instances of the global state, and therefore have
no worries with colliding their state.</p><h2>Does a mock from one test affect another test?</h2><p>While seeking the fabled &quot;squawk-less&quot; test, it is often useful to mock console
so that tests that produce an expected error don&#x27;t actually print an error
message. However, if not done carefully, you will remove errors across tests</p><p>So, could a mock from one test affect another test? If it&#x27;s in the same file,
yes!</p><p>mock_console.test.js</p><pre><code>test(&quot;test1&quot;, () =&gt; {
  console.error = jest.fn();
  console.error(&quot;wow&quot;);
  expect(console.error).toHaveBeenCalled();
});

test(&quot;test2&quot;, () =&gt; {
  // this console.error will not appear because test1 mocked away console.error
  // without restoring it
  console.error(&quot;Help I can&#x27;t see!&quot;);
});


</code></pre><p>To properly mock these, you should restore the console mock at the end of your
function</p><pre><code>test(&quot;test1&quot;, () =&gt; {
  const orig = console.error;
  console.error = jest.fn();
  console.error(&quot;I should not see this!&quot;);
  expect(console.error).toHaveBeenCalled();
  console.error = orig;
});

test(&quot;test2&quot;, () =&gt; {
  const consoleMock = jest.spyOn(console, &quot;error&quot;).mockImplementation();
  console.error(&quot;I should not see this!&quot;);
  consoleMock.mockRestore();
});

test(&quot;test3&quot;, () =&gt; {
  console.error(&quot;I should see this error!&quot;);
});
</code></pre><h2>Add-on: Achieve squawkless tests!</h2><p>Your test output should just be a big list of PASS statements, not interleaved
with console.error outputs from when you are testing error conditions of your
code</p><p>&quot;Squawkless tests&quot; is a term I made up, but it means that if you have code
under test that prints some errors to the console, then mock the console.error
function, as in the previous section. Don&#x27;t stand for having a bunch of verbose
errors in your CI logs! However, I also suggest only mocking out console.error
for tests that are <strong>expected</strong> to have errors, lest you paper over unexpected
errors.</p><p><img src="/media/squawkless_tests.png"/></p><p>Figure: a nice clean test suite without a bunch of crazy console.error outputs</p><h2>Conclusion</h2><p>Getting better at testing requires exercise, and understanding the basics of
your tools can help!  Hopefully this helps you achieve a better understanding
and write cleaner jest tests.</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/2021-10-05-jest","query":{},"buildId":"8-QlfOkNwV-WU6y7-Gqhe","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>