<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Handling component state with React (or, remember that props can change)</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/50853c3f2e0364c3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/50853c3f2e0364c3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-93aa87d657ed1852.js" defer=""></script><script src="/_next/static/chunks/framework-c0d8f0fd2eea5ac1.js" defer=""></script><script src="/_next/static/chunks/main-ae0707941214d030.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d9139de5c3de3b6b.js" defer=""></script><script src="/_next/static/chunks/996-06f747e212688e27.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-b6f09b4db8bfc341.js" defer=""></script><script src="/_next/static/aFJety1wzZSeZCsbhgqMl/_buildManifest.js" defer=""></script><script src="/_next/static/aFJety1wzZSeZCsbhgqMl/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Handling component state with React (or, remember that props can change)</h1><h4>2022-10-10</h4></div><div><p>If you make a React component that has, say, a prop for a item id, and an async
action in a <code>useEffect</code> to fetch data for that item from an API, then you may
probably also have a <code>useState</code> to set data after you get results back from
your API (or an error occurs). But, the interesting thing to me is</p>
<p><strong>you have to remember to reset that state, including error state, when your
props change</strong></p>
<p>It seems obvious, but I just wanted to write some working examples here</p>
<h2 id="part-1-having-component-state-for-returned-api-data-or-returned-error"><a aria-hidden="true" tabindex="-1" href="#part-1-having-component-state-for-returned-api-data-or-returned-error"><a href="#part-1-having-component-state-for-returned-api-data-or-returned-error" style="margin-right: 10px">#</a></a>Part 1: Having component state for returned API data or returned error</h2>
<p>Working codesandbox</p>
<p><a href="https://codesandbox.io/s/practical-rubin-l2d5el?file=/src/App.tsx:0-2003">https://codesandbox.io/s/practical-rubin-l2d5el?file=/src/App.tsx:0-2003</a></p>
<p>In the below example, we will handle fetching from the Pokemon API, and use a
<code>useState</code> to handle the returned data or a returned error. The important thing
to highlight is: when you go to refetch a new item from the API, you likely
need to clear the state of what was previously there (unless you want to
display stale results)</p>
<div class="highlight highlight-text-xml"><pre>import { useState, useEffect } from 'react'

interface PokemonType {
  type: {
    name: string
  }
}
interface PokemonInfo {
  name: string
  types: PokemonType
}

// util fetch function to throw if !response.ok, I use this util often
async function myfetch(url: string, opts?: RequestInit) {
  const response = await fetch(url, opts)
  if (!response.ok) {
    throw new Error(
      `Error fetching ${url}: HTTP ${response.status} ${await response.text()}`,
    )
  }
  return response.json()
}

function ErrorMessage({ error }: { error: unknown }) {
  return &#x3C;<span class="pl-ent">div</span> <span class="pl-e">style</span>={{ background: <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span> }}>{`${error}`}&#x3C;/<span class="pl-ent">div</span>>
}

function PokemonCard({ pokemonName }: { pokemonName: string }) {
  const [error, setError] = useState&#x3C;<span class="pl-ent">unknown</span>>()
  const [pokemonInfo, setPokemonInfo] = useState&#x3C;<span class="pl-ent">PokemonInfo</span>>()
  useEffect(() => {
    let cancelled = false
    ;(async () => {
      try {
        // important: reset the error and item state of the component!
        setError(undefined)
        setPokemonInfo(undefined)

        const data = await myfetch(
          `https://pokeapi.co/api/v2/pokemon/${pokemonName}`,
        )
        if (!cancelled) {
          setPokemonInfo(data)
        }
      } catch (e) {
        console.error(e)
        if (!cancelled) {
          setError(e)
        }
      }
    })()

    return () => {
      cancelled = true
    }
  }, [pokemonName])

  return (
    &#x3C;<span class="pl-ent">div</span>>
      {error ? (
        &#x3C;<span class="pl-ent">ErrorMessage</span> <span class="pl-e">error</span>={error} />
      ) : pokemonInfo ? (
        &#x3C;<span class="pl-ent">div</span>>
          {pokemonInfo.name} is of type{' '}
          {pokemonInfo.types.map(t => t.type.name).join(', ')}
        &#x3C;/<span class="pl-ent">div</span>>
      ) : (
        &#x3C;<span class="pl-ent">div</span>>Loading...&#x3C;/<span class="pl-ent">div</span>>
      )}
    &#x3C;/<span class="pl-ent">div</span>>
  )
}

export default function App() {
  const [value, setValue] = useState('oddish')
  return (
    &#x3C;<span class="pl-ent">div</span> <span class="pl-e">className</span>=<span class="pl-s"><span class="pl-pds">"</span>App<span class="pl-pds">"</span></span>>
      &#x3C;<span class="pl-ent">label</span> <span class="pl-e">htmlFor</span>=<span class="pl-s"><span class="pl-pds">"</span>pokemon_name<span class="pl-pds">"</span></span>>Pokemon name&#x3C;/<span class="pl-ent">label</span>>
      &#x3C;<span class="pl-ent">input</span>
        <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>pokemon_name<span class="pl-pds">"</span></span>
        <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span>
        <span class="pl-e">value</span>={value}
        <span class="pl-e">onChange</span>={e => setValue(e.target.value)}
      />
      &#x3C;<span class="pl-ent">PokemonCard</span> <span class="pl-e">pokemonName</span>={value} />
    &#x3C;/<span class="pl-ent">div</span>>
  )
}
</pre></div>
<h2 id="part-2-a-custom-hook"><a aria-hidden="true" tabindex="-1" href="#part-2-a-custom-hook"><a href="#part-2-a-custom-hook" style="margin-right: 10px">#</a></a>Part 2: A custom hook?</h2>
<p>Can we make a hook to make this easier? I don't often make custom hooks, but
you can try to "encapsulate" some of the multiple-related hooks (the useStates
for error, pokemonInfo, and useEffect) into a single hook. This does not
drastically affect our approach, but in the below example, we can call
<code>usePokemonInfo(pokemonName)</code> and error handling and fetching is handled for us</p>
<p>Working codesandbox</p>
<p><a href="https://codesandbox.io/s/fragrant-wind-008pfn?file=/src/App.tsx:0-2234">https://codesandbox.io/s/fragrant-wind-008pfn?file=/src/App.tsx:0-2234</a></p>
<div class="highlight highlight-text-xml"><pre>import { useState, useEffect } from 'react'

interface PokemonType {
  type: {
    name: string
  }
}
interface PokemonInfo {
  name: string
  types: PokemonType
}

// util fetch function to throw if !response.ok, I use this util often
async function myfetch(url: string, opts?: RequestInit) {
  const response = await fetch(url, opts)
  if (!response.ok) {
    throw new Error(
      `Error fetching ${url}: HTTP ${response.status} ${await response.text()}`,
    )
  }
  return response.json()
}

function usePokemonInfo(pokemonName: string) {
  const [error, setError] = useState&#x3C;<span class="pl-ent">unknown</span>>()
  const [pokemonInfo, setPokemonInfo] = useState&#x3C;<span class="pl-ent">PokemonInfo</span>>()
  useEffect(() => {
    let cancelled = false
    ;(async () => {
      try {
        setPokemonInfo(undefined) // &#x3C;<span class="pl-ent">--</span> important to reset the state of the app
        setError(undefined) // &#x3C;-- important to reset the state of the app
        const data = await myfetch(
          `https://pokeapi.co/api/v2/pokemon/${pokemonName}`,
        )
        if (!cancelled) {
          setPokemonInfo(data)
        }
      } catch (e) {
        console.error(e)
        if (!cancelled) {
          setError(e)
        }
      }
    })()

    return () => {
      cancelled = true
    }
  }, [pokemonName])

  return [error, pokemonInfo]
}

function ErrorMessage({ error }: { error: unknown }) {
  return &#x3C;<span class="pl-ent">div</span> <span class="pl-e">style</span>={{ background: <span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span> }}>{`${error}`}&#x3C;/<span class="pl-ent">div</span>>
}

function PokemonCard({ pokemonName }: { pokemonName: string }) {
  const [error, pokemonInfo] = usePokemonInfo(pokemonName)

  return (
    &#x3C;<span class="pl-ent">div</span>>
      {error ? (
        &#x3C;<span class="pl-ent">ErrorMessage</span> <span class="pl-e">error</span>={error} />
      ) : pokemonInfo ? (
        &#x3C;<span class="pl-ent">div</span>>
          {pokemonInfo.name} is of type{' '}
          {pokemonInfo.types.map(t => t.type.name).join(', ')}
        &#x3C;/<span class="pl-ent">div</span>>
      ) : (
        &#x3C;<span class="pl-ent">div</span>>Loading...&#x3C;/<span class="pl-ent">div</span>>
      )}
    &#x3C;/<span class="pl-ent">div</span>>
  )
}

export default function App() {
  const [value, setValue] = useState('oddish')
  return (
    &#x3C;<span class="pl-ent">div</span> <span class="pl-e">className</span>=<span class="pl-s"><span class="pl-pds">"</span>App<span class="pl-pds">"</span></span>>
      &#x3C;<span class="pl-ent">label</span> <span class="pl-e">htmlFor</span>=<span class="pl-s"><span class="pl-pds">"</span>pokemon_name<span class="pl-pds">"</span></span>>Pokemon name&#x3C;/<span class="pl-ent">label</span>>
      &#x3C;<span class="pl-ent">input</span>
        <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>pokemon_name<span class="pl-pds">"</span></span>
        <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span>
        <span class="pl-e">value</span>={value}
        <span class="pl-e">onChange</span>={e => setValue(e.target.value)}
      />
      &#x3C;<span class="pl-ent">PokemonCard</span> <span class="pl-e">pokemonName</span>={value} />
    &#x3C;/<span class="pl-ent">div</span>>
  )
}
</pre></div>
<h2 id="conclusion"><a aria-hidden="true" tabindex="-1" href="#conclusion"><a href="#conclusion" style="margin-right: 10px">#</a></a>Conclusion</h2>
<p>I think it's sometimes common to forget error handling in async JS code
(useEffect async or many other contexts, etc), and it's not linted well wither,
leaving errors uncaught. If you don't manually handle the error in the
useEffect, your user will literally never see that an error occured. But, the
flipside to this, is you also have to reset your "error state", those are the
key lines where I call setError(undefined) and setPokemonInfo(undefined) before
I fetch a new pokemon from my API.</p>
<h2 id="footnote-0"><a aria-hidden="true" tabindex="-1" href="#footnote-0"><a href="#footnote-0" style="margin-right: 10px">#</a></a>Footnote 0:</h2>
<p>I think sometimes, this manner of fetching data inside a component can lead to
what some web-perf-experts refer to as waterfall. Can you get your state from
your parent? That might result in fewer individual requests made, but is also
quite a different architecture.</p></div><div style="margin-top:200px"></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin/">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Handling component state with React (or, remember that props can change)","date":"2022-10-10","slug":"2022-10-10-reactstate","html":"\u003cp\u003eIf you make a React component that has, say, a prop for a item id, and an async\naction in a \u003ccode\u003euseEffect\u003c/code\u003e to fetch data for that item from an API, then you may\nprobably also have a \u003ccode\u003euseState\u003c/code\u003e to set data after you get results back from\nyour API (or an error occurs). But, the interesting thing to me is\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eyou have to remember to reset that state, including error state, when your\nprops change\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIt seems obvious, but I just wanted to write some working examples here\u003c/p\u003e\n\u003ch2 id=\"part-1-having-component-state-for-returned-api-data-or-returned-error\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#part-1-having-component-state-for-returned-api-data-or-returned-error\"\u003e\u003ca href=\"#part-1-having-component-state-for-returned-api-data-or-returned-error\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003ePart 1: Having component state for returned API data or returned error\u003c/h2\u003e\n\u003cp\u003eWorking codesandbox\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://codesandbox.io/s/practical-rubin-l2d5el?file=/src/App.tsx:0-2003\"\u003ehttps://codesandbox.io/s/practical-rubin-l2d5el?file=/src/App.tsx:0-2003\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIn the below example, we will handle fetching from the Pokemon API, and use a\n\u003ccode\u003euseState\u003c/code\u003e to handle the returned data or a returned error. The important thing\nto highlight is: when you go to refetch a new item from the API, you likely\nneed to clear the state of what was previously there (unless you want to\ndisplay stale results)\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-text-xml\"\u003e\u003cpre\u003eimport { useState, useEffect } from 'react'\n\ninterface PokemonType {\n  type: {\n    name: string\n  }\n}\ninterface PokemonInfo {\n  name: string\n  types: PokemonType\n}\n\n// util fetch function to throw if !response.ok, I use this util often\nasync function myfetch(url: string, opts?: RequestInit) {\n  const response = await fetch(url, opts)\n  if (!response.ok) {\n    throw new Error(\n      `Error fetching ${url}: HTTP ${response.status} ${await response.text()}`,\n    )\n  }\n  return response.json()\n}\n\nfunction ErrorMessage({ error }: { error: unknown }) {\n  return \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e \u003cspan class=\"pl-e\"\u003estyle\u003c/span\u003e={{ background: \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003ered\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e }}\u003e{`${error}`}\u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n}\n\nfunction PokemonCard({ pokemonName }: { pokemonName: string }) {\n  const [error, setError] = useState\u0026#x3C;\u003cspan class=\"pl-ent\"\u003eunknown\u003c/span\u003e\u003e()\n  const [pokemonInfo, setPokemonInfo] = useState\u0026#x3C;\u003cspan class=\"pl-ent\"\u003ePokemonInfo\u003c/span\u003e\u003e()\n  useEffect(() =\u003e {\n    let cancelled = false\n    ;(async () =\u003e {\n      try {\n        // important: reset the error and item state of the component!\n        setError(undefined)\n        setPokemonInfo(undefined)\n\n        const data = await myfetch(\n          `https://pokeapi.co/api/v2/pokemon/${pokemonName}`,\n        )\n        if (!cancelled) {\n          setPokemonInfo(data)\n        }\n      } catch (e) {\n        console.error(e)\n        if (!cancelled) {\n          setError(e)\n        }\n      }\n    })()\n\n    return () =\u003e {\n      cancelled = true\n    }\n  }, [pokemonName])\n\n  return (\n    \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n      {error ? (\n        \u0026#x3C;\u003cspan class=\"pl-ent\"\u003eErrorMessage\u003c/span\u003e \u003cspan class=\"pl-e\"\u003eerror\u003c/span\u003e={error} /\u003e\n      ) : pokemonInfo ? (\n        \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n          {pokemonInfo.name} is of type{' '}\n          {pokemonInfo.types.map(t =\u003e t.type.name).join(', ')}\n        \u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n      ) : (\n        \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003eLoading...\u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n      )}\n    \u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n  )\n}\n\nexport default function App() {\n  const [value, setValue] = useState('oddish')\n  return (\n    \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e \u003cspan class=\"pl-e\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003eApp\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003e\n      \u0026#x3C;\u003cspan class=\"pl-ent\"\u003elabel\u003c/span\u003e \u003cspan class=\"pl-e\"\u003ehtmlFor\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003epokemon_name\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003ePokemon name\u0026#x3C;/\u003cspan class=\"pl-ent\"\u003elabel\u003c/span\u003e\u003e\n      \u0026#x3C;\u003cspan class=\"pl-ent\"\u003einput\u003c/span\u003e\n        \u003cspan class=\"pl-e\"\u003eid\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003epokemon_name\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"pl-e\"\u003etype\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003etext\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"pl-e\"\u003evalue\u003c/span\u003e={value}\n        \u003cspan class=\"pl-e\"\u003eonChange\u003c/span\u003e={e =\u003e setValue(e.target.value)}\n      /\u003e\n      \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ePokemonCard\u003c/span\u003e \u003cspan class=\"pl-e\"\u003epokemonName\u003c/span\u003e={value} /\u003e\n    \u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n  )\n}\n\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"part-2-a-custom-hook\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#part-2-a-custom-hook\"\u003e\u003ca href=\"#part-2-a-custom-hook\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003ePart 2: A custom hook?\u003c/h2\u003e\n\u003cp\u003eCan we make a hook to make this easier? I don't often make custom hooks, but\nyou can try to \"encapsulate\" some of the multiple-related hooks (the useStates\nfor error, pokemonInfo, and useEffect) into a single hook. This does not\ndrastically affect our approach, but in the below example, we can call\n\u003ccode\u003eusePokemonInfo(pokemonName)\u003c/code\u003e and error handling and fetching is handled for us\u003c/p\u003e\n\u003cp\u003eWorking codesandbox\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://codesandbox.io/s/fragrant-wind-008pfn?file=/src/App.tsx:0-2234\"\u003ehttps://codesandbox.io/s/fragrant-wind-008pfn?file=/src/App.tsx:0-2234\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight highlight-text-xml\"\u003e\u003cpre\u003eimport { useState, useEffect } from 'react'\n\ninterface PokemonType {\n  type: {\n    name: string\n  }\n}\ninterface PokemonInfo {\n  name: string\n  types: PokemonType\n}\n\n// util fetch function to throw if !response.ok, I use this util often\nasync function myfetch(url: string, opts?: RequestInit) {\n  const response = await fetch(url, opts)\n  if (!response.ok) {\n    throw new Error(\n      `Error fetching ${url}: HTTP ${response.status} ${await response.text()}`,\n    )\n  }\n  return response.json()\n}\n\nfunction usePokemonInfo(pokemonName: string) {\n  const [error, setError] = useState\u0026#x3C;\u003cspan class=\"pl-ent\"\u003eunknown\u003c/span\u003e\u003e()\n  const [pokemonInfo, setPokemonInfo] = useState\u0026#x3C;\u003cspan class=\"pl-ent\"\u003ePokemonInfo\u003c/span\u003e\u003e()\n  useEffect(() =\u003e {\n    let cancelled = false\n    ;(async () =\u003e {\n      try {\n        setPokemonInfo(undefined) // \u0026#x3C;\u003cspan class=\"pl-ent\"\u003e--\u003c/span\u003e important to reset the state of the app\n        setError(undefined) // \u0026#x3C;-- important to reset the state of the app\n        const data = await myfetch(\n          `https://pokeapi.co/api/v2/pokemon/${pokemonName}`,\n        )\n        if (!cancelled) {\n          setPokemonInfo(data)\n        }\n      } catch (e) {\n        console.error(e)\n        if (!cancelled) {\n          setError(e)\n        }\n      }\n    })()\n\n    return () =\u003e {\n      cancelled = true\n    }\n  }, [pokemonName])\n\n  return [error, pokemonInfo]\n}\n\nfunction ErrorMessage({ error }: { error: unknown }) {\n  return \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e \u003cspan class=\"pl-e\"\u003estyle\u003c/span\u003e={{ background: \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003ered\u003cspan class=\"pl-pds\"\u003e'\u003c/span\u003e\u003c/span\u003e }}\u003e{`${error}`}\u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n}\n\nfunction PokemonCard({ pokemonName }: { pokemonName: string }) {\n  const [error, pokemonInfo] = usePokemonInfo(pokemonName)\n\n  return (\n    \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n      {error ? (\n        \u0026#x3C;\u003cspan class=\"pl-ent\"\u003eErrorMessage\u003c/span\u003e \u003cspan class=\"pl-e\"\u003eerror\u003c/span\u003e={error} /\u003e\n      ) : pokemonInfo ? (\n        \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n          {pokemonInfo.name} is of type{' '}\n          {pokemonInfo.types.map(t =\u003e t.type.name).join(', ')}\n        \u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n      ) : (\n        \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003eLoading...\u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n      )}\n    \u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n  )\n}\n\nexport default function App() {\n  const [value, setValue] = useState('oddish')\n  return (\n    \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e \u003cspan class=\"pl-e\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003eApp\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003e\n      \u0026#x3C;\u003cspan class=\"pl-ent\"\u003elabel\u003c/span\u003e \u003cspan class=\"pl-e\"\u003ehtmlFor\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003epokemon_name\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003ePokemon name\u0026#x3C;/\u003cspan class=\"pl-ent\"\u003elabel\u003c/span\u003e\u003e\n      \u0026#x3C;\u003cspan class=\"pl-ent\"\u003einput\u003c/span\u003e\n        \u003cspan class=\"pl-e\"\u003eid\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003epokemon_name\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"pl-e\"\u003etype\u003c/span\u003e=\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003etext\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"pl-e\"\u003evalue\u003c/span\u003e={value}\n        \u003cspan class=\"pl-e\"\u003eonChange\u003c/span\u003e={e =\u003e setValue(e.target.value)}\n      /\u003e\n      \u0026#x3C;\u003cspan class=\"pl-ent\"\u003ePokemonCard\u003c/span\u003e \u003cspan class=\"pl-e\"\u003epokemonName\u003c/span\u003e={value} /\u003e\n    \u0026#x3C;/\u003cspan class=\"pl-ent\"\u003ediv\u003c/span\u003e\u003e\n  )\n}\n\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"conclusion\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#conclusion\"\u003e\u003ca href=\"#conclusion\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eI think it's sometimes common to forget error handling in async JS code\n(useEffect async or many other contexts, etc), and it's not linted well wither,\nleaving errors uncaught. If you don't manually handle the error in the\nuseEffect, your user will literally never see that an error occured. But, the\nflipside to this, is you also have to reset your \"error state\", those are the\nkey lines where I call setError(undefined) and setPokemonInfo(undefined) before\nI fetch a new pokemon from my API.\u003c/p\u003e\n\u003ch2 id=\"footnote-0\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#footnote-0\"\u003e\u003ca href=\"#footnote-0\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eFootnote 0:\u003c/h2\u003e\n\u003cp\u003eI think sometimes, this manner of fetching data inside a component can lead to\nwhat some web-perf-experts refer to as waterfall. Can you get your state from\nyour parent? That might result in fewer individual requests made, but is also\nquite a different architecture.\u003c/p\u003e"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-10-10-reactstate"},"buildId":"aFJety1wzZSeZCsbhgqMl","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>