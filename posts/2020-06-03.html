<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Misconceptions your team might have during The Big Rewrite</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/9d066bf523979bbf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d066bf523979bbf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-4c70eeb4cef5b69f.js" defer=""></script><script src="/_next/static/chunks/framework-c0d8f0fd2eea5ac1.js" defer=""></script><script src="/_next/static/chunks/main-33a474ca00e371b8.js" defer=""></script><script src="/_next/static/chunks/pages/_app-13ca9a07b898f6f6.js" defer=""></script><script src="/_next/static/chunks/996-9c91d1eae613ddeb.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-a9b8dd170d83e486.js" defer=""></script><script src="/_next/static/ZOwrOtoUUOMcKRGNVh2wS/_buildManifest.js" defer=""></script><script src="/_next/static/ZOwrOtoUUOMcKRGNVh2wS/_ssgManifest.js" defer=""></script><script src="/_next/static/ZOwrOtoUUOMcKRGNVh2wS/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Misconceptions your team might have during The Big Rewrite</h1><h4>2020-06-03</h4></div><p>Disclaimer: I enjoy the project I am working on and this is still a work
in progress. I just had to rant about the stuff I go through in my job
here, but it does not reflect the opinions of my emplorer, and my
personal opinion is despite these troubles we are coming along nicely</p>
<p>I joined a team that was doing the big rewrite in 2018. I was involved
in the project before then and knew it&#x27;s ins and outs, and frankly think
it&#x27;s still a great system. In order to break it&#x27;s &quot;limitations&quot; a grand
v2 gets started. I think my team has been good. My tech lead is really
good at architecture. Where I really resist kind of &quot;writing new
architecture that is not already there&quot;, he can pull up entirely new
concepts and abstractions that are all pretty good. Myself, I don&#x27;t much
enjoy writing &quot;new architecture&quot; if there is something already there
that I can use, and I&#x27;ll try to refer to the existence of an existing
thing instead of creating new exotic stuff.</p>
<p>Now, what happened during the big rewrite so far. 4 people on the team,
2 years in</p>
<p>Persistent confusion about sources of slowness in our app</p>
<ul>
<li>it&#x27;s only slow because devtools is open (maybe it is! but this is
definitely a red herring. the code should work with devtools open.
reason that&#x27;s been stated: devtools adds a &quot;bunch of instrumentation to
the promises that slows it down&quot;...stated without any evidence during a
3 hour long planning call...)
 - it&#x27;s only slow because we&#x27;re using a development build of react, try
a production build (the production build makes some stuff faster, but it
is NOT going to save your butt if you are constantly rerending all your
components unnecessarily every millisecond during user scroll, which is
something we suffered from, and it creeps back in if you are not careful
because you can&#x27;t write tests against this so often one day I&#x27;ll be
looking at my devtools and suddenly things are rendering twice per frame
(signature of calling an unnecessary setState), tons of unnecessary
components rendering in every frame (signature of
componentShouldUpdate/bad functional react memoizing, etc))
 - it&#x27;s slow because we are hogging the main thread all the time, our
killer new feature in v2 is an intense webworker framework. now main
thread contention is a concern, but really our app needs to just be
performant all around, webworkers just offloads that cpu spinning to
another core. what we have done in v2 is we went whole hog and made our
code rely on OffscreenCanvas which 0 browsers support. also, our
webworker bundles (worker-loader webpack build) are huge webpack things
that pretty much contain all the code that is on the main thread so it&#x27;s
just massive. that makes it slow at loading time, and makes it harder to
think about our worker threads in a lighter-weight way, and the worker
concept is now very deeply entrenched in a lot of the code (all code has
to think of things in terms of rpc calls)
 - it&#x27;s slow because there are processes that haven&#x27;t been aborted
spinning in the background, so we must build out an intensive
AbortController thing that touches the entirety of all our code
including sending abort signals across the RPC boundary in hopes that a
locked up webworker will respond to this (note: our first version of the
software had zero aborting, did not from my perspective suffer.
arguments with the team have gotten accusatory where I just claim that
there is no evidence that the aborting is helping us, pointing to the
fact that our old code works fine, and that if our new code suffers
without aborting, that means something else is wrong. I have not really
been given a proper response for this, and so the curse of passing
AbortSignals onto every function via an extra function parameter drags
on
 - it&#x27;s slow because we are not multithreading..., so we put two views
of the same data into different webworkers (but now each webworker
separately downloads the same data, which leads to more resource spent,
more network IO, more slowness)</li>
</ul>
<p>confusion about what our old users needs are</p>
<ul>
<li>
<p>tracks not having per-track scroll (problem: leads to many scrolls
within-scrolls, still unresolved problem)
 - the name indexing was always a big problem (yes it is slow but is it
really THE critical problem we face? likely not: bioinformatics people
run a data pipeline, it takes a couple days, so what). use elasticsearch
if it sucks so bad
 - our users are &quot;stupid&quot; so they need to have every single thing GUI
editable (interesting endeavor, but our design for this has been
difficult, and has not yet delivered on simplifying the system for
users)
 - our users &quot;do not like modal popups&quot; so we design everything into a
tiny sidedrawer that barely can contain the relevant data that they want
to see</p>
</li>
<li>
<p>having interest in catering to obscure or not very clear &quot;user
stories&quot; like displaying the same exact region twice on the screen at
once saying &quot;someone will want to do this&quot;, but causing a ton of extra
logical weirdness from this</p>
</li>
<li>
<p>not catering to emerging areas of user needs such as breaking our
large app into components that can be re-used, and instead just going
full hog on a large monolith project and treating our monolith as a
giant hammer that will solve everyones problems, when in reality, our
users are also programmers that could benefit from using smaller
componentized versions of our code</p>
</li>
<li>
<p>confusion about &quot;what our competitors have&quot;. sometimes my team one day
was like &quot;alright we just do that and then we have everything product X
has?&quot; and I just had to be clear and be like, no! the competitor has a
reall pretty intricate complex system that we could never hope to
replicate. but does that matter? probably not, but even still, we likely
don&#x27;t have even 20% of the full set of functions of a competitor.
luckily we have our own strengths that make us compelling besides that
20%</p>
</li>
<li>
<p>making it so our product requires a server side component to run,
where our first version was much more amenable to running as a static
site</p>
</li>
<li>
<p>etc...</p>
</li>
</ul>
<p>but what does all this imply?</p>
<p>there are persistent confusion about what the challenges we face are,
what the architectural needs are, what our user stores are, what our new
v2 design goals are, and more. It&#x27;s really crazy</p><div style="margin-top:200px"></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin/">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Misconceptions your team might have during The Big Rewrite","date":"2020-06-03","slug":"2020-06-03","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Disclaimer: I enjoy the project I am working on and this is still a work\\nin progress. I just had to rant about the stuff I go through in my job\\nhere, but it does not reflect the opinions of my emplorer, and my\\npersonal opinion is despite these troubles we are coming along nicely\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I joined a team that was doing the big rewrite in 2018. I was involved\\nin the project before then and knew it's ins and outs, and frankly think\\nit's still a great system. In order to break it's \\\"limitations\\\" a grand\\nv2 gets started. I think my team has been good. My tech lead is really\\ngood at architecture. Where I really resist kind of \\\"writing new\\narchitecture that is not already there\\\", he can pull up entirely new\\nconcepts and abstractions that are all pretty good. Myself, I don't much\\nenjoy writing \\\"new architecture\\\" if there is something already there\\nthat I can use, and I'll try to refer to the existence of an existing\\nthing instead of creating new exotic stuff.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now, what happened during the big rewrite so far. 4 people on the team,\\n2 years in\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Persistent confusion about sources of slowness in our app\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"it's only slow because devtools is open (maybe it is! but this is\\ndefinitely a red herring. the code should work with devtools open.\\nreason that's been stated: devtools adds a \\\"bunch of instrumentation to\\nthe promises that slows it down\\\"...stated without any evidence during a\\n3 hour long planning call...)\\n - it's only slow because we're using a development build of react, try\\na production build (the production build makes some stuff faster, but it\\nis NOT going to save your butt if you are constantly rerending all your\\ncomponents unnecessarily every millisecond during user scroll, which is\\nsomething we suffered from, and it creeps back in if you are not careful\\nbecause you can't write tests against this so often one day I'll be\\nlooking at my devtools and suddenly things are rendering twice per frame\\n(signature of calling an unnecessary setState), tons of unnecessary\\ncomponents rendering in every frame (signature of\\ncomponentShouldUpdate/bad functional react memoizing, etc))\\n - it's slow because we are hogging the main thread all the time, our\\nkiller new feature in v2 is an intense webworker framework. now main\\nthread contention is a concern, but really our app needs to just be\\nperformant all around, webworkers just offloads that cpu spinning to\\nanother core. what we have done in v2 is we went whole hog and made our\\ncode rely on OffscreenCanvas which 0 browsers support. also, our\\nwebworker bundles (worker-loader webpack build) are huge webpack things\\nthat pretty much contain all the code that is on the main thread so it's\\njust massive. that makes it slow at loading time, and makes it harder to\\nthink about our worker threads in a lighter-weight way, and the worker\\nconcept is now very deeply entrenched in a lot of the code (all code has\\nto think of things in terms of rpc calls)\\n - it's slow because there are processes that haven't been aborted\\nspinning in the background, so we must build out an intensive\\nAbortController thing that touches the entirety of all our code\\nincluding sending abort signals across the RPC boundary in hopes that a\\nlocked up webworker will respond to this (note: our first version of the\\nsoftware had zero aborting, did not from my perspective suffer.\\narguments with the team have gotten accusatory where I just claim that\\nthere is no evidence that the aborting is helping us, pointing to the\\nfact that our old code works fine, and that if our new code suffers\\nwithout aborting, that means something else is wrong. I have not really\\nbeen given a proper response for this, and so the curse of passing\\nAbortSignals onto every function via an extra function parameter drags\\non\\n - it's slow because we are not multithreading..., so we put two views\\nof the same data into different webworkers (but now each webworker\\nseparately downloads the same data, which leads to more resource spent,\\nmore network IO, more slowness)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"confusion about what our old users needs are\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"tracks not having per-track scroll (problem: leads to many scrolls\\nwithin-scrolls, still unresolved problem)\\n - the name indexing was always a big problem (yes it is slow but is it\\nreally THE critical problem we face? likely not: bioinformatics people\\nrun a data pipeline, it takes a couple days, so what). use elasticsearch\\nif it sucks so bad\\n - our users are \\\"stupid\\\" so they need to have every single thing GUI\\neditable (interesting endeavor, but our design for this has been\\ndifficult, and has not yet delivered on simplifying the system for\\nusers)\\n - our users \\\"do not like modal popups\\\" so we design everything into a\\ntiny sidedrawer that barely can contain the relevant data that they want\\nto see\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"having interest in catering to obscure or not very clear \\\"user\\nstories\\\" like displaying the same exact region twice on the screen at\\nonce saying \\\"someone will want to do this\\\", but causing a ton of extra\\nlogical weirdness from this\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"not catering to emerging areas of user needs such as breaking our\\nlarge app into components that can be re-used, and instead just going\\nfull hog on a large monolith project and treating our monolith as a\\ngiant hammer that will solve everyones problems, when in reality, our\\nusers are also programmers that could benefit from using smaller\\ncomponentized versions of our code\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"confusion about \\\"what our competitors have\\\". sometimes my team one day\\nwas like \\\"alright we just do that and then we have everything product X\\nhas?\\\" and I just had to be clear and be like, no! the competitor has a\\nreall pretty intricate complex system that we could never hope to\\nreplicate. but does that matter? probably not, but even still, we likely\\ndon't have even 20% of the full set of functions of a competitor.\\nluckily we have our own strengths that make us compelling besides that\\n20%\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"making it so our product requires a server side component to run,\\nwhere our first version was much more amenable to running as a static\\nsite\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"etc...\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"but what does all this imply?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"there are persistent confusion about what the challenges we face are,\\nwhat the architectural needs are, what our user stores are, what our new\\nv2 design goals are, and more. It's really crazy\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2020-06-03"},"buildId":"ZOwrOtoUUOMcKRGNVh2wS","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>