<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Caching async functions or promises in Javascript</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/53d80a6545e3cb78.css" as="style"/><link rel="stylesheet" href="/_next/static/css/53d80a6545e3cb78.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-6db65d5e18d8108f.js" defer=""></script><script src="/_next/static/EYD6Fjl0eBO4PUZJ0STIT/_buildManifest.js" defer=""></script><script src="/_next/static/EYD6Fjl0eBO4PUZJ0STIT/_ssgManifest.js" defer=""></script><script src="/_next/static/EYD6Fjl0eBO4PUZJ0STIT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Caching async functions or promises in Javascript</h1><h4>2022-02-26</h4></div><p>There are two hard problems in computer science: <a href="https://martinfowler.com/bliki/TwoHardThings.html">Cache invalidation and naming
things</a>. I&#x27;m not going to go
over cache invalidation here but I will try to recommend how to cache async
functions</p><p>Caching async functions or promises in javascript can be somewhat confusing. I
think searching for info about it online is often misguided and results are
often very specific to someones application Here is a method I have used to
cache promises, or to memoize an async function. It may not handle all cases,
but it helps with some scenarios I have seen</p><p>Example async function: fetch from the pokemon API</p><pre><code class="language-javascript">async function getPokemon() {
  const id = Math.floor(Math.random() * 150)
  const url = &#x27;https://pokeapi.co/api/v2/pokemon/&#x27; + id
  const ret = await fetch(url)
  if (!ret.ok) {
    throw new Error(
      `Failed to fetch ${url} HTTP ${ret.status} ${ret.statusText}`,
    )
  }
  return ret.json()
}
</code></pre><p>How can we cache this function so that we only get one result</p><pre><code class="language-javascript">async function getCachedPokemon() {
  if (!this.res) {
    this.res = getPokemon().catch(e =&gt; {
      this.res = undefined
      throw e
    })
  }
  return this.res
}
</code></pre><p>The important part of this function is that when I get an error, I clear the
resource. The caller of the function, on error, will receive the error message,
but caching will not take place, allowing retries to take place later on.</p><p>See <a href="https://cmdcolin.github.io/pokemon.html">https://cmdcolin.github.io/pokemon.html</a> for demo</p><h2>Footnote 1: Error handling</h2><p>This demo also demonstrates some basic fetch error handling, and uses
<code>statusText</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText">which happens to not exist in
HTTP/2</a>.
If you want a semblence of status message text in HTTP/2 you can try to use
await ret.json() or await ret.text() inside the catch clause, but note that it
could cause yet another error to be thrown</p><h1>Footnote 2: Cache types</h1><p>You could also keep a cache in a global variable, or as a property on a class,
or other methods. I have also found it useful to have a specific function for
clearing the cache, so you can get a clean slate each time a test runs in unit
testing or similar</p><pre><code class="language-javascript">let res
async function getCachedPokemon() {
  if (!res) {
    res = getPokemon().catch(e =&gt; {
      res = undefined
      throw e
    })
  }
  return res
}
function clearCache() {
  res = undefined
}
</code></pre><h2>Footnote 3 - Aborting</h2><p>If you want to handle aborting, it is a bit trickier. Aborting in javascript is
handled by
<a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController/AbortController">AbortController</a>.
This is an object that gives you an
<a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal">AbortSignal</a>
that can be passed to fetch calls and the like to stop a big download from
happening.</p><p>In our above example, if we passed an abort signal to the first call to fetch,
and then aborted it, it would abort the fetch, <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort">which throws a DOMException
called
&quot;AbortError&quot;</a>.
You can detect that it is an AbortError like this, and may choose not to
display or re-throw the abort exception</p><pre><code class="language-javascript">function isAbortException(e) {
  return e instanceof Error &amp;&amp; exception.name === &#x27;AbortError&#x27;
}
</code></pre><p>Now, what if 5 functions call getCachedPokemon(), all passing different abort
signals. What if the first one aborts? Then all the rest will get aborted also.
But what if we only want to abort the cached call if literally all of them
aborted? Then we may have to synthesize an abortcontroller inside our function</p><pre><code class="language-javascript">let res
let abortcontroller
let listeners = 0
async function getCachedPokemon(signal) {
  if (!res) {
    abortcontroller = new AbortController()

    // synthesize a new signal instead of using the passed in signal
    res = getPokemon(abortcontroller.signal).catch(e =&gt; {
      res = undefined
      throw e
    })
  }
  if (signal) {
    listeners++
    // add listener to the passed in signal
    signal.addEventListener(&#x27;abort&#x27;, () =&gt; {
      listeners--
      if (listeners === 0) {
        abortcontroller.abort()
      }
    })
  }
  return res
}
</code></pre><p>A library my team created,
<a href="https://github.com/GMOD/abortable-promise-cache">abortable-promise-cache</a>,
tries to help with this scenario with a cleaner abstraction.</p><h2>Footnote 4</h2><p>I have been playing through Pokemon Yellow and find it really amusing hence the
pokemon theme</p><p>Fun stuff: The cutting room floor wiki with unused moves, sounds, and sprites
in Pokemon Yellow <a href="https://tcrf.net/Pok%C3%A9mon_Yellow">https://tcrf.net/Pok%C3%A9mon_Yellow</a></p></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="https://scholar.google.com/citations?view_op=list_works&amp;hl=en&amp;user=--FwzsgAAAAJ">Publications</a> <a href="/sketches">Sketches</a> <a href="/kitty">Kitty</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Caching async functions or promises in Javascript","date":"2022-02-26","slug":"2022-02-26-caching-promise","mdxSource":{"compiledSource":"var p=Object.defineProperty,d=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(e,t,a)=\u003et in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,o=(e,t)=\u003e{for(var a in t||(t={}))s.call(t,a)\u0026\u0026c(e,a,t[a]);if(r)for(var a of r(t))i.call(t,a)\u0026\u0026c(e,a,t[a]);return e},l=(e,t)=\u003ed(e,m(t));var h=(e,t)=\u003e{var a={};for(var n in e)s.call(e,n)\u0026\u0026t.indexOf(n)\u003c0\u0026\u0026(a[n]=e[n]);if(e!=null\u0026\u0026r)for(var n of r(e))t.indexOf(n)\u003c0\u0026\u0026i.call(e,n)\u0026\u0026(a[n]=e[n]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:e}=n,t=h(n,[\"components\"]);return mdx(MDXLayout,l(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"There are two hard problems in computer science: \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://martinfowler.com/bliki/TwoHardThings.html\"}),`Cache invalidation and naming\nthings`),`. I'm not going to go\nover cache invalidation here but I will try to recommend how to cache async\nfunctions`),mdx(\"p\",null,`Caching async functions or promises in javascript can be somewhat confusing. I\nthink searching for info about it online is often misguided and results are\noften very specific to someones application Here is a method I have used to\ncache promises, or to memoize an async function. It may not handle all cases,\nbut it helps with some scenarios I have seen`),mdx(\"p\",null,\"Example async function: fetch from the pokemon API\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getPokemon() {\n  const id = Math.floor(Math.random() * 150)\n  const url = 'https://pokeapi.co/api/v2/pokemon/' + id\n  const ret = await fetch(url)\n  if (!ret.ok) {\n    throw new Error(\n      \\`Failed to fetch \\${url} HTTP \\${ret.status} \\${ret.statusText}\\`,\n    )\n  }\n  return ret.json()\n}\n`)),mdx(\"p\",null,\"How can we cache this function so that we only get one result\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getCachedPokemon() {\n  if (!this.res) {\n    this.res = getPokemon().catch(e =\u003e {\n      this.res = undefined\n      throw e\n    })\n  }\n  return this.res\n}\n`)),mdx(\"p\",null,`The important part of this function is that when I get an error, I clear the\nresource. The caller of the function, on error, will receive the error message,\nbut caching will not take place, allowing retries to take place later on.`),mdx(\"p\",null,\"See \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://cmdcolin.github.io/pokemon.html\"}),\"https://cmdcolin.github.io/pokemon.html\"),\" for demo\"),mdx(\"h2\",null,\"Footnote 1: Error handling\"),mdx(\"p\",null,`This demo also demonstrates some basic fetch error handling, and uses\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"statusText\"),\" \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText\"}),`which happens to not exist in\nHTTP/2`),`.\nIf you want a semblence of status message text in HTTP/2 you can try to use\nawait ret.json() or await ret.text() inside the catch clause, but note that it\ncould cause yet another error to be thrown`),mdx(\"h1\",null,\"Footnote 2: Cache types\"),mdx(\"p\",null,`You could also keep a cache in a global variable, or as a property on a class,\nor other methods. I have also found it useful to have a specific function for\nclearing the cache, so you can get a clean slate each time a test runs in unit\ntesting or similar`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-javascript\"}),`let res\nasync function getCachedPokemon() {\n  if (!res) {\n    res = getPokemon().catch(e =\u003e {\n      res = undefined\n      throw e\n    })\n  }\n  return res\n}\nfunction clearCache() {\n  res = undefined\n}\n`)),mdx(\"h2\",null,\"Footnote 3 - Aborting\"),mdx(\"p\",null,`If you want to handle aborting, it is a bit trickier. Aborting in javascript is\nhandled by\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController/AbortController\"}),\"AbortController\"),`.\nThis is an object that gives you an\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\"}),\"AbortSignal\"),`\nthat can be passed to fetch calls and the like to stop a big download from\nhappening.`),mdx(\"p\",null,`In our above example, if we passed an abort signal to the first call to fetch,\nand then aborted it, it would abort the fetch, `,mdx(\"a\",o({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\"}),`which throws a DOMException\ncalled\n\"AbortError\"`),`.\nYou can detect that it is an AbortError like this, and may choose not to\ndisplay or re-throw the abort exception`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-javascript\"}),`function isAbortException(e) {\n  return e instanceof Error \u0026\u0026 exception.name === 'AbortError'\n}\n`)),mdx(\"p\",null,`Now, what if 5 functions call getCachedPokemon(), all passing different abort\nsignals. What if the first one aborts? Then all the rest will get aborted also.\nBut what if we only want to abort the cached call if literally all of them\naborted? Then we may have to synthesize an abortcontroller inside our function`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-javascript\"}),`let res\nlet abortcontroller\nlet listeners = 0\nasync function getCachedPokemon(signal) {\n  if (!res) {\n    abortcontroller = new AbortController()\n\n    // synthesize a new signal instead of using the passed in signal\n    res = getPokemon(abortcontroller.signal).catch(e =\u003e {\n      res = undefined\n      throw e\n    })\n  }\n  if (signal) {\n    listeners++\n    // add listener to the passed in signal\n    signal.addEventListener('abort', () =\u003e {\n      listeners--\n      if (listeners === 0) {\n        abortcontroller.abort()\n      }\n    })\n  }\n  return res\n}\n`)),mdx(\"p\",null,`A library my team created,\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://github.com/GMOD/abortable-promise-cache\"}),\"abortable-promise-cache\"),`,\ntries to help with this scenario with a cleaner abstraction.`),mdx(\"h2\",null,\"Footnote 4\"),mdx(\"p\",null,`I have been playing through Pokemon Yellow and find it really amusing hence the\npokemon theme`),mdx(\"p\",null,`Fun stuff: The cutting room floor wiki with unused moves, sounds, and sprites\nin Pokemon Yellow `,mdx(\"a\",o({parentName:\"p\"},{href:\"https://tcrf.net/Pok%C3%A9mon_Yellow\"}),\"https://tcrf.net/Pok%C3%A9mon_Yellow\")))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-02-26-caching-promise"},"buildId":"EYD6Fjl0eBO4PUZJ0STIT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>