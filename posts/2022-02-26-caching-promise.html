<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Caching or memoizing promises</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/53d80a6545e3cb78.css" as="style"/><link rel="stylesheet" href="/_next/static/css/53d80a6545e3cb78.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-6db65d5e18d8108f.js" defer=""></script><script src="/_next/static/ma22oMDiDPE4UMkLLBMyy/_buildManifest.js" defer=""></script><script src="/_next/static/ma22oMDiDPE4UMkLLBMyy/_ssgManifest.js" defer=""></script><script src="/_next/static/ma22oMDiDPE4UMkLLBMyy/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Caching or memoizing promises</h1><h4>2022-02-26</h4></div><p>Caching promises in javascript can be somewhat confusing. I think searching for
info about it online is often misguided and results are often very specific to
someones application Here is a method I have used to cache promises, or to
memoize an async function. It may not handle all cases, but it helps with some
scenarios I have seen</p><p>Example async function: fetch from the pokemon API</p><pre><code class="language-javascript">async function getPokemon() {
  const id = Math.floor(Math.random() * 150)
  const url = &#x27;https://pokeapi.co/api/v2/pokemon/&#x27; + id
  const ret = await fetch(url)
  if (!ret.ok) {
    throw new Error(
      `Failed to fetch ${url} HTTP ${ret.status} ${ret.statusText}`,
    )
  }
  return ret.json()
}
</code></pre><p>How can we cache this function so that we only get one result</p><pre><code class="language-javascript">async function getCachedPokemon() {
  if (!this.res) {
    this.res = getPokemon().catch(e =&gt; {
      this.res = undefined
    })
  }
  return this.res
}
</code></pre><p>Whether you like the fact that I use <code>this</code> in the function is not the
important part necessarily</p><p>The important part is that when I get an error, I clear the resource. This
allows retries to take place later on</p><p>This demo also demonstrates some basic fetch error handling, and uses
<code>statusText</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText">which happens to not exist in
HTTP/2</a>.
If you want a semblence of status message text in HTTP/2 you can try to use
await ret.json() or await ret.text() inside the catch clause, but note that it
could cause yet another error to be thrown</p><p>See <a href="https://cmdcolin.github.io/pokemon.html">https://cmdcolin.github.io/pokemon.html</a> for demo</p><p>Footnote: you could also keep a cache in a global variable, and I have found it
is useful to have a specific function for clearing the cache, so you can get a
clean slate each time a test runs in unit testing or similar</p><pre><code class="language-javascript">let res
async function getCachedPokemon() {
  if (!res) {
    res = getPokemon().catch(e =&gt; {
      res = undefined
    })
  }
  return res
}
function clearCache() {
  res = undefined
}
</code></pre></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="https://scholar.google.com/citations?view_op=list_works&amp;hl=en&amp;user=--FwzsgAAAAJ">Publications</a> <a href="/sketches">Sketches</a> <a href="/kitty">Kitty</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Caching or memoizing promises","date":"2022-02-26","slug":"2022-02-26-caching-promise","mdxSource":{"compiledSource":"var u=Object.defineProperty,l=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(e,t,a)=\u003et in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,n=(e,t)=\u003e{for(var a in t||(t={}))r.call(t,a)\u0026\u0026c(e,a,t[a]);if(s)for(var a of s(t))i.call(t,a)\u0026\u0026c(e,a,t[a]);return e},p=(e,t)=\u003el(e,m(t));var h=(e,t)=\u003e{var a={};for(var o in e)r.call(e,o)\u0026\u0026t.indexOf(o)\u003c0\u0026\u0026(a[o]=e[o]);if(e!=null\u0026\u0026s)for(var o of s(e))t.indexOf(o)\u003c0\u0026\u0026i.call(e,o)\u0026\u0026(a[o]=e[o]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var o=a,{components:e}=o,t=h(o,[\"components\"]);return mdx(MDXLayout,p(n(n({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Caching promises in javascript can be somewhat confusing. I think searching for\ninfo about it online is often misguided and results are often very specific to\nsomeones application Here is a method I have used to cache promises, or to\nmemoize an async function. It may not handle all cases, but it helps with some\nscenarios I have seen`),mdx(\"p\",null,\"Example async function: fetch from the pokemon API\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getPokemon() {\n  const id = Math.floor(Math.random() * 150)\n  const url = 'https://pokeapi.co/api/v2/pokemon/' + id\n  const ret = await fetch(url)\n  if (!ret.ok) {\n    throw new Error(\n      \\`Failed to fetch \\${url} HTTP \\${ret.status} \\${ret.statusText}\\`,\n    )\n  }\n  return ret.json()\n}\n`)),mdx(\"p\",null,\"How can we cache this function so that we only get one result\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getCachedPokemon() {\n  if (!this.res) {\n    this.res = getPokemon().catch(e =\u003e {\n      this.res = undefined\n    })\n  }\n  return this.res\n}\n`)),mdx(\"p\",null,\"Whether you like the fact that I use \",mdx(\"inlineCode\",{parentName:\"p\"},\"this\"),` in the function is not the\nimportant part necessarily`),mdx(\"p\",null,`The important part is that when I get an error, I clear the resource. This\nallows retries to take place later on`),mdx(\"p\",null,`This demo also demonstrates some basic fetch error handling, and uses\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"statusText\"),\" \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText\"}),`which happens to not exist in\nHTTP/2`),`.\nIf you want a semblence of status message text in HTTP/2 you can try to use\nawait ret.json() or await ret.text() inside the catch clause, but note that it\ncould cause yet another error to be thrown`),mdx(\"p\",null,\"See \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cmdcolin.github.io/pokemon.html\"}),\"https://cmdcolin.github.io/pokemon.html\"),\" for demo\"),mdx(\"p\",null,`Footnote: you could also keep a cache in a global variable, and I have found it\nis useful to have a specific function for clearing the cache, so you can get a\nclean slate each time a test runs in unit testing or similar`),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`let res\nasync function getCachedPokemon() {\n  if (!res) {\n    res = getPokemon().catch(e =\u003e {\n      res = undefined\n    })\n  }\n  return res\n}\nfunction clearCache() {\n  res = undefined\n}\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-02-26-caching-promise"},"buildId":"ma22oMDiDPE4UMkLLBMyy","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>