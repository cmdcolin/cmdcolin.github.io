<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Caching or memoizing promises</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/53d80a6545e3cb78.css" as="style"/><link rel="stylesheet" href="/_next/static/css/53d80a6545e3cb78.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-6db65d5e18d8108f.js" defer=""></script><script src="/_next/static/z80U_SqoMWc0ZG9jeW97g/_buildManifest.js" defer=""></script><script src="/_next/static/z80U_SqoMWc0ZG9jeW97g/_ssgManifest.js" defer=""></script><script src="/_next/static/z80U_SqoMWc0ZG9jeW97g/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Caching or memoizing promises</h1><h4>2022-02-26</h4></div><p>Caching promises in javascript can be somewhat confusing. I think searching for
info about it online is often misguided and results are often very specific to
someones application Here is a method I have used to cache promises, or to
memoize an async function. It may not handle all cases, but it helps with some
scenarios I have seen</p><p>Example async function: fetch from the pokemon API</p><pre><code class="language-javascript">async function getPokemon() {
  const id = Math.floor(Math.random() * 150)
  const url = &#x27;https://pokeapi.co/api/v2/pokemon/&#x27; + id
  const ret = await fetch(url)
  if (!ret.ok) {
    throw new Error(
      `Failed to fetch ${url} HTTP ${ret.status} ${ret.statusText}`,
    )
  }
  return ret.json()
}
</code></pre><p>How can we cache this function so that we only get one result</p><pre><code class="language-javascript">async function getCachedPokemon() {
  if (!this.res) {
    this.res = getPokemon().catch(e =&gt; {
      this.res = undefined
      throw e
    })
  }
  return this.res
}
</code></pre><p>The important part of this function is that when I get an error, I clear the
resource. The caller of the function, on error, will receive the error message,
but caching will not take place, allowing retries to take place later on.</p><p>See <a href="https://cmdcolin.github.io/pokemon.html">https://cmdcolin.github.io/pokemon.html</a> for demo</p><h2>Footnote 1: Error handling</h2><p>This demo also demonstrates some basic fetch error handling, and uses
<code>statusText</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText">which happens to not exist in
HTTP/2</a>.
If you want a semblence of status message text in HTTP/2 you can try to use
await ret.json() or await ret.text() inside the catch clause, but note that it
could cause yet another error to be thrown</p><h1>Footnote 2: Cache types</h1><p>You could also keep a cache in a global variable, or as a property on a class,
or other methods. For globals, I have found it is useful to have a specific
function for clearing the cache, so you can get a clean slate each time a test
runs in unit testing or similar</p><pre><code class="language-javascript">let res
async function getCachedPokemon() {
  if (!res) {
    res = getPokemon().catch(e =&gt; {
      res = undefined
    })
  }
  return res
}
function clearCache() {
  res = undefined
}
</code></pre></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="https://scholar.google.com/citations?view_op=list_works&amp;hl=en&amp;user=--FwzsgAAAAJ">Publications</a> <a href="/sketches">Sketches</a> <a href="/kitty">Kitty</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Caching or memoizing promises","date":"2022-02-26","slug":"2022-02-26-caching-promise","mdxSource":{"compiledSource":"var l=Object.defineProperty,u=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(e,t,o)=\u003et in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,n=(e,t)=\u003e{for(var o in t||(t={}))s.call(t,o)\u0026\u0026c(e,o,t[o]);if(r)for(var o of r(t))i.call(t,o)\u0026\u0026c(e,o,t[o]);return e},h=(e,t)=\u003eu(e,m(t));var p=(e,t)=\u003e{var o={};for(var a in e)s.call(e,a)\u0026\u0026t.indexOf(a)\u003c0\u0026\u0026(o[a]=e[a]);if(e!=null\u0026\u0026r)for(var a of r(e))t.indexOf(a)\u003c0\u0026\u0026i.call(e,a)\u0026\u0026(o[a]=e[a]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var a=o,{components:e}=a,t=p(a,[\"components\"]);return mdx(MDXLayout,h(n(n({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Caching promises in javascript can be somewhat confusing. I think searching for\ninfo about it online is often misguided and results are often very specific to\nsomeones application Here is a method I have used to cache promises, or to\nmemoize an async function. It may not handle all cases, but it helps with some\nscenarios I have seen`),mdx(\"p\",null,\"Example async function: fetch from the pokemon API\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getPokemon() {\n  const id = Math.floor(Math.random() * 150)\n  const url = 'https://pokeapi.co/api/v2/pokemon/' + id\n  const ret = await fetch(url)\n  if (!ret.ok) {\n    throw new Error(\n      \\`Failed to fetch \\${url} HTTP \\${ret.status} \\${ret.statusText}\\`,\n    )\n  }\n  return ret.json()\n}\n`)),mdx(\"p\",null,\"How can we cache this function so that we only get one result\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getCachedPokemon() {\n  if (!this.res) {\n    this.res = getPokemon().catch(e =\u003e {\n      this.res = undefined\n      throw e\n    })\n  }\n  return this.res\n}\n`)),mdx(\"p\",null,`The important part of this function is that when I get an error, I clear the\nresource. The caller of the function, on error, will receive the error message,\nbut caching will not take place, allowing retries to take place later on.`),mdx(\"p\",null,\"See \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cmdcolin.github.io/pokemon.html\"}),\"https://cmdcolin.github.io/pokemon.html\"),\" for demo\"),mdx(\"h2\",null,\"Footnote 1: Error handling\"),mdx(\"p\",null,`This demo also demonstrates some basic fetch error handling, and uses\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"statusText\"),\" \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText\"}),`which happens to not exist in\nHTTP/2`),`.\nIf you want a semblence of status message text in HTTP/2 you can try to use\nawait ret.json() or await ret.text() inside the catch clause, but note that it\ncould cause yet another error to be thrown`),mdx(\"h1\",null,\"Footnote 2: Cache types\"),mdx(\"p\",null,`You could also keep a cache in a global variable, or as a property on a class,\nor other methods. For globals, I have found it is useful to have a specific\nfunction for clearing the cache, so you can get a clean slate each time a test\nruns in unit testing or similar`),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`let res\nasync function getCachedPokemon() {\n  if (!res) {\n    res = getPokemon().catch(e =\u003e {\n      res = undefined\n    })\n  }\n  return res\n}\nfunction clearCache() {\n  res = undefined\n}\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-02-26-caching-promise"},"buildId":"z80U_SqoMWc0ZG9jeW97g","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>