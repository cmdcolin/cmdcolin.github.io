<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="description" content="Astro description"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v6.0.0-beta.1"><title>Structural variants and the SAM format - the long (reads) and short (reads) of it</title><style>.container[data-astro-cid-4oxc2zqz]{max-width:800px;margin:0 auto;padding:0 1rem}article[data-astro-cid-lvjzyg5v]{max-width:100%}.post-content[data-astro-cid-lvjzyg5v]{margin:2rem 0;line-height:1.6}
</style>
<link rel="stylesheet" href="/_astro/Layout.Ca4IH_rv.css"></head> <body> <div class="mb-8"> <a href="/">Misc scribbles</a> </div>  <div class="container" data-astro-cid-4oxc2zqz>  <article data-astro-cid-lvjzyg5v> <div data-astro-cid-lvjzyg5v> <h1 data-astro-cid-lvjzyg5v>Structural variants and the SAM format - the long (reads) and short (reads) of it</h1> <h4 data-astro-cid-lvjzyg5v>2022-02-06</h4> </div> <div class="post-content" data-astro-cid-lvjzyg5v> <p>The
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf"><code>SAM</code> file format and its specification</a>
is pretty amazing, but it is also fairly terse and abstract. To really
understand what is going on with your reads, you probably gotta play around with
real world data and learn from tutorials.</p>
<p>I will try to relay some things I have learned over the years, with a bit of a
focus on how <code>SAM</code> file concepts can relate to structural variants.</p>
<p>Disclaimer: I’m a developer of JBrowse 2. This document has some screenshots and
links for it, feel free to try it at <a href="https://jbrowse.org">https://jbrowse.org</a>.</p>
<h2 id="basics">Basics</h2>
<h3 id="what-is-a-sam-file-and-how-does-it-relate-to-bam-and-cram">What is a <code>SAM</code> file, and how does it relate to <code>BAM</code> and <code>CRAM</code>?</h3>
<ul>
<li>
<p>A <code>SAM</code> file <strong>generally</strong> contains “reads” from a sequencer, with information
about how they are mapped to a reference genome [^1][^2].</p>
</li>
<li>
<p>A <code>SAM</code> file is <strong>generally</strong> produced when an aligner takes in raw, unaligned
reads (often stored in <code>FASTQ</code> format files) and aligns them to a reference
genome [^3].</p>
</li>
<li>
<p>A <code>SAM</code> file is a text format that you can read with your text editor. <code>BAM</code>
and <code>CRAM</code> are compressed representations of the <code>SAM</code> format.</p>
</li>
</ul>
<p>You generally see <code>BAM</code> or <code>CRAM</code> in the wild instead of <code>SAM</code> since the files
are very large, so the compressed versions are better to store on disk.</p>
<p>See Appendix E on how to convert between SAM/BAM/CRAM.</p>
<p>[^1] <code>SAM</code> can contain any type of sequence, not specifically reads. If you
created a <em>de novo</em> assembly, you could align the contigs of the <em>de novo</em>
assembly to a reference genome and store the results in <code>SAM</code>.</p>
<p>[^2] Does not always have to have information about mapping to a reference
genome. You can also store unaligned data in <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> (so-called
<code>uBAM</code> for example) but most of the time, the reads in <code>SAM</code> format are aligned
to a reference genome.</p>
<p>[^3] Examples of programs that do alignment include <code>bwa</code>, <code>bowtie</code>, and
<code>minimap2</code> (there are many others). These programs can all produce <code>SAM</code> outputs</p>
<h3 id="what-is-in-a-sambamcram-file">What is in a <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> file?</h3>
<p>A <code>SAM</code> file contains a “header” and a series of “records”.</p>
<h3 id="what-is-a-sam-record">What is a <code>SAM</code> “record”?</h3>
<p>A record is a single line in a <code>SAM</code> file, and it generally corresponds to a
single read, but as we will see, a split alignment may produce multiple records
that refer to the same source read.</p>
<p>Note that the words “read” and “record” are sometimes used interchangeably, but
record has the more specific meaning of being a single line in the <code>SAM</code> file.</p>
<h3 id="what-are-tags-in-a-sam-file">What are tags in a <code>SAM</code> file</h3>
<p>A SAM file has a core set of required fields, and then an arbitrary list of
extra columns called tags. The tags have a two-character abbreviation like <code>MQ</code>
(mapping quality) or many others. They can be upper or lower case. Upper case
tags are reserved for official usages (except those starting with X, Y, or Z, which are reserved for local/user-defined use).
See <a href="https://samtools.github.io/hts-specs/SAMtags.pdf">SAMtags.pdf</a> for more
details</p>
<h3 id="what-is-a-cigar-string-and-how-do-you-interpret-it">What is a <code>CIGAR</code> string, and how do you interpret it?</h3>
<p>A <code>CIGAR</code> string is a “compact idiosyncratic gapped alignment report”. It tells
you about insertions, deletions, and clipping. It is a series of “operators”
with lengths.</p>
<p>Insertion example:</p>
<p><code>50M50I50M</code></p>
<p>That would be 50bp of matching bases (<code>50M</code>), followed by a 50bp insertion
(<code>50I</code>), followed by another 50bp of matches (<code>50M</code>). The 50bp insertion means
the read contains 50 bases in the middle, which did not match the reference
genome that you are comparing the read to.</p>
<p>Clipping example:</p>
<p><code>50S50M50S</code></p>
<p>This means that 50bp matched (<code>50M</code> in the middle of the <code>CIGAR</code> string) and
both sides of the read are soft-clipped. The clipping means the aligner was not
able to align the reads on either side.</p>
<p>Notes:</p>
<ul>
<li>
<p><em>Finding mismatches</em>: A <code>CIGAR</code> string match like <code>50M</code> means 50 bases
“matched” the reference genome, but that only means that there are no
insertions or deletions in those 50 bases. There could be underlying
mismatches in the read compared to the reference. Note: there is also
“extended <code>CIGAR</code>” that replaces <code>M</code> with <code>=</code> (exact match) and <code>X</code>
(mismatch). Also see Appendix D on the <code>MD</code> tag and finding where the
mismatches are, but note that <code>MD</code> tag is tricky</p>
</li>
<li>
<p><em>Ambiguity of representation</em>: A <code>CIGAR</code> string with insertions and deletions
could be <code>50M1D1I50M</code>. This string had a 1bp deletion and a 1bp insertion
back-to-back. This could be just a mismatch! There is ambiguity in sequence
alignment representations. Downstream programs must accommodate this.</p>
</li>
<li>
<p><em>Split records and soft-clipping</em>: A <code>CIGAR</code> string with soft-clipping
<code>500S50M</code> this means that 500 bases of the read were not aligned at this
position, but 50 bases were!</p>
</li>
</ul>
<p>See <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> for all the
CIGAR operators.</p>
<p>If you are working with <code>SAM</code> data, you will often write loops that directly
parse CIGAR strings. See Appendix B for handy functions for parsing <code>CIGAR</code>
strings. Don’t fear the <code>CIGAR</code>!</p>
<p>Note regarding soft clipping: this will be discussed further in this post, but
“supplementary alignments” might indicate that e.g. those 500 bases that were
soft-clipped aligned to another region on the genome</p>
<h3 id="how-do-you-determine-start-and-end-and-strand-of-a-record">How do you determine “start” and “end” and “strand” of a record?</h3>
<p>SAM records do not have easy-to-interpret “start” and “end” and “strand” fields
like, say, lines in a <code>BED</code> file do</p>
<p>Instead, each SAM record has:</p>
<ul>
<li>A single <code>POS</code> coordinate</li>
<li>A <code>CIGAR</code> string</li>
<li>A flags field, that might say “read reverse complemented”</li>
</ul>
<p>Using this, you can find the “end” coordinate of a record by starting at the POS
coordinate and enumerating the reference-consuming operators of the <code>CIGAR</code>:
matches (M/=/X), deletions (D), and skips (N). Processing the whole <code>CIGAR</code> effectively
gives you the “end” coordinate on the reference genome, so “end” is derived from
the <code>CIGAR</code>. The “start” field corresponds to the <code>POS</code> field</p>
<h3 id="what-are-forward-and-reverse-strand-reads">What are “forward” and “reverse” strand reads?</h3>
<p>Reads can align to the “forward strand” of the reference genome (e.g. it matches
the DNA letters as written in the reference genome FASTA file), resulting in
“forward strand reads”.</p>
<p>Or, they can align to the reverse complement of the DNA in the reference genome,
resulting in “reverse strand reads”.</p>
<p>Strandedness is recorded for each record in the SAM/BAM/CRAM file by having the
SAM flags bitwise flag 16 enabled
(<a href="https://broadinstitute.github.io/picard/explain-flags.html">https://broadinstitute.github.io/picard/explain-flags.html</a>), the flag there is
referred to as “read reverse strand”</p>
<h3 id="do-you-count-backwards-with-the-cigar-for-reverse-strand-reads">Do you count backwards with the <code>CIGAR</code> for reverse strand reads?</h3>
<p>As mentioned above, you get the “start” and “end” by processing the <code>CIGAR</code>, so
one might wonder whether you count “downwards” from POS for reverse strand
reads. This is actually not correct though</p>
<p>Here is what the <code>SAM</code> spec has to say about this</p>
<blockquote>
<p>“<code>POS</code> is the 1-based leftmost mapping POSition of the first <code>CIGAR</code> operation
that “consumes” a reference base”</p>
</blockquote>
<p>And regarding <code>CIGAR</code> and other fields:</p>
<blockquote>
<p>“For segments that have been mapped to the reverse strand, the recorded <code>SEQ</code>
is reverse complemented from the original unmapped sequence and <code>CIGAR</code>,
<code>QUAL</code>, and strand-sensitive optional fields are reversed and thus recorded
consistently with the sequence bases as represented”</p>
</blockquote>
<p>That is a little bit of a mind boggle but effectively, no matter whether the
record is forward or reverse strand, you count upwards when processing the
<code>CIGAR</code>.</p>
<p>You can see in an example of this in SAMv1 section 1.1 — the read <code>r001/2</code> is a
“reverse strand” read, and its <code>POS</code>, or “start” position, is 37, and then the
<code>CIGAR</code> (9M, 9 matches) counts upwards from there, giving it an “end” position
of 45.</p>
<h3 id="how-are-reads-ordered-in-a-sam-file">How are reads ordered in a <code>SAM</code> file</h3>
<p>When you run an aligner program like bwa or minimap2, you type e.g.</p>
<pre><code>minimap2 -a reference_genom.fa reads.fq > out.sam
</code></pre>
<p>out.sam will be ordered in the same order as the fastq. For preparation for
loading into analysis tools or genome browsers, we will often sort the reads
using <code>samtools sort</code> which will group by chromosome name, and then increasing
in coordinate start position. Then <code>samtools index</code> creates an index file (e.g.
bam.bai, cram.crai). The index file lets you quickly query the reads in a
specific genomic region (e.g. with <code>samtools view myfile chr10:1000-2000</code>)</p>
<h3 id="what-happens-to-reads-that-dont-align-to-the-genome">What happens to reads that don’t align to the genome</h3>
<p>If a read failed to align to the reference genome, it may still be in your <code>SAM</code>
file, marked as unmapped using the flag column. Sometimes, “dumpster diving”
(looking at the unmapped records from a <code>SAM</code> file) can be used to aid
structural variant searches (e.g. there may be novel sequence in there not from
the reference genome that could be assembled)</p>
<h2 id="detecting-svs-from-long-reads">Detecting SVs from long reads</h2>
<p>Long reads offer a wide array of methods for detecting SVs</p>
<ul>
<li><em>Small insertions/deletions</em>: Long reads can completely span moderate sized
insertions and deletions, indicated by <code>I</code> or <code>D</code> in a <code>CIGAR</code> string.</li>
<li><em>Large insertions/deletions</em>: If a long read does not completely span an
insertion or deletion, it may be split aligned on either side of the SV or
could be soft/hard clipped where it can’t align all the way through an
insertion.</li>
<li><em>Translocations</em>: A split long alignment can span long-range or even
inter-chromosomal translocations, so part of the read maps to one chromosome
and one part maps to the other</li>
<li><em>Inversions</em>: A split alignment can span an inversion. In this case, long
reads can be split into multiple parts, one part of it aligns in the reverse
orientation, while the other part aligns in the forward orientation</li>
</ul>
<p>Note that there are many different methods for detecting SVs from long reads,
e.g. not all use mapped reads from SAM files, some use <em>de novo</em> assembly, but
it is still useful to be familiar with mapped read methods.</p>
<h3 id="what-are-splitsupplementarychimeric-alignments">What are split/supplementary/chimeric alignments?</h3>
<p>Split alignments, or chimeric alignments, are alignments where part of the read
maps to one place, and another part to another. For example, part of a long read
may map to <code>chr1</code> and part of it maps to <code>chr4</code>. It is worth reading the
definition of “Chimeric alignment” from
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> when you get the
chance.</p>
<p>As <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> tells us, one
record is marked as “representative”, sometimes also called the “primary”
record, while the other components of the split read are marked “supplementary”,
given the 2048 flag. The “primary” record generally has a <code>SEQ</code> field that
represents the entirety of the original read’s sequence (with CIGAR soft
clipping operators saying which part of that sequence aligned), and the
“supplementary alignments” will have <code>SEQ</code> field but sometimes just segments of
the original read’s sequence with CIGAR hard clipping operators indicating that
it is partial.</p>
<p>Supplementary alignments are especially common with long reads, and it can be a
signal for structural variants e.g. where two chromosomes are fused together,
and parts of the read align to multiple chromosomes, or the split alignment may
align to either side of a large deletion, or they may be split to align through
an inversion (part of it aligns to the forward strand, part of it to the reverse
strand, and again the forward strand)</p>
<p>There is no limitation on how many splits might occur so the split can align to
3, 4, or more different places. Each part of the split puts a new line in the
SAM file, and note that all the records also have the same read name, or <code>QNAME</code>
(first column of <code>SAM</code>).</p>
<h3 id="what-are-secondary-alignmentsmulti-mappers">What are secondary alignments/multi-mappers</h3>
<p>Secondary alignments generally come from “multi-mappers” where the entire read
maps equally well (or at least somewhat equally well) to, say, somewhere on both
<code>chr4</code> and <code>chr1</code>. “Multi mapping” results in secondary alignments, while split
reads result in supplementary alignments. See “Multiple mapping” in the
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> for the definition
of multi-mapping. Note also that secondary alignments sometimes are missing the
<code>SEQ</code> field entirely too, see
<a href="https://github.com/lh3/minimap2/issues/458#issuecomment-516661855">https://github.com/lh3/minimap2/issues/458#issuecomment-516661855</a></p>
<p>I wrote a tool called secondary_rewriter to add the <code>SEQ</code> field back to
secondary alignments, which may help in some cases</p>
<h3 id="what-is-the-sa-tag">What is the <code>SA</code> tag?</h3>
<p>The <code>SA</code> tag is outputted on each part of the supplementary/split/chimeric
alignment, e.g. the primary contains an <code>SA</code> tag that refers to information
(e.g. the location) of where all the supplementary alignments where placed, and
each of the supplementary alignments also contains an <code>SA</code> tag that refers to
the primary alignment and each other supplementary alignment.</p>
<p>Fun fact: The <code>SA</code> tag conceptually can result in a ‘quadratic explosion’ of
data, because each part of the split contains references to every other part.
For example, if a read is split into 4 pieces, then each record would have an
<code>SA</code> tag with 3 segments, so 3*4 segments will be documented in the <code>SA</code> tag.
In many cases, this is not a problem, but if you imagine a finished chromosome
aligned to a draft assembly, it may get split so many times that this could be a
factor.</p>
<p>See <a href="https://samtools.github.io/hts-specs/SAMtags.pdf">SAMtags.pdf</a> for more
info on the <code>SA</code> tag.</p>
<h3 id="visualizing-split-reads-across-a-breakend-or-translocation">Visualizing split reads across a breakend or translocation</h3>
<p>This is a specialized JBrowse 2 feature, but if there is an inter-chromosomal
translocation, you can load this into JBrowse and visualize support for this
event using our “breakpoint split view”. This view shows the evidence for the
reads that are split aligned across an SV, and can show connections between
paired-end reads across an SV too.</p>
<p>We also have a workflow called the “SV inspector” that helps you setup the
“breakpoint split views” (<a href="https://jbrowse.org/jb2/docs/user_guide/#sv-inspector">https://jbrowse.org/jb2/docs/user_guide/#sv-inspector</a>.
The SV inspector and Breakpoint split view work best on Breakends (e.g. VCF 4.3
section 5.4) and <code>&#x3C;TRA></code> (translocation) events from <code>VCF</code>, or <code>BEDPE</code> formatted
SV calls, and you can launch the “breakpoint split view” from the “SV inspector”</p>
<p><img src="/media/breakpoint_split_view.png" alt=""></p>
<h3 id="visualizing-a-read-vs-reference-view-given-a-split-alignment">Visualizing a ‘read vs reference’ view given a split alignment</h3>
<p>If we are given the primary alignment of an arbitrary split read, then we can
construct what that split looks like compared to the reference genome.</p>
<p>If we are not given the primary alignment (e.g. we are starting from a
supplementary alignment) then we can search the <code>SA</code> list for the one that is
primary, because at least one will be.</p>
<p>Now that we have the primary alignment, it will have the <code>SEQ</code> (of the entire
read, the supplementary alignments typically have a blank <code>SEQ</code>!) and the <code>SA</code>
tag containing the <code>CIGAR</code> of all the different parts of the split. We can then
construct how the entire read, not just a particular record of the split
alignment, compares to the genome. In JBrowse 2 we implemented this, and it uses
a synteny-style rendering. [1]</p>
<p><img src="/media/linear_alignment.png" alt=""></p>
<p>Figure showing JBrowse 2 piecing together a long read vs the reference genome
from a single read</p>
<p>In order to do this reconstruction, JBrowse 2 takes the <code>CIGAR</code> strings of the
primary alignment and each of the pieces of the <code>SA</code> tag (it is a semi-colon
separated list of chunks), sort them by the amount of softclipping (the
softclipping values will progressively trim off more of the <code>SEQ</code> telling you it
aligned further and further on in the long read), and then this tells me where
each piece of the split alignment came from in the original <code>SEQ</code>, so we can
plot the alignments of the read vs the reference genome using synteny style
display.</p>
<p>[1] Similar functionality also exists in GenomeRibbon <a href="https://genomeribbon.org">https://genomeribbon.org</a></p>
<h3 id="sam-vs-vcf---breakends-vs-split-alignments"><code>SAM</code> vs <code>VCF</code> - Breakends vs split alignments</h3>
<p>An interesting outcome (to me) is that from a single record in a <code>SAM</code> file, I
can reconstruct the “derived” genome around a region of interest from a single
read.</p>
<p>If I were to try to do this with the <code>VCF</code> Breakend specification (section 5.4
of <a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">VCF4.3.pdf</a>), it may
actually be more challenging than from a <code>SAM</code> read. This is because a Breakend
in <code>VCF</code> format is only an edge in a graph (and the sequences are nodes).
Therefore, in order to properly reconstruct a structural variant from a <code>VCF</code>
with Breakends, I would have to construct a graph and decode paths through it.</p>
<p>I like the ability to reconstruct the derived genome from a single read, but
individual reads can be noisy (contain errors). That said, <em>de novo</em> assembled
contigs can also be stored in <code>SAM</code> format and is significantly less noisy
(being composed of the aggregate information of many reads).</p>
<p>The point though is that interpretation of the <code>VCF</code> breakend specification is
challenging due to imposing a sequence graph on the genome, while the <code>SA</code> tag
remains just a simple set of linear alignments that can easily be pieced
together, and you only need to refer to a single record in the <code>SAM</code> file to do
so.</p>
<p>I am not aware of a lot of tools that work on the <code>VCF</code> Breakend graph, and
expect more will need to be created to truly work with this standard. An
inversion for example may create 4 records in the <code>VCF</code> file (see section 5.4 in
the <a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">VCF4.3.pdf</a> for example),
and needs careful interpretation.</p>
<h3 id="haplotype-tagged-reads">Haplotype-tagged reads</h3>
<p>A new trend has been to create <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> files with tagged reads, which
tells us which haplotype a read was inferred to have come from. This is commonly
done with the <code>HP</code> tag, which might have <code>HP=1</code> and <code>HP=2</code> for a diploid genome.
Tools like <code>whatshap</code> can add these tags to a <code>SAM</code> file, and IGV and JBrowse 2
can color and sort by these tags.</p>
<p><img src="/media/color_by_tag.png" alt=""></p>
<p>Screenshot of JBrowse 2 with the “Color by tag” and “Sort by tag” settings
enabled (coloring and sorting by the <code>HP</code> tag), letting us see that only one
haplotype has a deletion. Tutorial for how to do this in JBrowse 2 here
<a href="https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag">https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag</a></p>
<h2 id="how-do-you-detect-svs-with-paired-end-reads">How do you detect SVs with paired-end reads?</h2>
<h3 id="distance-between-pairs-being-abnormally-large-or-short">Distance between pairs being abnormally large or short</h3>
<p>The distance between pairs is encoded by the <code>TLEN</code> column in the <code>SAM</code> format.
The distance between pairs with good mapping is relatively constant and called
the “insert length”. This comes from how the sequencing is done: paired-end
sequencing performs sequencing on both ends of a fragment.</p>
<p>But, if you are mapping reads vs the reference genome, and you observe that they
are abnormally far apart, say 50kb apart instead of 1kb apart, this may indicate
there your sample contains a deletion relative to the reference.</p>
<p><img src="/media/aberrant_size.png" alt=""></p>
<p>Screenshot of JBrowse 1 with “View as pairs” enabled with “mate paired”
sequencing, and large insert size colored as red (from
<a href="https://jbrowse.org/docs/paired_reads.html">https://jbrowse.org/docs/paired_reads.html</a>. Note that some of JBrowse 1’s View
as pairs features are not yet available in JBrowse 2</p>
<h3 id="mate-pairs-vs-paired-end-reads">Mate pairs vs paired end reads</h3>
<p>“Mate paired” reads have a larger distance between pairs (aka the insert size is
larger). Think: mate pairs have 2-5kb between pairs instead of a couple hundred
bp. Mate pairs can be useful in scaffolding de novo genome assemblies since the
larger range can span gaps, giving evidence that multiple contigs are connected.</p>
<p>“Paired-end” reads typically have like 200-500bp distance between pairs (aka,
the insert size).</p>
<p>Data sheet
<a href="https://web.archive.org/web/20210827021305/https://www.illumina.com/Documents/products/datasheets/datasheet_genomic_sequence.pdf">https://web.archive.org/web/20210827021305/https://www.illumina.com/Documents/products/datasheets/datasheet_genomic_sequence.pdf</a></p>
<p>The above JBrowse screenshot shows mate pairs. Note that mate pairs have a
different pair orientation, and pairs don’t necessarily point at each other,
they “point away from each other” in normal conditions due to how the library is constructed. See Appendix A for
more info.</p>
<h3 id="linked-reads-aka-simulated-long-reads">Linked reads aka simulated long reads</h3>
<p>Linked reads are another method that uses short reads but gives long read
information. I don’t have a lot of info on this but I will update this section
if I do. The company, 10x genomics, that originally used this discontinued
commercial sequencing using this method to focus instead on single cell AFAIK.
<a href="https://www.10xgenomics.com/products/linked-reads">https://www.10xgenomics.com/products/linked-reads</a></p>
<h3 id="an-abundance-of-reads-being-clipped-at-a-particular-position">An abundance of reads being “clipped” at a particular position</h3>
<p>This can indicate that part of the reads map well, but then there was an abrupt
stop to the mapping. This might mean that there is a sequence that was an
insertion at that position, or a deletion, or a translocation.</p>
<p>The clipping is indicated by the <code>CIGAR</code> string, either at the start or end of
it by an <code>S</code> or an <code>H</code>. The <code>S</code> indicates “soft clipping”, and indicates that
the sequence of the clipped portion can be found in the <code>SEQ</code> field of the
primary alignment. The <code>H</code> is hard clipped, and the sequence that is hard
clipped will not appear in the <code>SEQ</code>.</p>
<p><img src="/media/clipping_pileup.png" alt=""></p>
<p>Screenshot of JBrowse 2 showing blue clipping indicator with a “pileup” of
soft-clipping at a particular position shown in blue. The clipping is an
“interbase” operation (it occurs between base pair coordinates) so it is plotted
separately from the normal coverage histogram.</p>
<p><img src="/media/show_soft_clipping.png" alt=""></p>
<p>Screenshot of JBrowse 2 showing an insertion with Nanopore (top), PacBio
(middle) and Illumina short reads. The long reads may completely span the
insertion, so the <code>CIGAR</code> string on those have an <code>I</code> operator and are indicated
by the purple triangle above the reads. For the short reads, the reads near the
insertion will be clipped since they will not properly map to the reference
genome and cannot span the insertion. The “Show soft clipping” setting in
JBrowse 2 and IGV can be used to show visually the bases that extend into the
insertion (shown on the bottom track).</p>
<h3 id="unexpected-pair-orientation">Unexpected pair orientation</h3>
<p>With standard paired end sequencing, the pairs normally point at each other</p>
<pre><code>
forward reverse ---> &#x3C;---

</code></pre>
<p>If the stranded-ness of the pair is off, then it could indicate a structural
variant. See Appendix A for a handy function for calculating pair orientation.</p>
<p>This guide from IGV is helpful for interpreting the pair directionality with
patterns of SVs using “Color by pair orientation”</p>
<p><a href="https://software.broadinstitute.org/software/igv/interpreting_pair_orientations">https://software.broadinstitute.org/software/igv/interpreting_pair_orientations</a></p>
<p><img src="/media/inverted_duplication.png" alt=""></p>
<p>Figure: JBrowse 2 showing an inverted (tandem) duplication in 1000 genomes data.
It uses the same coloring as IGV for pair orientation. The tandem duplication
can produce green arrows which have reads pointing in opposite directions e.g.
<code>&#x3C;--</code> and <code>--></code>, while blue arrows which can indicate an inversion point in the
same direction e.g. <code>--></code> and <code>--></code></p>
<h3 id="caveat-about-tlen">Caveat about TLEN</h3>
<p>Note that <code>TLEN</code> is a field in the SAM format that is somewhat ill-defined, at
least in the sense that different tools may use it differently
<a href="https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767">https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767</a></p>
<p>If needed, you can calculate <code>TLEN</code> yourself if you process the file yourself
(e.g. process all reads, get the actual records for the pairs, and calculate
distance) but I have not had trouble with relying on the <code>TLEN</code> from the data
files themselves.</p>
<h2 id="calling-copy-number-variants-with-your-short-or-long-reads">Calling copy number variants with your short or long reads</h2>
<p>Another type of SV that you can get from your <code>SAM</code> files are copy number
variants (CNVs). By looking at the depth-of-coverage for your data files, you
can look for abnormalities that may indicate copy number variants. By using a
tool like <code>mosdepth</code>, you can quickly get a file showing the coverage across the
genome.</p>
<p>Be aware that if you are comparing the coverage counts from different tools,
they have different defaults that may affect comparison. Some discard <code>QC_FAIL</code>,
<code>DUP</code>, and <code>SECONDARY</code> flagged reads. This is probably appropriate, and
corresponds to what most genome browsers will display (see
<a href="https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af">https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af</a> for a short
summary of depth calculated from different tools)</p>
<p>Note that both long and short reads can be used for CNV detection. Long reads
may give more accurate measurements also, with their better ability to map
smoothly through difficult regions of the genome.</p>
<p><img src="/media/coverage_cnv.png" alt=""></p>
<p>Screenshot showing coverage in <code>BigWig</code> format from nanopore reads on normal and
tumor tissue from a melanoma cancer cell line (COLO829) plotted using JBrowse 2.
This coverage data is calculated from nanopore sequencing from
<a href="https://www.biorxiv.org/content/10.1101/2020.10.15.340497v1.full">here</a> using
<a href="https://github.com/brentp/mosdepth"><code>mosdepth</code></a>, converted from <code>BedGraph</code> to
<code>BigWig</code>, and loaded into JBrowse 2. See
(<a href="https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json&#x26;session=share-MZj3d18lzH&#x26;password=3X7bS">demo</a>
and
<a href="https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv">tutorial</a>)</p>
<h2 id="the-future-with-graph-genomes-and-de-novo-assemblies">The future, with graph genomes and <em>de novo</em> assemblies</h2>
<p>Currently, SV visualization is highly based on comparing data versus a reference
genome (and the <code>SAM</code> format is a signature of this: it stores data in terms of
reference genome coordinates). In the future, SV visualization may look more
similar to comparative genomics, where we compare an SV to a population-specific
reference from a graph genomes or something like this.</p>
<p>It is known that <em>de novo</em> assembly has more power to detect SVs than some read
operations (<a href="https://twitter.com/lh3lh3/status/1362921612690010118/photo/1">https://twitter.com/lh3lh3/status/1362921612690010118/photo/1</a>). As <em>de
novo</em> assembled genomes improve and become more widespread, we may see a shift
in how SVs are called</p>
<p>I would also like to see improved ability to do fast or ‘on the fly’ gene
prediction on the <em>de novo</em> assembled genomes, and we can see what SNPs or
modified splicing might look like in copies of genes (e.g. derived regions of
the CNV duplications).</p>
<p>Fun fact: the
<a href="https://github.com/lh3/gfatools/blob/master/doc/rGFA.md#the-graph-alignment-format-gaf"><code>GAF</code></a>
(graphical alignment format) is a strict superset of
<a href="https://github.com/lh3/miniasm/blob/master/PAF.md"><code>PAF</code></a> (pairwise alignment
format) by storing graph node labels in the <code>target name</code> slot of <code>PAF</code>, and can
refer to an <code>rGFA</code> (reference genome graph)! Looking forward to the graph genome
world.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Algorithms that call structural variants face many challenges, but understanding
how the reads are encoded in SAM format, and seeing what they look like in the
genome browser is a useful first step to gaining a better understanding.</p>
<p>In summary, some of the signatures of SVs may include:</p>
<ul>
<li>Aberrant insert size (<code>TLEN</code>) detection (longer for deletion, shorter for
insertion)</li>
<li>Aberrant pair orientation (pairs are not pointing at each other)</li>
<li>Split-read detection (<code>SA</code> tag)</li>
<li><code>CIGAR</code> string processing (<code>D</code> operator for deletions, <code>I</code> operator for
insertions)</li>
<li>Over-abundance of clipping (<code>S</code> or <code>H</code> operators in <code>CIGAR</code>)</li>
<li>Depth of coverage changes for CNVs</li>
<li>Aligning <em>de novo</em> assembly vs a reference genome
(<a href="https://twitter.com/lh3lh3/status/1362921612690010118/photo/1">https://twitter.com/lh3lh3/status/1362921612690010118/photo/1</a>) which can
output <code>SAM</code>, but it can also output
<a href="https://github.com/lh3/miniasm/blob/master/PAF.md"><code>PAF</code></a> format (which can
be loaded in JBrowse 2 in the synteny views). Techniques of detecting SVs on
PAF will be fundamentally pretty similar to the techniques listed above but
may look a bit different (see <code>cs</code> tag in <code>PAF</code> for example, it is a modified
<code>CIGAR</code>-like string)</li>
</ul>
<p>If you have any ideas I should include here, let me know!</p>
<h3 id="appendix-a-interpreting-pair-orientation">Appendix A: Interpreting pair orientation</h3>
<p>This may be unnecessarily low-level code for this article, but it could be
helpful utility to help determine the pair orientation from a single
SAM/BAM/CRAM record.</p>
<pre><code class="language-ts"><a-c>// @param flags - flags from a single read</a-c>
<a-c>// @param ref - the string of the reference sequence, just used to determine if it matches rnext</a-c>
<a-c>// @param rnext - the string of the RNEXT, just used to determine if it matches ref</a-c>
<a-c>// @param tlen - the TLEN field from SAM</a-c>
<a-c>// @return e.g. F1R2 normal paired end orientation</a-c>
<a-k>function</a-k> <a-f>getPairOrientation</a-f><a-p>(</a-p>
  <a-v>flags</a-v>: <a-t>number</a-t><a-p>,</a-p>
  <a-v>ref</a-v>: <a-t>string</a-t><a-p>,</a-p>
  <a-v>rnext</a-v>: <a-t>string</a-t><a-p>,</a-p>
  <a-v>tlen</a-v>: <a-t>number</a-t><a-p>,</a-p>
<a-p>)</a-p> <a-p>{</a-p>
  <a-c>// this read is not unmapped &#x26;&#x26;</a-c>
  <a-c>// this read's mate is also not unmapped &#x26;&#x26;</a-c>
  <a-c>// this read's mate is on the same reference genome</a-c>
  <a-k>if</a-k> <a-p>(</a-p><a-o>!</a-o><a-p>(</a-p><a-v>flags</a-v> <a-o>&#x26;</a-o> <a-n>4</a-n><a-p>)</a-p> <a-o>&#x26;&#x26;</a-o> <a-o>!</a-o><a-p>(</a-p><a-v>flags</a-v> <a-o>&#x26;</a-o> <a-n>8</a-n><a-p>)</a-p> <a-o>&#x26;&#x26;</a-o> <a-v>ref</a-v> <a-o>===</a-o> <a-v>rnext</a-v><a-p>)</a-p> <a-p>{</a-p>
    <a-k>const</a-k> <a-v>s1</a-v> <a-o>=</a-o> <a-v>flags</a-v> <a-o>&#x26;</a-o> <a-n>16</a-n> ? <a-s>'R'</a-s> : <a-s>'F'</a-s>
    <a-k>const</a-k> <a-v>s2</a-v> <a-o>=</a-o> <a-v>flags</a-v> <a-o>&#x26;</a-o> <a-n>32</a-n> ? <a-s>'R'</a-s> : <a-s>'F'</a-s>
    <a-k>let</a-k> <a-v>o1</a-v> <a-o>=</a-o> <a-s>' '</a-s>
    <a-k>let</a-k> <a-v>o2</a-v> <a-o>=</a-o> <a-s>' '</a-s>

    <a-c>// if first in pair</a-c>
    <a-k>if</a-k> <a-p>(</a-p><a-v>flags</a-v> <a-o>&#x26;</a-o> <a-n>64</a-n><a-p>)</a-p> <a-p>{</a-p>
      <a-v>o1</a-v> <a-o>=</a-o> <a-s>'1'</a-s>
      <a-v>o2</a-v> <a-o>=</a-o> <a-s>'2'</a-s>
    <a-p>}</a-p>

    <a-c>// else if second in pair</a-c>
    <a-k>else</a-k> <a-k>if</a-k> <a-p>(</a-p><a-v>flags</a-v> <a-o>&#x26;</a-o> <a-n>128</a-n><a-p>)</a-p> <a-p>{</a-p>
      <a-v>o1</a-v> <a-o>=</a-o> <a-s>'2'</a-s>
      <a-v>o2</a-v> <a-o>=</a-o> <a-s>'1'</a-s>
    <a-p>}</a-p>

    <a-k>const</a-k> <a-v>tmp</a-v> <a-o>=</a-o> <a-p>[]</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>tlen</a-v> <a-o>></a-o> <a-n>0</a-n><a-p>)</a-p> <a-p>{</a-p>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>0</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>s1</a-v>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>1</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>o1</a-v>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>2</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>s2</a-v>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>3</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>o2</a-v>
    <a-p>}</a-p> <a-k>else</a-k> <a-p>{</a-p>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>2</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>s1</a-v>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>3</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>o1</a-v>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>0</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>s2</a-v>
      <a-v>tmp</a-v><a-p>[</a-p><a-n>1</a-n><a-p>]</a-p> <a-o>=</a-o> <a-v>o2</a-v>
    <a-p>}</a-p>
    <a-k>return</a-k> <a-v>tmp</a-v><a-p>.</a-p><a-f>join</a-f><a-p>(</a-p><a-s>''</a-s><a-p>)</a-p>
  <a-p>}</a-p>
  <a-k>return</a-k> <a-co>null</a-co>
<a-p>}</a-p>
</code></pre>
<p>Then this can be broken down further by orientation type</p>
<ul>
<li>Paired end reads are “fr”</li>
<li>Mate pair reads are “rf”</li>
</ul>
<p>So you can interpret e.g. F1R2 in relation to being a paired end read (fr) or
mate pair (rf) below and with this link
<a href="https://software.broadinstitute.org/software/igv/interpreting_pair_orientations">https://software.broadinstitute.org/software/igv/interpreting_pair_orientations</a></p>
<pre><code class="language-json">{
  <a-s>"fr"</a-s>: {
    <a-s>"F1R2"</a-s>: <a-s>"LR"</a-s>,
    <a-s>"F2R1"</a-s>: <a-s>"LR"</a-s>,

    <a-s>"F1F2"</a-s>: <a-s>"LL"</a-s>,
    <a-s>"F2F1"</a-s>: <a-s>"LL"</a-s>,

    <a-s>"R1R2"</a-s>: <a-s>"RR"</a-s>,
    <a-s>"R2R1"</a-s>: <a-s>"RR"</a-s>,

    <a-s>"R1F2"</a-s>: <a-s>"RL"</a-s>,
    <a-s>"R2F1"</a-s>: <a-s>"RL"</a-s>
  },

  <a-s>"rf"</a-s>: {
    <a-s>"R1F2"</a-s>: <a-s>"LR"</a-s>,
    <a-s>"R2F1"</a-s>: <a-s>"LR"</a-s>,

    <a-s>"R1R2"</a-s>: <a-s>"LL"</a-s>,
    <a-s>"R2R1"</a-s>: <a-s>"LL"</a-s>,

    <a-s>"F1F2"</a-s>: <a-s>"RR"</a-s>,
    <a-s>"F2F1"</a-s>: <a-s>"RR"</a-s>,

    <a-s>"F1R2"</a-s>: <a-s>"RL"</a-s>,
    <a-s>"F2R1"</a-s>: <a-s>"RL"</a-s>
  }
}
</code></pre>
<h3 id="appendix-b---cigar-parsing">Appendix B - <code>CIGAR</code> parsing</h3>
<pre><code class="language-ts"><a-c>// @param cigar: CIGAR string in text form</a-c>
<a-c>// @returns an array of elements like ['30','M', '2','I', '50','M', '40','D']</a-c>
<a-c>// which you can consume in a loop two elements at a time</a-c>
<a-k>function</a-k> <a-f>parseCigar</a-f><a-p>(</a-p><a-v>cigar</a-v>: <a-t>string</a-t><a-p>)</a-p> <a-p>{</a-p>
  <a-k>return</a-k> <a-v>cigar</a-v><a-p>.</a-p><a-f>split</a-f><a-p>(</a-p><a-o>/</a-o><a-s>([MIDNSHPX=])</a-s><a-o>/</a-o><a-p>)</a-p>
<a-p>}</a-p>
</code></pre>
<p>Then parse the returned array two at a time</p>
<pre><code class="language-ts"><a-c>// this function does nothing, but is informative for how to interpret a</a-c>
<a-c>// CIGAR string</a-c>
<a-c>// @param cigar - CIGAR string from record</a-c>
<a-c>// @param readSeq -  the SEQ from record</a-c>
<a-c>// @param refSeq -  the reference sequence underlying the read</a-c>
<a-k>function</a-k> <a-f>interpretCigar</a-f><a-p>(</a-p><a-v>cigar</a-v>: <a-t>string</a-t><a-p>,</a-p> <a-v>readSeq</a-v>: <a-t>string</a-t><a-p>,</a-p> <a-v>refSeq</a-v>: <a-t>string</a-t><a-p>)</a-p> <a-p>{</a-p>
  <a-k>const</a-k> <a-v>opts</a-v> <a-o>=</a-o> <a-f>parseCigar</a-f><a-p>(</a-p><a-v>cigar</a-v><a-p>)</a-p>
  <a-k>let</a-k> <a-v>qpos</a-v> <a-o>=</a-o> <a-n>0</a-n> <a-c>// query position, position on the read</a-c>
  <a-k>let</a-k> <a-v>tpos</a-v> <a-o>=</a-o> <a-n>0</a-n> <a-c>// target position, position on the reference sequence</a-c>

  <a-c>// opts will be an array like this ['30','M', '2','I', '50','M', '40','D']</a-c>
  <a-c>// which we parse two elements at a time</a-c>
  <a-k>for</a-k> <a-p>(</a-p><a-k>let</a-k> <a-v>i</a-v> <a-o>=</a-o> <a-n>0</a-n><a-p>;</a-p> <a-v>i</a-v> <a-o>&#x3C;</a-o> <a-v>opts</a-v><a-p>.</a-p><a-pr>length</a-pr><a-p>;</a-p> <a-v>i</a-v> <a-o>+=</a-o> <a-n>2</a-n><a-p>)</a-p> <a-p>{</a-p>
    <a-k>const</a-k> <a-v>len</a-v> <a-o>=</a-o> <a-o>+</a-o><a-v>opts</a-v><a-p>[</a-p><a-v>i</a-v><a-p>]</a-p>
    <a-k>const</a-k> <a-v>op</a-v> <a-o>=</a-o> <a-v>opts</a-v><a-p>[</a-p><a-v>i</a-v> <a-o>+</a-o> <a-n>1</a-n><a-p>]</a-p>
    <a-c>// do things. refer to the CIGAR chart in SAMv1.pdf for which operators</a-c>
    <a-c>// "consume reference" to see whether to increment</a-c>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'M'</a-s> <a-o>||</a-o> <a-v>op</a-v> <a-o>===</a-o> <a-s>'='</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// matches consume query and reference</a-c>
      <a-k>const</a-k> <a-v>refMatch</a-v> <a-o>=</a-o> <a-v>refSeq</a-v><a-p>.</a-p><a-f>slice</a-f><a-p>(</a-p><a-v>tpos</a-v><a-p>,</a-p> <a-v>tpos</a-v> <a-o>+</a-o> <a-v>len</a-v><a-p>)</a-p>
      <a-k>const</a-k> <a-v>readMatch</a-v> <a-o>=</a-o> <a-v>readSeq</a-v><a-p>.</a-p><a-f>slice</a-f><a-p>(</a-p><a-v>qpos</a-v><a-p>,</a-p> <a-v>qpos</a-v> <a-o>+</a-o> <a-v>len</a-v><a-p>)</a-p>
      <a-k>for</a-k> <a-p>(</a-p><a-k>let</a-k> <a-v>i</a-v> <a-o>=</a-o> <a-n>0</a-n><a-p>;</a-p> <a-v>i</a-v> <a-o>&#x3C;</a-o> <a-v>len</a-v><a-p>;</a-p> <a-v>i</a-v><a-o>++</a-o><a-p>)</a-p> <a-p>{</a-p>
        <a-k>if</a-k> <a-p>(</a-p><a-v>refMatch</a-v><a-p>[</a-p><a-v>i</a-v><a-p>]</a-p> <a-o>!==</a-o> <a-v>readMatch</a-v><a-p>[</a-p><a-v>i</a-v><a-p>])</a-p> <a-p>{</a-p>
          <a-c>// SNP at this position</a-c>
        <a-p>}</a-p>
      <a-p>}</a-p>
      <a-v>qpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
      <a-v>tpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
    <a-p>}</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'I'</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// insertions only consume query</a-c>
      <a-c>// sequence of the insertion from the read is</a-c>
      <a-k>const</a-k> <a-v>insSeq</a-v> <a-o>=</a-o> <a-v>readSeq</a-v><a-p>.</a-p><a-f>slice</a-f><a-p>(</a-p><a-v>qpos</a-v><a-p>,</a-p> <a-v>qpos</a-v> <a-o>+</a-o> <a-v>len</a-v><a-p>)</a-p>
      <a-v>qpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
    <a-p>}</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'D'</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// deletions only consume reference</a-c>
      <a-c>// sequence of the deletion from the reference is</a-c>
      <a-k>const</a-k> <a-v>delSeq</a-v> <a-o>=</a-o> <a-v>refSeq</a-v><a-p>.</a-p><a-f>slice</a-f><a-p>(</a-p><a-v>tpos</a-v><a-p>,</a-p> <a-v>tpos</a-v> <a-o>+</a-o> <a-v>len</a-v><a-p>)</a-p>
      <a-v>tpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
    <a-p>}</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'N'</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// skips only consume reference</a-c>
      <a-c>// skips are similar to deletions but are related to spliced alignments</a-c>
      <a-v>tpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
    <a-p>}</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'X'</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// mismatch using the extended CIGAR format</a-c>
      <a-c>// could lookup the mismatch letter in a string containing the reference</a-c>
      <a-k>const</a-k> <a-v>mismatch</a-v> <a-o>=</a-o> <a-v>refSeq</a-v><a-p>.</a-p><a-f>slice</a-f><a-p>(</a-p><a-v>tpos</a-v><a-p>,</a-p> <a-v>tpos</a-v> <a-o>+</a-o> <a-v>len</a-v><a-p>)</a-p>
      <a-v>qpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
      <a-v>tpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
    <a-p>}</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'H'</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// does not consume query or reference</a-c>
      <a-c>// hardclip is just an indicator</a-c>
    <a-p>}</a-p>
    <a-k>if</a-k> <a-p>(</a-p><a-v>op</a-v> <a-o>===</a-o> <a-s>'S'</a-s><a-p>)</a-p> <a-p>{</a-p>
      <a-c>// softclip consumes query</a-c>
      <a-c>// below gets the entire soft clipped portion</a-c>
      <a-k>const</a-k> <a-v>softClipStr</a-v> <a-o>=</a-o> <a-v>readSeq</a-v><a-p>.</a-p><a-f>slice</a-f><a-p>(</a-p><a-v>qpos</a-v><a-p>,</a-p> <a-v>qpos</a-v> <a-o>+</a-o> <a-v>len</a-v><a-p>)</a-p>
      <a-v>qpos</a-v> <a-o>+=</a-o> <a-v>len</a-v>
    <a-p>}</a-p>
  <a-p>}</a-p>
<a-p>}</a-p>
</code></pre>
<p>Note for example, that to determine how long a record is on the reference
sequence, you have to combine the records start position with the CIGAR string,
basically parsing the CIGAR string to add up tpos and return tpos</p>
<h3 id="appendix-c---align-fastq-directly-to-cram">Appendix C - align <code>FASTQ</code> directly to <code>CRAM</code></h3>
<p>This example from the htslib documentation
(<a href="http://www.htslib.org/workflow/fastq.html">http://www.htslib.org/workflow/fastq.html</a>) shows how you can stream directly
from <code>FASTQ</code> to <code>CRAM</code> (and generate the index file .crai too)</p>
<p>If you want, you can make this a little shell script, easy_align_shortreads.sh</p>
<p>easy_align_shortreads.sh</p>
<pre><code class="language-sh"><a-c>#!/bin/bash</a-c>
<a-f>minimap2</a-f> <a-co>-t</a-co> 8 <a-co>-a</a-co> <a-co>-x</a-co> sr <a-s>"</a-s><a-o>$</a-o><a-pr>1</a-pr><a-s>"</a-s> <a-s>"</a-s><a-o>$</a-o><a-pr>2</a-pr><a-s>"</a-s> <a-s>"</a-s><a-o>$</a-o><a-pr>3</a-pr><a-s>"</a-s>  <a-o>|</a-o> \
<a-f>samtools</a-f> fixmate <a-co>-u</a-co> <a-co>-m</a-co> <a-co>-</a-co> <a-co>-</a-co> <a-o>|</a-o> \
<a-f>samtools</a-f> sort <a-co>-u</a-co> <a-co>-@2</a-co> <a-co>-</a-co> <a-o>|</a-o> \
<a-f>samtools</a-f> markdup <a-co>-@8</a-co> <a-co>--reference</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>1</a-pr><a-s>"</a-s> <a-co>-</a-co> <a-co>--write-index</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>4</a-pr><a-s>"</a-s>
</code></pre>
<p>Similar idea for longreads, except just a single fastq file is generally used
for longreads</p>
<p>easy_align_longreads.sh</p>
<pre><code class="language-sh"><a-c>#!/bin/bash</a-c>
<a-f>minimap2</a-f> <a-co>-t</a-co> 8 <a-co>-a</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>1</a-pr><a-s>"</a-s> <a-s>"</a-s><a-o>$</a-o><a-pr>2</a-pr><a-s>"</a-s>  <a-o>|</a-o> \
<a-f>samtools</a-f> fixmate <a-co>-u</a-co> <a-co>-m</a-co> <a-co>-</a-co> <a-co>-</a-co> <a-o>|</a-o> \
<a-f>samtools</a-f> sort <a-co>-u</a-co> <a-co>-@2</a-co> <a-co>-</a-co> <a-o>|</a-o> \
<a-f>samtools</a-f> markdup <a-co>-@8</a-co> <a-co>--reference</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>1</a-pr><a-s>"</a-s> <a-co>-</a-co> <a-co>--write-index</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>3</a-pr><a-s>"</a-s>
</code></pre>
<p>Then call</p>
<pre><code class="language-sh"><a-f>bash</a-f> easy_align_shortreads.sh ref.fa reads1.fq reads2.fq out.cram
<a-f>bash</a-f> easy_align_longreads.sh ref.fa reads.fq out.cram

<a-c>## output BAM instead</a-c>
<a-f>bash</a-f> easy_align_shortreads.sh ref.fa reads1.fq reads2.fq out.bam
<a-f>bash</a-f> easy_align_longreads.sh ref.fa reads.fq out.bam
</code></pre>
<p>This same concept works with other common aligners as well like bwa</p>
<p>Bonus: CRAM to bigwig, for looking at CNV/coverage</p>
<pre><code class="language-sh"><a-c>#!/bin/bash</a-c>
<a-c># quickalign.sh ref.fa 1.fq 2.fq out.cram</a-c>
<a-c># produces out.cram and out.bw</a-c>
<a-f>samtools</a-f> faidx <a-o>$</a-o><a-pr>1</a-pr>
<a-f>minimap2</a-f> <a-co>-t</a-co> 8 <a-co>-a</a-co> <a-co>-x</a-co> sr <a-s>"</a-s><a-o>$</a-o><a-pr>1</a-pr><a-s>"</a-s> <a-s>"</a-s><a-o>$</a-o><a-pr>2</a-pr><a-s>"</a-s> <a-s>"</a-s><a-o>$</a-o><a-pr>3</a-pr><a-s>"</a-s>  <a-o>|</a-o> \
<a-f>samtools</a-f> fixmate <a-co>-u</a-co> <a-co>-m</a-co> <a-co>-</a-co> <a-co>-</a-co> <a-o>|</a-o> \
<a-f>samtools</a-f> sort <a-co>-u</a-co> <a-co>-@2</a-co> <a-co>-</a-co> <a-o>|</a-o> \
<a-f>samtools</a-f> markdup <a-co>-@8</a-co> <a-co>--reference</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>1</a-pr><a-s>"</a-s> <a-co>-</a-co> <a-co>--write-index</a-co> <a-s>"</a-s><a-o>$</a-o><a-pr>4</a-pr><a-s>"</a-s>


<a-f>mosdepth</a-f> <a-o>$</a-o><a-pr>4</a-pr> <a-co>-f</a-co> <a-o>$</a-o><a-pr>1</a-pr> <a-o>$</a-o><a-pr>4</a-pr>
<a-f>gunzip</a-f> <a-o>$</a-o><a-pr>4</a-pr>.per-base.bed.gz
<a-f>bedGraphToBigWig</a-f> <a-o>$</a-o><a-pr>4</a-pr>.per-base.bed <a-o>$</a-o><a-pr>1</a-pr>.fa.fai <a-o>$</a-o><a-pr>4</a-pr>.bw
</code></pre>
<p>Call as “quickalign.sh ref.fa 1.fq 2.fq out.cram” gives you out.cram,
out.cram.crai, and out.cram.bw (coverage)</p>
<h3 id="appendix-d---the-md-tag-and-finding-snps-in-reads">Appendix D - the <code>MD</code> tag and finding SNPs in reads</h3>
<p>The <code>MD</code> tag helps tell you where the mismatches are without looking at the
reference genome. This is useful because as I mentioned, <code>CIGAR</code> can say <code>50M</code>
(50 matches) but some letters inside those 50 matches can be mismatches, it only
says there are no insertions/deletions in those 50 bases, but you have to
determine where in those 50 bases where the mismatches are.</p>
<p>The <code>MD</code> tag can help tell you where those are, but it is somewhat complicated
to decode (<a href="https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html">https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html</a>).
You have to combine it with the <code>CIGAR</code> to get the position of the mismatches on
the reference genome. If you have a reference genome to look at, you might just
compare all the bases within the 50M to the reference genome and look for
mismatches yourself and forget about the <code>MD</code> tag</p>
<p>The <code>MD</code> tag is also not required to exist, but the command
<code>samtools calmd yourfile.bam --reference reference.fa</code> can add <code>MD</code> tags to your
<code>BAM</code> file. It is generally not useful for <code>CRAM</code> because <code>CRAM</code> actually does
store mismatches with the reference genome in it’s compression format.</p>
<p>Note that there are some oddities about <code>MD</code> tag representation leading to
complaints (e.g. <a href="https://github.com/samtools/hts-specs/issues/505">https://github.com/samtools/hts-specs/issues/505</a>), which could
lend credence to “doing it yourself” e.g. finding your own mismatches by
comparing the read sequence with the reference, instead of relying on the <code>MD</code>
tag. (see Appendix B)</p>
<h2 id="appendix-e-converting-between-sambamcram">Appendix E: Converting between SAM/BAM/CRAM</h2>
<p>You can convert <code>SAM</code> to <code>BAM</code> with samtools</p>
<pre><code class="language-sh"><a-f>samtools</a-f> view file.sam <a-co>-o</a-co> file.bam
</code></pre>
<p>You can also convert a <code>BAM</code> back to <code>SAM</code> with samtools view</p>
<pre><code class="language-sh"><a-f>samtools</a-f> view <a-co>-h</a-co> file.bam <a-co>-o</a-co> file.sam
</code></pre>
<p>The -h just makes sure to preserve the header.</p>
<p>If you are converting <code>SAM</code> to <code>CRAM</code>, it may require the -T argument to specify
your reference sequence (this is because the <code>CRAM</code> is “reference compressed”)</p>
<pre><code class="language-sh"><a-f>samtools</a-f> view <a-co>-T</a-co> reference.fa file.sam <a-co>-o</a-co> file.cram
</code></pre>
<p>Note that in some cases you can pipe data directly from e.g. an aligner straight
to CRAM. See Appendix C: piping FASTQ from <code>minimap2</code> directly to CRAM</p>
<h2 id="appendix-f-why-is-my-read-alignment-coverage-uneven">Appendix F: Why is my read alignment coverage uneven?</h2>
<p>When looking at coverage plots, you might notice that coverage is far from
uniform. There are both biological and technical reasons for this.</p>
<h3 id="biological-reasons">Biological reasons</h3>
<ul>
<li>
<p><em>GC content bias</em>: Regions with very high or very low GC content tend to have
lower coverage. This affects both short and long read sequencing, though to
different degrees. DNA with extreme GC content is harder to denature and
amplify during library preparation.</p>
</li>
<li>
<p><em>Repetitive regions</em>: Tandem repeats, transposable elements, segmental
duplications, and other repetitive sequences can cause reads to multi-map,
leading to apparent coverage drops if multi-mappers are filtered out, or
inflated coverage if they are randomly assigned. Centromeres and telomeres are
particularly affected.</p>
</li>
<li>
<p><em>Copy number variation</em>: True biological differences in copy number between
your sample and the reference genome will show up as coverage differences.
Duplicated regions will have higher coverage, and deleted regions will have
lower or zero coverage.</p>
</li>
<li>
<p><em>Heterochromatin and chromatin structure</em>: Tightly packed heterochromatic
regions can be harder to sequence due to reduced accessibility during library
preparation, leading to lower coverage.</p>
</li>
<li>
<p><em>Segmental duplications and paralogous sequences</em>: Highly similar duplicated
regions in the genome can cause reads to map ambiguously, resulting in
mapping quality drops and uneven coverage.</p>
</li>
</ul>
<h3 id="technical-reasons">Technical reasons</h3>
<ul>
<li>
<p><em>PCR amplification bias</em>: Library preparation protocols that involve PCR can
introduce amplification bias. Some fragments amplify more efficiently than
others, leading to uneven representation. PCR-free library prep protocols
can reduce this.</p>
</li>
<li>
<p><em>Fragmentation bias</em>: Enzymatic or mechanical fragmentation of DNA during
library preparation is not perfectly uniform, which can lead to some regions
being over- or under-represented.</p>
</li>
<li>
<p><em>Mappability</em>: Some regions of the genome are inherently difficult to map
reads to uniquely. Short reads in particular struggle with repetitive
regions, leading to mapping quality zero reads or unmapped reads. Long reads
improve this but don’t fully eliminate it.</p>
</li>
<li>
<p><em>Sequencing errors in homopolymers</em>: Nanopore and older PacBio sequencing
can have higher error rates in homopolymer runs (e.g. AAAAAAA), which can
cause local alignment artifacts and apparent coverage fluctuations.</p>
</li>
<li>
<p><em>Library complexity</em>: Low input DNA or over-amplified libraries result in
many duplicate reads. After duplicate marking/removal, the effective coverage
in some regions can drop significantly.</p>
</li>
<li>
<p><em>Target capture bias</em>: For exome or targeted sequencing, probe hybridization
efficiency varies across targets, leading to highly uneven coverage across
the captured regions.</p>
</li>
<li>
<p><em>Edge effects</em>: Coverage tends to drop at the edges of chromosomes
(telomeres) and near gaps (Ns) in the reference assembly.</p>
</li>
<li>
<p><em>Reference genome quality</em>: Errors or gaps in the reference genome itself can
cause reads to fail to map in certain regions, or cause pileups of
misaligned reads in others.</p>
</li>
</ul>
<p>Understanding these sources of coverage variation is important when
interpreting CNV calls, as not every coverage dip or peak represents a true
biological copy number change.</p>
<h3 id="divergent-strains-mapped-to-a-single-reference">Divergent strains mapped to a single reference</h3>
<p>An extreme case of uneven coverage occurs when you map reads from a
divergent strain or wild isolate to a reference genome. If the sample is
highly divergent from the reference in certain genomic regions, reads from
those regions will either fail to map entirely or map with very high mismatch
rates, creating dramatic coverage drops and spikes at a fine scale.</p>
<p>This is particularly well-studied in C. elegans, where wild isolates (e.g.
DL238, JU2526, EG4725) have “hyper-divergent” regions compared to the
standard N2 reference. These regions can be so different from N2 that they
resemble a different species, and the coverage profile when mapping to N2
looks extremely jagged: sharp transitions between well-mapped conserved
regions and poorly-mapped or unmapped divergent regions. The read pileup
in these regions will also show an abundance of colored mismatches.</p>
<p>These hyper-divergent haplotypes in C. elegans often overlap with genes
involved in environmental response such as chemoreceptors and innate immunity
genes, and are thought to be maintained by balancing selection. This
phenomenon is not unique to C. elegans; any organism with high population
diversity or where you are mapping a divergent strain to a single reference
can show similar patterns.</p>
<p>The solution is not to “fix” the library prep but rather to use a
strain-specific assembly, a pangenome reference, or a graph genome approach
that can represent the diversity in these regions. Alternatively, using a
more lenient aligner setting may recover some reads, but at the cost of
noisier alignments.</p> </div> <div id="giscus"></div> <script>
  const script = document.createElement('script');
  script.src = 'https://giscus.app/client.js';
  script.setAttribute('data-repo', 'cmdcolin/cmdcolin.github.io');
  script.setAttribute('data-repo-id', 'MDEwOlJlcG9zaXRvcnkyNjE0OTY3Nw==');
  script.setAttribute('data-category', 'General');
  script.setAttribute('data-category-id', 'DIC_kwDOAY8DLc4CO-L9');
  script.setAttribute('data-mapping', 'pathname');
  script.setAttribute('data-strict', '0');
  script.setAttribute('data-reactions-enabled', '1');
  script.setAttribute('data-emit-metadata', '0');
  script.setAttribute('data-input-position', 'bottom');
  script.setAttribute('data-theme', 'light');
  script.setAttribute('data-lang', 'en');
  script.setAttribute('crossorigin', 'anonymous');
  script.async = true;
  document.getElementById('giscus').appendChild(script);
</script> </article>  </div>   <footer class="footer-style" data-astro-cid-k2f5zb5c> <a class="footer-link" href="/" data-astro-cid-k2f5zb5c>Home</a> <a class="footer-link" href="/archive" data-astro-cid-k2f5zb5c>Blog archive</a> <a class="footer-link" href="https://github.com/cmdcolin/" data-astro-cid-k2f5zb5c>Github</a> <a class="footer-link" href="/projects" data-astro-cid-k2f5zb5c>Projects</a> <a class="footer-link" href="/about" data-astro-cid-k2f5zb5c>About</a> </footer> </body></html> 