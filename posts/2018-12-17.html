<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Behind the release - the story of the bugs and features in JBrowse 1.16.0</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/0e13ae09fdc48bba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0e13ae09fdc48bba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-01f10f588aa1f712.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-896947e153b7d53e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d6e6a35eb3960502.js" defer=""></script><script src="/_next/static/chunks/996-9e3c12b77542c098.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-9a0bc1852a8bf540.js" defer=""></script><script src="/_next/static/uTVnDYznkkM6IezkSjDZK/_buildManifest.js" defer=""></script><script src="/_next/static/uTVnDYznkkM6IezkSjDZK/_ssgManifest.js" defer=""></script><script src="/_next/static/uTVnDYznkkM6IezkSjDZK/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Behind the release - the story of the bugs and features in JBrowse 1.16.0</h1><h4>2018-12-17</h4></div><p>Every once in awhile, you might see that your favorite program, JBrowse,  has a
new release. There are a ton of little snippets in the release notes, you might
as well just go ahead and upgrade, but what went into all those little fixes?
Going to the blog post has links to the github
issues, http://jbrowse.org/blog/2018/12/13/jbrowse-1-16-0.html but I felt like
maybe I&#x27;d add a little more context for some of them:</p>
<!-- --><p>PS This is sort of motivated by @zcbenz blog on Electron
(https://twitter.com/zcbenz http://cheng.guru/) which tells the software in
terms of actual commit messages and such.</p>
<!-- --><ul>
<!-- --><li>
<!-- --><p>The webpack build doing a production build by default. This seems pretty
straightforward, but was also difficult because I use WSL and the UglifyJs
plugin had trouble on WSL using the parallel: 4 option to use multiple
processors. This was really annoying and resulted in the webpack build just
hanging for no reason and only careful google-fu really uncovered other
people having this issue. I removed the parallelism as the speed gain wasn&#x27;t
even really justifiable https://github.com/gmod/jbrowse/pull/1223</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>The incorporation of the <!-- --><code>@gmod/bam</code> module. This was an almost 2 months
process after my first module, <!-- --><code>@gmod/indexedfasta</code>. It required really
getting down to the binary level for BAM and was pretty tough. The module has
already itself had 12 releases
<!-- --><a href="https://github.com/GMOD/bam-js/blob/master/CHANGELOG.md">here</a></p>
<!-- --></li>
<!-- --></ul>
<!-- --><p>- Added support for indexing arbitrary fields from GFF3Tabix files. This was
fairly straightforward but required making design decisions about this.
Previously flatfile-to-json.pl files would have a command line flag to index
arbitrary fields. Since gff3tabix files are specified via config, I allowed
specifying arbitrary fields via config.</p>
<!-- --><p>- Added ability to render non-coding transcript types to the default Gene
glyph. This one was a nice feature and enables you to see non-coding types, but
required some weird design decisions because I could not override
the <!-- --><code>box-&gt;style-&gt;color</code> from a higher level type simply using the
<!-- --><code>_defaultConfig</code> function, so I needed to override the <!-- --><code>getStyle</code> callback that
was passed down to the lower levels, so that it was able to use the default
lower level style and also our non-coding transcript style. See this part of
the code for
details https://github.com/GMOD/jbrowse/commit/ec638ea1cc62c8727#diff-a14e88322d8f4e8e940f995417277878R22<!-- --></p>
<!-- --><p>- Added <!-- --><code>hideImproperPairs</code> filter. This was fairly straightforward but it is
one of these bugs that went unnoticed for years...the <!-- --><code>hideMissingMatepairs</code>
flag would hide things didn&#x27;t have the sam 0x02 flag for &quot;read mapped in proper
pair&quot;, but reads with this flag could still be paired. Doing the 1.16 release
that focused on paired reads helped focus on this issue and now
hideMissingMatepairs filters on &quot;mate unmapped&quot; and <!-- --><code>hideImproperPairs</code> is
the &quot;read mapped in proper pair&quot;<!-- --></p>
<!-- --><ul>
<!-- --><li>Added <!-- --><code>useTS</code> flag. This one is fairly straightforward, it is similar to
<!-- --><code>useXS</code> which colors reads based on their alignment in canonical splice site
orientations. I figured I could just copy the <!-- --><code>useXS</code> to the <!-- --><code>useTS</code> since I
figured they are the same, but I went ahead and manually generated RNA-seq
alignments with minimap2 and found that the useTS is actually flipped the
opposite of <!-- --><code>useXS</code>, so it was valuable to get actual test data here.<!-- --></li>
<!-- --></ul>
<!-- --><p>- Fixed issue where some <!-- --><code>generate-names</code> setups would fail to index features.
This was a bad bug that was brought to light by a user. I was kind of mind
boggled when I saw it. In JBrowse 1.13-JBrowse 1.15 a change was introduced to
name indexing with a memory leak. In JBrowse 1.15 that was removed. But, there
was another change where refseqs could return empty name records, because they
were handled separately. But if the initial fill up of the name buffer of 50000
was exceeded by the reference sequence, then there would be empty name records
after this point and cause the name indexing to stop. Therefore this bug would
only happen when the reference sequence indexing buffer exceeded 50000 items
which could happen even when there are less than 50000 refseqs due to
autocompletions<!-- --></p>
<!-- --><p>-  Fixed issue with getting feature density from BAM files via the index stats
estimation. This involved parsing the &quot;dummy bin&quot; from index files, and I found
it was failing on certain 1000 genomes files. I actually don&#x27;t really know what
the story behind this was, but our tabix code was better at parsing the dummy
bins than my bam code, and it was the same concept, so I took a note from their
codebase to use it in bam-js code. Commit
here https://github.com/GMOD/bam-js/commit/d5796dfc8750378ac8b875615ae0a7e81371af76</p>
<!-- --><p>-  Fixed issue with some GFF3Tabix tracks having some inconsistent layout of
features. This is a persistently annoying fact in tabix files where we cannot
really get a unique ID of a feature based on it&#x27;s file offset. Therefore this
takes the full crc32 of a line as it&#x27;s unique ID.</p>
<!-- --><ul>
<!-- --><li>Fixed CRAM store not renaming reference sequences in the same way as other
stores. This one was interesting because rbuels made a fix but it caused
features from one chromosome to show up on the wrong ones, so chr1 reads
where showing up on chrMT. This happened because it was falling back to the
refseq index if it chrMT wasn&#x27;t in the embedded &quot;sam header&quot; in the CRAM
file, but it should only fallback to refseq index if there is not any
embedded &quot;sam header&quot; in the CRAM file.</li>
<!-- --></ul>
<!-- --><p>-  Fixed bug where older browsers e.g. IE11 were not being properly supported
via babel. This was a absolutely terrible bug that I found over thanksgiving
break. It was a regression from 1.15 branch of JBrowse. Previous versions from
1.13 when webpack was up until 1.15 used <!-- --><code>@babel/env</code>. It was changed to
babel-preset-2015 but it was not being run correctly. Then I found that even if
I did get it running correctly, it was unable to properly babel-ify the
lru-cache module because it used something called
<!-- --><code>Object.defineProperty(&#x27;length&#x27;, ...)</code> to change how the length property was
intepreted which was illegal in IE11. The &#x27;util.promisify&#x27; NPM module also did
this in some contexts. I found that I could use the quick-lru module and the
es6-promisify module instead of lru-cache and util.promisify as a workaround.
Then I had to update all <!-- --><code>@gmod/tabix</code>, <!-- --><code>@gmod/vcf</code>, <!-- --><code>@gmod/bgzf-filehandle</code>,
<!-- --><code>@gmod/indexedfasta</code>, <!-- --><code>@gmod/tribble-index</code>, <!-- --><code>@gmod/bam</code>, and JBrowse proper to
use these modules instead, and make the bable chain, which typically does not
parse node_modules, to build these modules specifically (I didn&#x27;t want to setup
babel toolchains for every single one of these modules, just one in the jbrowse
main codebase...). This was really a lot of work to support IE11 but now that
works so ...ya<!-- --></p>
<!-- --><p>-  Fixed bug where some files were not being fetched properly when changing
refseqs. This was actually fixed when I changed out lru-cache for quick-lru and
fixed a bug where the cache size was set to 0 due to a erroneous comment that
said <!-- --><code>50*1024 // 50MB</code>...of course it should have said <!-- --><code>50*1024*1024 // 50MB</code> https://github.com/GMOD/jbrowse/commit/2025dc0aa0091b70<!-- --></p>
<!-- --><ul>
<!-- --><li>
<!-- --><p>Fixed issue where JBrowse would load the wrong area of the refseq on startup
resulting in bad layouts and excessive data fetches. This was actually a
heinous bug where jbrowse upon loading would just navigateTo the start of the
reference sequence automatically and then to wherever was specified by the
user. This resulted in track data to start downloading immediately from the
start of the chromosome and resulted in for example 350 kilobases of
reference sequence from all tracks to start downloading, which when I was
implementing view as pairs, was causing me to download over 100MB routinely.
This was terrible, and after fixing I only download about 10MB over even
large regions for most BAM files. Additionally, this bug was causing the
track heights to be calculated incorrectly because the track heights would
actually be calculated based on distorted canvas
bitmaps. https://github.com/gmod/jbrowse/issues/1187</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>JBrowse Desktop was not fetching remote files. This was a weird issue where
remote file requests were considered a CORS requests to any external remote.
This was solved by changing the usage of the fetch API in JBrowse for
node-fetch which does not obey CORS. Note that electron-fetch was also
considered, which uses Chromiums network stack instead of node&#x27;s, but that
had specific assumptions about the context in which it was called.</p>
<!-- --></li>
<!-- --></ul>
<!-- --><p>-  Fixed issue where some parts of a CRAM file would not be displayed in
JBrowse due to a CRAM index parsing issue. This was based on a sort of binary
search that was implemented in JBrowse where the elements of the lists were
non-overlapping regions, and the query was a region, and the output should be a
list of the non-overlapping regions that overlap the query. Most algorithms for
binary search don&#x27;t really tell you how to do searches on ranges so needed to
roll up my sleeves and write a little custom code. An interval tree could have
been used but this is too heavy-weight for non-overlapping regions from the
index https://github.com/GMOD/cram-js/pull/10</p>
<!-- --><p>-  Fixed an issue where BAM features were not lazily evaluating their tags.
When a function <!-- --><code>feature.get(&#x27;blahblah&#x27;)</code> is called on a BAM feature, it checks
to see if it&#x27;s part of a default list of things that are parsed like feature
start, end, id, but if not, it has to parse all the BAM tags to see if it is a
tag. Since they are called &quot;lazy features&quot; the tag processing is deferred until
it is absolutely needed. As it turned out, the incorporation of CRAM in 1.15
was calling a function to try to get the CRAM&#x27;s version of CIGAR/MD on the BAM
features unnecessarily invoking the tag parsing on every feature up front and
therefore making the feature not really lazy anymore. This restored
the &quot;lazyness&quot; aspect of BAM.<!-- --></p>
<!-- --><p>-  Fixed issue where CRAM layout and mouseover would be glitchy due to ID
collisions on features. In the 1.15 releases, CRAM was introduced, and we
thought that the concept of taking CRC32 of the entire feature data days were
over because there is the concept of a &quot;unique ID&quot; on the features. However,
this ID was only unique within the slices, so around the slice boundaries there
were a lot of bad feature layouts and mouseovers would fail because they would
map to multiple features, etc. I found a way to unique-ify this by giving it
the sliceHeader file offset. https://github.com/GMOD/cram-js/pull/10</p>
<!-- --><ul>
<!-- --><li>
<!-- --><p>We also had behind the scenes work by igv.js team member jrobinso who helped
on the CRAM codebase to incorporate a feature where for lossy read names, so
that a read and it&#x27;s mate pair would consistently be assigned the same read
name based on the unique ID mentioned above. There was also a rare issue
where sometimes the mate pair&#x27;s orientation was incorrectly reported based on
the CRAM flags, but the embedded BAM flags correctly reported it.</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>Finally the paired reads feature. This was a feature that I really wanted to
get right. It started when garrett and rbuels were going to san diego for the
CIVIC hackathon, and we talked about doing something that matched a &quot;variant
review system&quot; that they had done for the IGV codebase, which involved
detailed inspection of reads. I thought it would probably be feasible for
jbrowse to do this, but I thought essentially at some point that enhancing
jbrowse&#x27;s read visualizations with paired reads would be a big win. I had
thought about this at the JBrowse hackathon also and my discussions then were
that this was very hard. Overall, I invented a compromise that I thought was
reasonable which was that there can be a &quot;maxInsertSize&quot; for the pileup view
beyond which the pairing wouldn&#x27;t be resolved. This allowed (a) a significant
reduction in data fetches because I implemented a &quot;read redispatcher&quot; that
would actually literally resolve the read pairs in the separate chunks and
(b) a cleaner view because the layout wouldn&#x27;t be polluted by very long read
inserts all the time and also, for example, if you scrolled to the right, and
suddenly a read was paired to the left side of your view, it would result in
a bad layout (but with max insert size, the window of all reads within
maxinsertsize are always resolved so this does not happen) and finally ( c)
the paired arc view was incorporated which does not use read redispatching
and which can do very long reads. All of these things took time to think
through and resolve, but it is now I think a pretty solid system and I look
forward to user feedback!</p>
<!-- --></li>
<!-- --></ul><div style="margin-top:200px"><giscus-widget id="comments" repo="cmdcolin/cmdcolin.github.io" repoid="MDEwOlJlcG9zaXRvcnkyNjE0OTY3Nw==" category="General" categoryid="DIC_kwDOAY8DLc4CO-L9" mapping="pathname" term="Welcome to @giscus/react component!" reactionsenabled="1" emitmetadata="0" inputposition="top" lang="en" loading="lazy"></giscus-widget></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <!-- --><a href="/archive">Blog archive</a> <!-- --><a href="https://github.com/cmdcolin/">Github</a> <!-- --><a href="https://twitter.com/cmdcolin">Twitter</a> <!-- --><a href="/projects">Projects</a> <!-- --><a href="/photos">Photos</a> <!-- --><a href="/rss.xml">RSS</a><a href="/about">About</a> <!-- --></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Behind the release - the story of the bugs and features in JBrowse 1.16.0","date":"2018-12-17","slug":"2018-12-17","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      code: \"code\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Every once in awhile, you might see that your favorite program, JBrowse,  has a\\nnew release. There are a ton of little snippets in the release notes, you might\\nas well just go ahead and upgrade, but what went into all those little fixes?\\nGoing to the blog post has links to the github\\nissues, http://jbrowse.org/blog/2018/12/13/jbrowse-1-16-0.html but I felt like\\nmaybe I'd add a little more context for some of them:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"PS This is sort of motivated by @zcbenz blog on Electron\\n(https://twitter.com/zcbenz http://cheng.guru/) which tells the software in\\nterms of actual commit messages and such.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"The webpack build doing a production build by default. This seems pretty\\nstraightforward, but was also difficult because I use WSL and the UglifyJs\\nplugin had trouble on WSL using the parallel: 4 option to use multiple\\nprocessors. This was really annoying and resulted in the webpack build just\\nhanging for no reason and only careful google-fu really uncovered other\\npeople having this issue. I removed the parallelism as the speed gain wasn't\\neven really justifiable https://github.com/gmod/jbrowse/pull/1223\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"The incorporation of the \", _jsx(_components.code, {\n              children: \"@gmod/bam\"\n            }), \" module. This was an almost 2 months\\nprocess after my first module, \", _jsx(_components.code, {\n              children: \"@gmod/indexedfasta\"\n            }), \". It required really\\ngetting down to the binary level for BAM and was pretty tough. The module has\\nalready itself had 12 releases\\n\", _jsx(_components.a, {\n              href: \"https://github.com/GMOD/bam-js/blob/master/CHANGELOG.md\",\n              children: \"here\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"- Added support for indexing arbitrary fields from GFF3Tabix files. This was\\nfairly straightforward but required making design decisions about this.\\nPreviously flatfile-to-json.pl files would have a command line flag to index\\narbitrary fields. Since gff3tabix files are specified via config, I allowed\\nspecifying arbitrary fields via config.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"- Added ability to render non-coding transcript types to the default Gene\\nglyph. This one was a nice feature and enables you to see non-coding types, but\\nrequired some weird design decisions because I could not override\\nthe \", _jsx(_components.code, {\n          children: \"box-\u003estyle-\u003ecolor\"\n        }), \" from a higher level type simply using the\\n\", _jsx(_components.code, {\n          children: \"_defaultConfig\"\n        }), \" function, so I needed to override the \", _jsx(_components.code, {\n          children: \"getStyle\"\n        }), \" callback that\\nwas passed down to the lower levels, so that it was able to use the default\\nlower level style and also our non-coding transcript style. See this part of\\nthe code for\\ndetails https://github.com/GMOD/jbrowse/commit/ec638ea1cc62c8727#diff-a14e88322d8f4e8e940f995417277878R22\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"- Added \", _jsx(_components.code, {\n          children: \"hideImproperPairs\"\n        }), \" filter. This was fairly straightforward but it is\\none of these bugs that went unnoticed for years...the \", _jsx(_components.code, {\n          children: \"hideMissingMatepairs\"\n        }), \"\\nflag would hide things didn't have the sam 0x02 flag for \\\"read mapped in proper\\npair\\\", but reads with this flag could still be paired. Doing the 1.16 release\\nthat focused on paired reads helped focus on this issue and now\\nhideMissingMatepairs filters on \\\"mate unmapped\\\" and \", _jsx(_components.code, {\n          children: \"hideImproperPairs\"\n        }), \" is\\nthe \\\"read mapped in proper pair\\\"\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Added \", _jsx(_components.code, {\n            children: \"useTS\"\n          }), \" flag. This one is fairly straightforward, it is similar to\\n\", _jsx(_components.code, {\n            children: \"useXS\"\n          }), \" which colors reads based on their alignment in canonical splice site\\norientations. I figured I could just copy the \", _jsx(_components.code, {\n            children: \"useXS\"\n          }), \" to the \", _jsx(_components.code, {\n            children: \"useTS\"\n          }), \" since I\\nfigured they are the same, but I went ahead and manually generated RNA-seq\\nalignments with minimap2 and found that the useTS is actually flipped the\\nopposite of \", _jsx(_components.code, {\n            children: \"useXS\"\n          }), \", so it was valuable to get actual test data here.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"- Fixed issue where some \", _jsx(_components.code, {\n          children: \"generate-names\"\n        }), \" setups would fail to index features.\\nThis was a bad bug that was brought to light by a user. I was kind of mind\\nboggled when I saw it. In JBrowse 1.13-JBrowse 1.15 a change was introduced to\\nname indexing with a memory leak. In JBrowse 1.15 that was removed. But, there\\nwas another change where refseqs could return empty name records, because they\\nwere handled separately. But if the initial fill up of the name buffer of 50000\\nwas exceeded by the reference sequence, then there would be empty name records\\nafter this point and cause the name indexing to stop. Therefore this bug would\\nonly happen when the reference sequence indexing buffer exceeded 50000 items\\nwhich could happen even when there are less than 50000 refseqs due to\\nautocompletions\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"-  Fixed issue with getting feature density from BAM files via the index stats\\nestimation. This involved parsing the \\\"dummy bin\\\" from index files, and I found\\nit was failing on certain 1000 genomes files. I actually don't really know what\\nthe story behind this was, but our tabix code was better at parsing the dummy\\nbins than my bam code, and it was the same concept, so I took a note from their\\ncodebase to use it in bam-js code. Commit\\nhere https://github.com/GMOD/bam-js/commit/d5796dfc8750378ac8b875615ae0a7e81371af76\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"-  Fixed issue with some GFF3Tabix tracks having some inconsistent layout of\\nfeatures. This is a persistently annoying fact in tabix files where we cannot\\nreally get a unique ID of a feature based on it's file offset. Therefore this\\ntakes the full crc32 of a line as it's unique ID.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Fixed CRAM store not renaming reference sequences in the same way as other\\nstores. This one was interesting because rbuels made a fix but it caused\\nfeatures from one chromosome to show up on the wrong ones, so chr1 reads\\nwhere showing up on chrMT. This happened because it was falling back to the\\nrefseq index if it chrMT wasn't in the embedded \\\"sam header\\\" in the CRAM\\nfile, but it should only fallback to refseq index if there is not any\\nembedded \\\"sam header\\\" in the CRAM file.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"-  Fixed bug where older browsers e.g. IE11 were not being properly supported\\nvia babel. This was a absolutely terrible bug that I found over thanksgiving\\nbreak. It was a regression from 1.15 branch of JBrowse. Previous versions from\\n1.13 when webpack was up until 1.15 used \", _jsx(_components.code, {\n          children: \"@babel/env\"\n        }), \". It was changed to\\nbabel-preset-2015 but it was not being run correctly. Then I found that even if\\nI did get it running correctly, it was unable to properly babel-ify the\\nlru-cache module because it used something called\\n\", _jsx(_components.code, {\n          children: \"Object.defineProperty('length', ...)\"\n        }), \" to change how the length property was\\nintepreted which was illegal in IE11. The 'util.promisify' NPM module also did\\nthis in some contexts. I found that I could use the quick-lru module and the\\nes6-promisify module instead of lru-cache and util.promisify as a workaround.\\nThen I had to update all \", _jsx(_components.code, {\n          children: \"@gmod/tabix\"\n        }), \", \", _jsx(_components.code, {\n          children: \"@gmod/vcf\"\n        }), \", \", _jsx(_components.code, {\n          children: \"@gmod/bgzf-filehandle\"\n        }), \",\\n\", _jsx(_components.code, {\n          children: \"@gmod/indexedfasta\"\n        }), \", \", _jsx(_components.code, {\n          children: \"@gmod/tribble-index\"\n        }), \", \", _jsx(_components.code, {\n          children: \"@gmod/bam\"\n        }), \", and JBrowse proper to\\nuse these modules instead, and make the bable chain, which typically does not\\nparse node_modules, to build these modules specifically (I didn't want to setup\\nbabel toolchains for every single one of these modules, just one in the jbrowse\\nmain codebase...). This was really a lot of work to support IE11 but now that\\nworks so ...ya\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"-  Fixed bug where some files were not being fetched properly when changing\\nrefseqs. This was actually fixed when I changed out lru-cache for quick-lru and\\nfixed a bug where the cache size was set to 0 due to a erroneous comment that\\nsaid \", _jsx(_components.code, {\n          children: \"50*1024 // 50MB\"\n        }), \"...of course it should have said \", _jsx(_components.code, {\n          children: \"50*1024*1024 // 50MB\"\n        }), \" https://github.com/GMOD/jbrowse/commit/2025dc0aa0091b70\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Fixed issue where JBrowse would load the wrong area of the refseq on startup\\nresulting in bad layouts and excessive data fetches. This was actually a\\nheinous bug where jbrowse upon loading would just navigateTo the start of the\\nreference sequence automatically and then to wherever was specified by the\\nuser. This resulted in track data to start downloading immediately from the\\nstart of the chromosome and resulted in for example 350 kilobases of\\nreference sequence from all tracks to start downloading, which when I was\\nimplementing view as pairs, was causing me to download over 100MB routinely.\\nThis was terrible, and after fixing I only download about 10MB over even\\nlarge regions for most BAM files. Additionally, this bug was causing the\\ntrack heights to be calculated incorrectly because the track heights would\\nactually be calculated based on distorted canvas\\nbitmaps. https://github.com/gmod/jbrowse/issues/1187\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"JBrowse Desktop was not fetching remote files. This was a weird issue where\\nremote file requests were considered a CORS requests to any external remote.\\nThis was solved by changing the usage of the fetch API in JBrowse for\\nnode-fetch which does not obey CORS. Note that electron-fetch was also\\nconsidered, which uses Chromiums network stack instead of node's, but that\\nhad specific assumptions about the context in which it was called.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"-  Fixed issue where some parts of a CRAM file would not be displayed in\\nJBrowse due to a CRAM index parsing issue. This was based on a sort of binary\\nsearch that was implemented in JBrowse where the elements of the lists were\\nnon-overlapping regions, and the query was a region, and the output should be a\\nlist of the non-overlapping regions that overlap the query. Most algorithms for\\nbinary search don't really tell you how to do searches on ranges so needed to\\nroll up my sleeves and write a little custom code. An interval tree could have\\nbeen used but this is too heavy-weight for non-overlapping regions from the\\nindex https://github.com/GMOD/cram-js/pull/10\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"-  Fixed an issue where BAM features were not lazily evaluating their tags.\\nWhen a function \", _jsx(_components.code, {\n          children: \"feature.get('blahblah')\"\n        }), \" is called on a BAM feature, it checks\\nto see if it's part of a default list of things that are parsed like feature\\nstart, end, id, but if not, it has to parse all the BAM tags to see if it is a\\ntag. Since they are called \\\"lazy features\\\" the tag processing is deferred until\\nit is absolutely needed. As it turned out, the incorporation of CRAM in 1.15\\nwas calling a function to try to get the CRAM's version of CIGAR/MD on the BAM\\nfeatures unnecessarily invoking the tag parsing on every feature up front and\\ntherefore making the feature not really lazy anymore. This restored\\nthe \\\"lazyness\\\" aspect of BAM.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"-  Fixed issue where CRAM layout and mouseover would be glitchy due to ID\\ncollisions on features. In the 1.15 releases, CRAM was introduced, and we\\nthought that the concept of taking CRC32 of the entire feature data days were\\nover because there is the concept of a \\\"unique ID\\\" on the features. However,\\nthis ID was only unique within the slices, so around the slice boundaries there\\nwere a lot of bad feature layouts and mouseovers would fail because they would\\nmap to multiple features, etc. I found a way to unique-ify this by giving it\\nthe sliceHeader file offset. https://github.com/GMOD/cram-js/pull/10\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"We also had behind the scenes work by igv.js team member jrobinso who helped\\non the CRAM codebase to incorporate a feature where for lossy read names, so\\nthat a read and it's mate pair would consistently be assigned the same read\\nname based on the unique ID mentioned above. There was also a rare issue\\nwhere sometimes the mate pair's orientation was incorrectly reported based on\\nthe CRAM flags, but the embedded BAM flags correctly reported it.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Finally the paired reads feature. This was a feature that I really wanted to\\nget right. It started when garrett and rbuels were going to san diego for the\\nCIVIC hackathon, and we talked about doing something that matched a \\\"variant\\nreview system\\\" that they had done for the IGV codebase, which involved\\ndetailed inspection of reads. I thought it would probably be feasible for\\njbrowse to do this, but I thought essentially at some point that enhancing\\njbrowse's read visualizations with paired reads would be a big win. I had\\nthought about this at the JBrowse hackathon also and my discussions then were\\nthat this was very hard. Overall, I invented a compromise that I thought was\\nreasonable which was that there can be a \\\"maxInsertSize\\\" for the pileup view\\nbeyond which the pairing wouldn't be resolved. This allowed (a) a significant\\nreduction in data fetches because I implemented a \\\"read redispatcher\\\" that\\nwould actually literally resolve the read pairs in the separate chunks and\\n(b) a cleaner view because the layout wouldn't be polluted by very long read\\ninserts all the time and also, for example, if you scrolled to the right, and\\nsuddenly a read was paired to the left side of your view, it would result in\\na bad layout (but with max insert size, the window of all reads within\\nmaxinsertsize are always resolved so this does not happen) and finally ( c)\\nthe paired arc view was incorporated which does not use read redispatching\\nand which can do very long reads. All of these things took time to think\\nthrough and resolve, but it is now I think a pretty solid system and I look\\nforward to user feedback!\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2018-12-17"},"buildId":"uTVnDYznkkM6IezkSjDZK","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>