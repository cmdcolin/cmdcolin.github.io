<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Making a serverless website for photo and video upload pt. 2</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/0e13ae09fdc48bba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0e13ae09fdc48bba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-3e9e72f6d5fa0854.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-896947e153b7d53e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d6e6a35eb3960502.js" defer=""></script><script src="/_next/static/chunks/996-9e3c12b77542c098.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-23a4b3bec5e8663d.js" defer=""></script><script src="/_next/static/S652vUFlobT6RAYGmEXUt/_buildManifest.js" defer=""></script><script src="/_next/static/S652vUFlobT6RAYGmEXUt/_ssgManifest.js" defer=""></script><script src="/_next/static/S652vUFlobT6RAYGmEXUt/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Making a serverless website for photo and video upload pt. 2</h1><h4>2020-12-26</h4></div><p>This post follows
on https://cmdcolin.github.io/2020-12-24.html</p>
<!-- --><p>It is possible I zoomed ahead too fast to make this a continuous tutorial, but
overall I just wanted to post an update</p>
<!-- --><p>In pt. 1 I learned how to use the <!-- --><code>aws-sam</code> CLI tool. This was a great insight
for me about automating deployments. I can now simply run <!-- --><code>sam deploy</code> and it
will create new dynamodb tables, lambda functions, etc.<!-- --></p>
<!-- --><p>After writing pt 1. I converted the existing vue-js app that was in the aws
tutorial and converted it to react. Then I extended the app to allow</p>
<!-- --><ul>
<!-- --><li>Posting comments on photos</li>
<!-- --><li>Uploading multiple files</li>
<!-- --><li>Uploading videos etc.</li>
<!-- --></ul>
<!-- --><p>It will be hard to summarize all the changes since now the app has taken off a
little bit but it looks like this:</p>
<!-- --><p>Repo structure</p>
<!-- --><pre><code> ./frontend # created using npx create-react-app frontend --template
 typescript
 ./frontend/src/App.tsx # main frontend app code in react
 ./lambdas/
 ./lambdas/postFile # post a file to the lambda, this uploads a row to
 dynamodb and returns a pre-signed URL for uploading (note that if the
 client failed it&#x27;s upload, that row in the lambda DB might be in a bad
 state...)
 ./lambdas/getFiles # get all files that were ever posted
 ./lambdas/postComment # post a comment on a picture with POST
 request
 ./lambdas/getComments?file=filename.jpg # get comments on a
 picture/video with GET request
</code></pre>
<!-- --><p>Here is a detailed code for uploading the file. We upload one file at a
time, but the client code post to the lambda endpoint individually for
each file</p>
<!-- --><p>This generates a pre-signed URL to allow the client-side JS (not the
lambda itself) to directly upload to S3, and also posts a row in the S3
to the filename that will. It is very similar code in
to https://cmdcolin.github.io/2020-12-24.html</p>
<!-- --><p>./lambdas/postFile/app.js</p>
<!-- --><pre><code class="language-js">&#x27;use strict&#x27;

const AWS = require(&#x27;aws-sdk&#x27;)
const multipart = require(&#x27;./multipart&#x27;)
AWS.config.update({ region: process.env.AWS_REGION })
const s3 = new AWS.S3()

// Change this value to adjust the signed URL&#x27;s expiration
const URL_EXPIRATION_SECONDS = 300

// Main Lambda entry point
exports.handler = async event =&gt; {
  return await getUploadURL(event)
}

const { AWS_REGION: region } = process.env

const dynamodb = new AWS.DynamoDB({ apiVersion: &#x27;2012-08-10&#x27;, region })

async function uploadPic({
  timestamp,
  filename,
  message,
  user,
  date,
  contentType,
}) {
  const params = {
    Item: {
      timestamp: {
        N: `${timestamp}`,
      },
      filename: {
        S: filename,
      },
      message: {
        S: message,
      },
      user: {
        S: user,
      },
      date: {
        S: date,
      },
      contentType: {
        S: contentType,
      },
    },
    TableName: &#x27;files&#x27;,
  }
  return dynamodb.putItem(params).promise()
}

const getUploadURL = async function (event) {
  try {
    const data = multipart.parse(event)
    const { filename, contentType, user, message, date } = data
    const timestamp = +Date.now()
    const Key = `${timestamp}-${filename}` // Get signed URL from S3

    const s3Params = {
      Bucket: process.env.UploadBucket,
      Key,
      Expires: URL_EXPIRATION_SECONDS,
      ContentType: contentType, // This ACL makes the uploaded object publicly readable. You must also uncomment // the extra permission for the Lambda function in the SAM template.

      ACL: &#x27;public-read&#x27;,
    }

    const uploadURL = await s3.getSignedUrlPromise(&#x27;putObject&#x27;, s3Params)

    await uploadPic({
      timestamp,
      filename: Key,
      message,
      user,
      date,
      contentType,
    })

    return JSON.stringify({
      uploadURL,
      Key,
    })
  } catch (e) {
    const response = {
      statusCode: 500,
      body: JSON.stringify({ message: `${e}` }),
    }
    return response
  }
}
</code></pre>
<!-- --><p>./lambdas/getFiles/app.js</p>
<!-- --><pre><code class="language-js">// eslint-disable-next-line import/no-unresolved
const AWS = require(&#x27;aws-sdk&#x27;)

const { AWS_REGION: region } = process.env

const docClient = new AWS.DynamoDB.DocumentClient()

const getItems = function () {
  const params = {
    TableName: &#x27;files&#x27;,
  }

  return docClient.scan(params).promise()
}

exports.handler = async event =&gt; {
  try {
    const result = await getItems()
    return {
      statusCode: 200,
      body: JSON.stringify(result),
    }
  } catch (e) {
    return {
      statusCode: 400,
      body: JSON.stringify({ message: `${e}` }),
    }
  }
}
</code></pre>
<!-- --><p>./frontend/src/App.tsx (excerpt)</p>
<!-- --><pre><code class="language-tsx">async function myfetch(params: string, opts?: any) {
  const response = await fetch(params, opts)
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}
 ${response.statusText}`)
  }
  return response.json()
}

function UploadDialog({
  open,
  onClose,
}: {
  open: boolean
  onClose: () =&gt; void
}) {
  const [images, setImages] = useState&lt;FileList&gt;()
  const [error, setError] = useState&lt;Error&gt;()
  const [loading, setLoading] = useState(false)
  const [total, setTotal] = useState(0)
  const [completed, setCompleted] = useState(0)
  const [user, setUser] = useState(&#x27;&#x27;)
  const [message, setMessage] = useState(&#x27;&#x27;)
  const classes = useStyles()

  const handleClose = () =&gt; {
    setError(undefined)
    setLoading(false)
    setImages(undefined)
    setCompleted(0)
    setTotal(0)
    setMessage(&#x27;&#x27;)
    onClose()
  }

  return (
    &lt;Dialog onClose={handleClose} open={open}&gt;
           &lt;DialogTitle&gt;upload a file (supports picture or video)&lt;/DialogTitle&gt; 
         
      &lt;DialogContent&gt;
               &lt;label htmlFor=&quot;user&quot;&gt;name (optional) &lt;/label&gt;
               &lt;input
          type=&quot;text&quot;
          value={user}
          onChange={event =&gt; setUser(event.target.value)}
          id=&quot;user&quot;
        /&gt;
               &lt;br /&gt;       &lt;label htmlFor=&quot;user&quot;&gt;message (optional) &lt;/label&gt;
               
        &lt;input
          type=&quot;text&quot;
          value={message}
          onChange={event =&gt; setMessage(event.target.value)}
          id=&quot;message&quot;
        /&gt;
               &lt;br /&gt;
               
        &lt;input
          multiple
          type=&quot;file&quot;
          onChange={e =&gt; {
            let files = e.target.files
            if (files &amp;&amp; files.length) {
              setImages(files)
            }
          }}
        /&gt;       {error ? (
          &lt;div className={classes.error}&gt;{`${error}`}&lt;/div&gt;
        ) : loading ? (
          `Uploading...${completed}/${total}`
        ) : completed ? (
          &lt;h2&gt;Uploaded &lt;/h2&gt;
        ) : null}       &lt;DialogActions&gt;
                   
          &lt;Button
            style={{ textTransform: &#x27;none&#x27; }}
            onClick={async () =&gt; {
              try {
                if (images) {
                  setLoading(true)
                  setError(undefined)
                  setCompleted(0)
                  setTotal(images.length)
                  await Promise.all(
                    Array.from(images).map(async image =&gt; {
                      const data = new FormData()
                      data.append(&#x27;message&#x27;, message)
                      data.append(&#x27;user&#x27;, user)
                      data.append(&#x27;date&#x27;, new Date().toLocaleString())
                      data.append(&#x27;filename&#x27;, image.name)
                      data.append(&#x27;contentType&#x27;, image.type)
                      const res = await myfetch(API_ENDPOINT + &#x27;/postFile&#x27;, {
                        method: &#x27;POST&#x27;,
                        body: data,
                      })

                      await myfetch(res.uploadURL, {
                        method: &#x27;PUT&#x27;,
                        body: image,
                      })

                      setCompleted(completed =&gt; completed + 1)
                    }),
                  )
                  setTimeout(() =&gt; {
                    handleClose()
                  }, 500)
                }
              } catch (e) {
                setError(e)
              }
            }}
            color=&quot;primary&quot;
          &gt;
                       upload          
          &lt;/Button&gt;
                   &lt;Button
            onClick={handleClose}
            color=&quot;primary&quot;
            style={{ textTransform: &#x27;none&#x27; }}
          &gt;
                       cancel          
          &lt;/Button&gt;       
        &lt;/DialogActions&gt;     
      &lt;/DialogContent&gt;
         
    &lt;/Dialog&gt;
  )
}
</code></pre>
<!-- --><p>template.yaml for AWS</p>
<!-- --><pre><code class="language-yaml"> AWSTemplateFormatVersion: 2010-09-09
 Transform: AWS::Serverless-2016-10-31
 Description: S3 Uploader

 Resources:
  filesDynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: &quot;timestamp&quot;
          AttributeType: &quot;N&quot;
      KeySchema:
        - AttributeName: &quot;timestamp&quot;
          KeyType: &quot;HASH&quot;
      ProvisionedThroughput:
        ReadCapacityUnits: &quot;5&quot;
        WriteCapacityUnits: &quot;5&quot;
      TableName: &quot;files&quot;

  # HTTP API
  MyApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      # CORS configuration - this is open for development only and
 should be restricted in prod.
      # See
 &lt;https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-httpapicorsconfiguration.html&gt;
      CorsConfiguration:
        AllowMethods:
          - GET
          - POST
          - DELETE
          - OPTIONS
        AllowHeaders:
          - &quot;*&quot;
        AllowOrigins:
          - &quot;*&quot;

  UploadRequestFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambdas/postFile/
      Handler: app.handler
      Runtime: nodejs12.x
      Timeout: 3
      MemorySize: 128
      Environment:
        Variables:
          UploadBucket: !Ref S3UploadBucket
      Policies:
        - AmazonDynamoDBFullAccess
        - S3WritePolicy:
            BucketName: !Ref S3UploadBucket
        - Statement:
            - Effect: Allow
              Resource: !Sub &quot;arn:aws:s3:::${S3UploadBucket}/&quot;
              Action:
                - s3:putObjectAcl
      Events:
        UploadAssetAPI:
          Type: HttpApi
          Properties:
            Path: /postFile
            Method: post
            ApiId: !Ref MyApi


  FileReadFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambdas/getFiles/
      Handler: app.handler
      Runtime: nodejs12.x
      Timeout: 3
      MemorySize: 128
      Policies:
        - AmazonDynamoDBFullAccess
      Events:
        UploadAssetAPI:
          Type: HttpApi
          Properties:
            Path: /getFiles
            Method: get
            ApiId: !Ref MyApi

  ## S3 bucket
  S3UploadBucket:
    Type: AWS::S3::Bucket
    Properties:
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - &quot;*&quot;
            AllowedMethods:
              - GET
              - PUT
              - HEAD
            AllowedOrigins:
              - &quot;*&quot;


 ## Take a note of the outputs for deploying the workflow templates
 in this sample application
 Outputs:
  APIendpoint:
    Description: &quot;HTTP API endpoint URL&quot;
    Value: !Sub
 &quot;https://${MyApi}.execute-api.${AWS::Region}.amazonaws.com&quot;
  S3UploadBucketName:
    Description: &quot;S3 bucket for application uploads&quot;
    Value: !Ref &quot;S3UploadBucket&quot;

</code></pre>
<!-- --><p>To display all the pictures I use a switch from video or img tag based
on contentType.startsWith(&#x27;video&#x27;). I also use the &quot;figcaption&quot; HTML tag
to have a little caption on the pics/videos</p>
<!-- --><p>./frontend/src/App.tsx</p>
<!-- --><pre><code class="language-tsx">function Media({
  file,
  style,
  onClick,
  children,
}: {
  file: File
  onClick?: Function
  style?: React.CSSProperties
  children?: React.ReactNode
}) {
  const { filename, contentType } = file
  const src = `${BUCKET}/${filename}`
  return (
    &lt;figure style={{ display: &#x27;inline-block&#x27; }}&gt;
           
      &lt;picture&gt;
               
        {contentType.startsWith(&#x27;video&#x27;) ? (
          &lt;video style={style} src={src} controls onClick={onClick as any} /&gt;
        ) : (
          &lt;img style={style} src={src} onClick={onClick as any} /&gt;
        )}
             
      &lt;/picture&gt;
           &lt;figcaption&gt;{children}&lt;/figcaption&gt;   
    &lt;/figure&gt;
  )
}
</code></pre>
<!-- --><p>Now the really fun part: if you get an image of a picture frame
like https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T</p>
<!-- --><p>You can make it a border for any image or video using border-image CSS</p>
<!-- --><pre><code class="language-js">style = {
  border: &#x27;30px solid&#x27;,
  borderImage: `url(borders/${border}) 30 round`,
}
</code></pre>
<!-- --><p><img src="/media/638602799897329664_0.png" alt=""/></p>
<!-- --><p>Summary</p>
<!-- --><p>The template.yaml automatically deploys the lambdas for postFile/getFile
and the files table in dynamoDB</p>
<!-- --><p>The React app uses postFile for each file in an <!-- --><code>&lt;input type=&quot;file&quot;/&gt;</code>,
the code uses React hooks and functional components but is hopefully not
too complex<!-- --></p>
<!-- --><p>I also added commenting on photos. The code is not shown here but you
can look in the source code for details</p>
<!-- --><p><img src="/media/638602799897329664_1.png" alt=""/></p>
<!-- --><p>Overall this has been a good experience learning to develop this app and
learning to automate the cloud deployment is really good for ensuring
reliability and fast iteration.</p>
<!-- --><p>Also quick note on serverless CLI vs aws-sam. I had tried a serverless
CLI tutorial from another user but it didn&#x27;t click with me, while the
aws-sam tutorial from
https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1 was
a great kick start for me. I am sure the serverless CLI is great too and
it ensures a bit less vendor lock in, but then is also a little bit
removed from the native aws config schemas. Probably fine though</p>
<!-- --><p>Source code https://github.com/cmdcolin/aws_photo_gallery/</p><div style="margin-top:200px"></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <!-- --><a href="/archive">Blog archive</a> <!-- --><a href="https://github.com/cmdcolin/">Github</a> <!-- --><a href="https://twitter.com/cmdcolin">Twitter</a> <!-- --><a href="/projects">Projects</a> <!-- --><a href="/photos">Photos</a> <!-- --><a href="/rss.xml">RSS</a><a href="/about">About</a> <!-- --></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Making a serverless website for photo and video upload pt. 2","date":"2020-12-26","slug":"2020-12-26","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      ul: \"ul\",\n      li: \"li\",\n      pre: \"pre\",\n      img: \"img\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"This post follows\\non https://cmdcolin.github.io/2020-12-24.html\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"It is possible I zoomed ahead too fast to make this a continuous tutorial, but\\noverall I just wanted to post an update\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In pt. 1 I learned how to use the \", _jsx(_components.code, {\n          children: \"aws-sam\"\n        }), \" CLI tool. This was a great insight\\nfor me about automating deployments. I can now simply run \", _jsx(_components.code, {\n          children: \"sam deploy\"\n        }), \" and it\\nwill create new dynamodb tables, lambda functions, etc.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"After writing pt 1. I converted the existing vue-js app that was in the aws\\ntutorial and converted it to react. Then I extended the app to allow\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Posting comments on photos\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Uploading multiple files\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Uploading videos etc.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"It will be hard to summarize all the changes since now the app has taken off a\\nlittle bit but it looks like this:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Repo structure\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \" ./frontend # created using npx create-react-app frontend --template\\n typescript\\n ./frontend/src/App.tsx # main frontend app code in react\\n ./lambdas/\\n ./lambdas/postFile # post a file to the lambda, this uploads a row to\\n dynamodb and returns a pre-signed URL for uploading (note that if the\\n client failed it's upload, that row in the lambda DB might be in a bad\\n state...)\\n ./lambdas/getFiles # get all files that were ever posted\\n ./lambdas/postComment # post a comment on a picture with POST\\n request\\n ./lambdas/getComments?file=filename.jpg # get comments on a\\n picture/video with GET request\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Here is a detailed code for uploading the file. We upload one file at a\\ntime, but the client code post to the lambda endpoint individually for\\neach file\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This generates a pre-signed URL to allow the client-side JS (not the\\nlambda itself) to directly upload to S3, and also posts a row in the S3\\nto the filename that will. It is very similar code in\\nto https://cmdcolin.github.io/2020-12-24.html\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"./lambdas/postFile/app.js\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"'use strict'\\n\\nconst AWS = require('aws-sdk')\\nconst multipart = require('./multipart')\\nAWS.config.update({ region: process.env.AWS_REGION })\\nconst s3 = new AWS.S3()\\n\\n// Change this value to adjust the signed URL's expiration\\nconst URL_EXPIRATION_SECONDS = 300\\n\\n// Main Lambda entry point\\nexports.handler = async event =\u003e {\\n  return await getUploadURL(event)\\n}\\n\\nconst { AWS_REGION: region } = process.env\\n\\nconst dynamodb = new AWS.DynamoDB({ apiVersion: '2012-08-10', region })\\n\\nasync function uploadPic({\\n  timestamp,\\n  filename,\\n  message,\\n  user,\\n  date,\\n  contentType,\\n}) {\\n  const params = {\\n    Item: {\\n      timestamp: {\\n        N: `${timestamp}`,\\n      },\\n      filename: {\\n        S: filename,\\n      },\\n      message: {\\n        S: message,\\n      },\\n      user: {\\n        S: user,\\n      },\\n      date: {\\n        S: date,\\n      },\\n      contentType: {\\n        S: contentType,\\n      },\\n    },\\n    TableName: 'files',\\n  }\\n  return dynamodb.putItem(params).promise()\\n}\\n\\nconst getUploadURL = async function (event) {\\n  try {\\n    const data = multipart.parse(event)\\n    const { filename, contentType, user, message, date } = data\\n    const timestamp = +Date.now()\\n    const Key = `${timestamp}-${filename}` // Get signed URL from S3\\n\\n    const s3Params = {\\n      Bucket: process.env.UploadBucket,\\n      Key,\\n      Expires: URL_EXPIRATION_SECONDS,\\n      ContentType: contentType, // This ACL makes the uploaded object publicly readable. You must also uncomment // the extra permission for the Lambda function in the SAM template.\\n\\n      ACL: 'public-read',\\n    }\\n\\n    const uploadURL = await s3.getSignedUrlPromise('putObject', s3Params)\\n\\n    await uploadPic({\\n      timestamp,\\n      filename: Key,\\n      message,\\n      user,\\n      date,\\n      contentType,\\n    })\\n\\n    return JSON.stringify({\\n      uploadURL,\\n      Key,\\n    })\\n  } catch (e) {\\n    const response = {\\n      statusCode: 500,\\n      body: JSON.stringify({ message: `${e}` }),\\n    }\\n    return response\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"./lambdas/getFiles/app.js\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"// eslint-disable-next-line import/no-unresolved\\nconst AWS = require('aws-sdk')\\n\\nconst { AWS_REGION: region } = process.env\\n\\nconst docClient = new AWS.DynamoDB.DocumentClient()\\n\\nconst getItems = function () {\\n  const params = {\\n    TableName: 'files',\\n  }\\n\\n  return docClient.scan(params).promise()\\n}\\n\\nexports.handler = async event =\u003e {\\n  try {\\n    const result = await getItems()\\n    return {\\n      statusCode: 200,\\n      body: JSON.stringify(result),\\n    }\\n  } catch (e) {\\n    return {\\n      statusCode: 400,\\n      body: JSON.stringify({ message: `${e}` }),\\n    }\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"./frontend/src/App.tsx (excerpt)\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-tsx\",\n          children: \"async function myfetch(params: string, opts?: any) {\\n  const response = await fetch(params, opts)\\n  if (!response.ok) {\\n    throw new Error(`HTTP ${response.status}\\n ${response.statusText}`)\\n  }\\n  return response.json()\\n}\\n\\nfunction UploadDialog({\\n  open,\\n  onClose,\\n}: {\\n  open: boolean\\n  onClose: () =\u003e void\\n}) {\\n  const [images, setImages] = useState\u003cFileList\u003e()\\n  const [error, setError] = useState\u003cError\u003e()\\n  const [loading, setLoading] = useState(false)\\n  const [total, setTotal] = useState(0)\\n  const [completed, setCompleted] = useState(0)\\n  const [user, setUser] = useState('')\\n  const [message, setMessage] = useState('')\\n  const classes = useStyles()\\n\\n  const handleClose = () =\u003e {\\n    setError(undefined)\\n    setLoading(false)\\n    setImages(undefined)\\n    setCompleted(0)\\n    setTotal(0)\\n    setMessage('')\\n    onClose()\\n  }\\n\\n  return (\\n    \u003cDialog onClose={handleClose} open={open}\u003e\\n           \u003cDialogTitle\u003eupload a file (supports picture or video)\u003c/DialogTitle\u003e \\n         \\n      \u003cDialogContent\u003e\\n               \u003clabel htmlFor=\\\"user\\\"\u003ename (optional) \u003c/label\u003e\\n               \u003cinput\\n          type=\\\"text\\\"\\n          value={user}\\n          onChange={event =\u003e setUser(event.target.value)}\\n          id=\\\"user\\\"\\n        /\u003e\\n               \u003cbr /\u003e       \u003clabel htmlFor=\\\"user\\\"\u003emessage (optional) \u003c/label\u003e\\n               \\n        \u003cinput\\n          type=\\\"text\\\"\\n          value={message}\\n          onChange={event =\u003e setMessage(event.target.value)}\\n          id=\\\"message\\\"\\n        /\u003e\\n               \u003cbr /\u003e\\n               \\n        \u003cinput\\n          multiple\\n          type=\\\"file\\\"\\n          onChange={e =\u003e {\\n            let files = e.target.files\\n            if (files \u0026\u0026 files.length) {\\n              setImages(files)\\n            }\\n          }}\\n        /\u003e       {error ? (\\n          \u003cdiv className={classes.error}\u003e{`${error}`}\u003c/div\u003e\\n        ) : loading ? (\\n          `Uploading...${completed}/${total}`\\n        ) : completed ? (\\n          \u003ch2\u003eUploaded \u003c/h2\u003e\\n        ) : null}       \u003cDialogActions\u003e\\n                   \\n          \u003cButton\\n            style={{ textTransform: 'none' }}\\n            onClick={async () =\u003e {\\n              try {\\n                if (images) {\\n                  setLoading(true)\\n                  setError(undefined)\\n                  setCompleted(0)\\n                  setTotal(images.length)\\n                  await Promise.all(\\n                    Array.from(images).map(async image =\u003e {\\n                      const data = new FormData()\\n                      data.append('message', message)\\n                      data.append('user', user)\\n                      data.append('date', new Date().toLocaleString())\\n                      data.append('filename', image.name)\\n                      data.append('contentType', image.type)\\n                      const res = await myfetch(API_ENDPOINT + '/postFile', {\\n                        method: 'POST',\\n                        body: data,\\n                      })\\n\\n                      await myfetch(res.uploadURL, {\\n                        method: 'PUT',\\n                        body: image,\\n                      })\\n\\n                      setCompleted(completed =\u003e completed + 1)\\n                    }),\\n                  )\\n                  setTimeout(() =\u003e {\\n                    handleClose()\\n                  }, 500)\\n                }\\n              } catch (e) {\\n                setError(e)\\n              }\\n            }}\\n            color=\\\"primary\\\"\\n          \u003e\\n                       upload          \\n          \u003c/Button\u003e\\n                   \u003cButton\\n            onClick={handleClose}\\n            color=\\\"primary\\\"\\n            style={{ textTransform: 'none' }}\\n          \u003e\\n                       cancel          \\n          \u003c/Button\u003e       \\n        \u003c/DialogActions\u003e     \\n      \u003c/DialogContent\u003e\\n         \\n    \u003c/Dialog\u003e\\n  )\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"template.yaml for AWS\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-yaml\",\n          children: \" AWSTemplateFormatVersion: 2010-09-09\\n Transform: AWS::Serverless-2016-10-31\\n Description: S3 Uploader\\n\\n Resources:\\n  filesDynamoDBTable:\\n    Type: AWS::DynamoDB::Table\\n    Properties:\\n      AttributeDefinitions:\\n        - AttributeName: \\\"timestamp\\\"\\n          AttributeType: \\\"N\\\"\\n      KeySchema:\\n        - AttributeName: \\\"timestamp\\\"\\n          KeyType: \\\"HASH\\\"\\n      ProvisionedThroughput:\\n        ReadCapacityUnits: \\\"5\\\"\\n        WriteCapacityUnits: \\\"5\\\"\\n      TableName: \\\"files\\\"\\n\\n  # HTTP API\\n  MyApi:\\n    Type: AWS::Serverless::HttpApi\\n    Properties:\\n      # CORS configuration - this is open for development only and\\n should be restricted in prod.\\n      # See\\n \u003chttps://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-httpapicorsconfiguration.html\u003e\\n      CorsConfiguration:\\n        AllowMethods:\\n          - GET\\n          - POST\\n          - DELETE\\n          - OPTIONS\\n        AllowHeaders:\\n          - \\\"*\\\"\\n        AllowOrigins:\\n          - \\\"*\\\"\\n\\n  UploadRequestFunction:\\n    Type: AWS::Serverless::Function\\n    Properties:\\n      CodeUri: lambdas/postFile/\\n      Handler: app.handler\\n      Runtime: nodejs12.x\\n      Timeout: 3\\n      MemorySize: 128\\n      Environment:\\n        Variables:\\n          UploadBucket: !Ref S3UploadBucket\\n      Policies:\\n        - AmazonDynamoDBFullAccess\\n        - S3WritePolicy:\\n            BucketName: !Ref S3UploadBucket\\n        - Statement:\\n            - Effect: Allow\\n              Resource: !Sub \\\"arn:aws:s3:::${S3UploadBucket}/\\\"\\n              Action:\\n                - s3:putObjectAcl\\n      Events:\\n        UploadAssetAPI:\\n          Type: HttpApi\\n          Properties:\\n            Path: /postFile\\n            Method: post\\n            ApiId: !Ref MyApi\\n\\n\\n  FileReadFunction:\\n    Type: AWS::Serverless::Function\\n    Properties:\\n      CodeUri: lambdas/getFiles/\\n      Handler: app.handler\\n      Runtime: nodejs12.x\\n      Timeout: 3\\n      MemorySize: 128\\n      Policies:\\n        - AmazonDynamoDBFullAccess\\n      Events:\\n        UploadAssetAPI:\\n          Type: HttpApi\\n          Properties:\\n            Path: /getFiles\\n            Method: get\\n            ApiId: !Ref MyApi\\n\\n  ## S3 bucket\\n  S3UploadBucket:\\n    Type: AWS::S3::Bucket\\n    Properties:\\n      CorsConfiguration:\\n        CorsRules:\\n          - AllowedHeaders:\\n              - \\\"*\\\"\\n            AllowedMethods:\\n              - GET\\n              - PUT\\n              - HEAD\\n            AllowedOrigins:\\n              - \\\"*\\\"\\n\\n\\n ## Take a note of the outputs for deploying the workflow templates\\n in this sample application\\n Outputs:\\n  APIendpoint:\\n    Description: \\\"HTTP API endpoint URL\\\"\\n    Value: !Sub\\n \\\"https://${MyApi}.execute-api.${AWS::Region}.amazonaws.com\\\"\\n  S3UploadBucketName:\\n    Description: \\\"S3 bucket for application uploads\\\"\\n    Value: !Ref \\\"S3UploadBucket\\\"\\n\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"To display all the pictures I use a switch from video or img tag based\\non contentType.startsWith('video'). I also use the \\\"figcaption\\\" HTML tag\\nto have a little caption on the pics/videos\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"./frontend/src/App.tsx\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-tsx\",\n          children: \"function Media({\\n  file,\\n  style,\\n  onClick,\\n  children,\\n}: {\\n  file: File\\n  onClick?: Function\\n  style?: React.CSSProperties\\n  children?: React.ReactNode\\n}) {\\n  const { filename, contentType } = file\\n  const src = `${BUCKET}/${filename}`\\n  return (\\n    \u003cfigure style={{ display: 'inline-block' }}\u003e\\n           \\n      \u003cpicture\u003e\\n               \\n        {contentType.startsWith('video') ? (\\n          \u003cvideo style={style} src={src} controls onClick={onClick as any} /\u003e\\n        ) : (\\n          \u003cimg style={style} src={src} onClick={onClick as any} /\u003e\\n        )}\\n             \\n      \u003c/picture\u003e\\n           \u003cfigcaption\u003e{children}\u003c/figcaption\u003e   \\n    \u003c/figure\u003e\\n  )\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now the really fun part: if you get an image of a picture frame\\nlike https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You can make it a border for any image or video using border-image CSS\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"style = {\\n  border: '30px solid',\\n  borderImage: `url(borders/${border}) 30 round`,\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/638602799897329664_0.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Summary\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The template.yaml automatically deploys the lambdas for postFile/getFile\\nand the files table in dynamoDB\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The React app uses postFile for each file in an \", _jsx(_components.code, {\n          children: \"\u003cinput type=\\\"file\\\"/\u003e\"\n        }), \",\\nthe code uses React hooks and functional components but is hopefully not\\ntoo complex\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I also added commenting on photos. The code is not shown here but you\\ncan look in the source code for details\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/638602799897329664_1.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Overall this has been a good experience learning to develop this app and\\nlearning to automate the cloud deployment is really good for ensuring\\nreliability and fast iteration.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Also quick note on serverless CLI vs aws-sam. I had tried a serverless\\nCLI tutorial from another user but it didn't click with me, while the\\naws-sam tutorial from\\nhttps://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1 was\\na great kick start for me. I am sure the serverless CLI is great too and\\nit ensures a bit less vendor lock in, but then is also a little bit\\nremoved from the native aws config schemas. Probably fine though\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Source code https://github.com/cmdcolin/aws_photo_gallery/\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2020-12-26"},"buildId":"S652vUFlobT6RAYGmEXUt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>