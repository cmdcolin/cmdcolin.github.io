<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Making a serverless website for photo and video upload pt. 2</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/fd6c173fc46e1e45.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fd6c173fc46e1e45.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-7c3bf82eed00c281.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3f0808b29fe77886.js" defer=""></script><script src="/_next/static/0tjr6FsYvWOBkn9QJhA2V/_buildManifest.js" defer=""></script><script src="/_next/static/0tjr6FsYvWOBkn9QJhA2V/_ssgManifest.js" defer=""></script><script src="/_next/static/0tjr6FsYvWOBkn9QJhA2V/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div><a href="/">Misc scribbles</a></div><article><h1>Making a serverless website for photo and video upload pt. 2<!-- --> - <!-- -->2020-12-26</h1><p>This post follows
on <a href="https://cmdcolin.github.io/2020-12-24.html">https://cmdcolin.github.io/2020-12-24.html</a></p><p>It is possible I zoomed ahead too fast to make this a continuous
tutorial, but overall I just wanted to post an update</p><p>In pt. 1 I learned how to use the <code>aws-sam</code> CLI tool. This was a great
insight for me about automating deployments. I can now simply run <code>sam deploy</code> and it will create new dynamodb tables, lambda functions, etc.</p><p>After writing pt 1. I converted the existing vue-js app that was in the
aws tutorial and converted it to react. Then I extended the app to allow</p><ul><li>Posting comments on photos</li><li>Uploading multiple files</li><li>Uploading videos
etc.</li></ul><p>It will be hard to summarize all the changes since now the app has taken
off a little bit but it looks like this:</p><p>Repo structure</p><pre><code> ./frontend # created using npx create-react-app frontend --template
 typescript
 ./frontend/src/App.tsx # main frontend app code in react
 ./lambdas/
 ./lambdas/postFile # post a file to the lambda, this uploads a row to
 dynamodb and returns a pre-signed URL for uploading (note that if the
 client failed it&#x27;s upload, that row in the lambda DB might be in a bad
 state...)
 ./lambdas/getFiles # get all files that were ever posted
 ./lambdas/postComment # post a comment on a picture with POST
 request
 ./lambdas/getComments?file=filename.jpg # get comments on a
 picture/video with GET request
</code></pre><p>Here is a detailed code for uploading the file. We upload one file at a
time, but the client code post to the lambda endpoint individually for
each file</p><p>This generates a pre-signed URL to allow the client-side JS (not the
lambda itself) to directly upload to S3, and also posts a row in the S3
to the filename that will. It is very similar code in
to <a href="https://cmdcolin.github.io/2020-12-24.html">https://cmdcolin.github.io/2020-12-24.html</a></p><p>./lambdas/postFile/app.js</p><pre><code class="language-js">&#x27;use strict&#x27;

const AWS = require(&#x27;aws-sdk&#x27;)
const multipart = require(&#x27;./multipart&#x27;)
AWS.config.update({ region: process.env.AWS_REGION })
const s3 = new AWS.S3()

// Change this value to adjust the signed URL&#x27;s expiration
const URL_EXPIRATION_SECONDS = 300

// Main Lambda entry point
exports.handler = async event =&gt; {
  return await getUploadURL(event)
}

const { AWS_REGION: region } = process.env

const dynamodb = new AWS.DynamoDB({ apiVersion: &#x27;2012-08-10&#x27;, region })

async function uploadPic({
  timestamp,
  filename,
  message,
  user,
  date,
  contentType,
}) {
  const params = {
    Item: {
      timestamp: {
        N: `${timestamp}`,
      },
      filename: {
        S: filename,
      },
      message: {
        S: message,
      },
      user: {
        S: user,
      },
      date: {
        S: date,
      },
      contentType: {
        S: contentType,
      },
    },
    TableName: &#x27;files&#x27;,
  }
  return dynamodb.putItem(params).promise()
}

const getUploadURL = async function (event) {
  try {
    const data = multipart.parse(event)
    const { filename, contentType, user, message, date } = data
    const timestamp = +Date.now()
    const Key = `${timestamp}-${filename}` // Get signed URL from S3

    const s3Params = {
      Bucket: process.env.UploadBucket,
      Key,
      Expires: URL_EXPIRATION_SECONDS,
      ContentType: contentType, // This ACL makes the uploaded object publicly readable. You must also uncomment // the extra permission for the Lambda function in the SAM template.

      ACL: &#x27;public-read&#x27;,
    }

    const uploadURL = await s3.getSignedUrlPromise(&#x27;putObject&#x27;, s3Params)

    await uploadPic({
      timestamp,
      filename: Key,
      message,
      user,
      date,
      contentType,
    })

    return JSON.stringify({
      uploadURL,
      Key,
    })
  } catch (e) {
    const response = {
      statusCode: 500,
      body: JSON.stringify({ message: `${e}` }),
    }
    return response
  }
}
</code></pre><p>./lambdas/getFiles/app.js</p><pre><code class="language-js">// eslint-disable-next-line import/no-unresolved
const AWS = require(&#x27;aws-sdk&#x27;)

const { AWS_REGION: region } = process.env

const docClient = new AWS.DynamoDB.DocumentClient()

const getItems = function () {
  const params = {
    TableName: &#x27;files&#x27;,
  }

  return docClient.scan(params).promise()
}

exports.handler = async event =&gt; {
  try {
    const result = await getItems()
    return {
      statusCode: 200,
      body: JSON.stringify(result),
    }
  } catch (e) {
    return {
      statusCode: 400,
      body: JSON.stringify({ message: `${e}` }),
    }
  }
}
</code></pre><p>./frontend/src/App.tsx (excerpt)</p><pre><code class="language-tsx">async function myfetch(params: string, opts?: any) {
  const response = await fetch(params, opts)
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}
 ${response.statusText}`)
  }
  return response.json()
}

function UploadDialog({
  open,
  onClose,
}: {
  open: boolean
  onClose: () =&gt; void
}) {
  const [images, setImages] = useState&lt;FileList&gt;()
  const [error, setError] = useState&lt;Error&gt;()
  const [loading, setLoading] = useState(false)
  const [total, setTotal] = useState(0)
  const [completed, setCompleted] = useState(0)
  const [user, setUser] = useState(&#x27;&#x27;)
  const [message, setMessage] = useState(&#x27;&#x27;)
  const classes = useStyles()

  const handleClose = () =&gt; {
    setError(undefined)
    setLoading(false)
    setImages(undefined)
    setCompleted(0)
    setTotal(0)
    setMessage(&#x27;&#x27;)
    onClose()
  }

  return (
    &lt;Dialog onClose={handleClose} open={open}&gt;
           &lt;DialogTitle&gt;upload a file (supports picture or video)&lt;/DialogTitle&gt; 
         &lt;DialogContent&gt;
               &lt;label htmlFor=&quot;user&quot;&gt;name (optional) &lt;/label&gt;
               &lt;input
          type=&quot;text&quot;
          value={user}
          onChange={event =&gt; setUser(event.target.value)}
          id=&quot;user&quot;
        /&gt;
               &lt;br /&gt;       &lt;label htmlFor=&quot;user&quot;&gt;message (optional) &lt;/label&gt;
               
        &lt;input
          type=&quot;text&quot;
          value={message}
          onChange={event =&gt; setMessage(event.target.value)}
          id=&quot;message&quot;
        /&gt;
               &lt;br /&gt;
               
        &lt;input
          multiple
          type=&quot;file&quot;
          onChange={e =&gt; {
            let files = e.target.files
            if (files &amp;&amp; files.length) {
              setImages(files)
            }
          }}
        /&gt;
               {error ? (
          &lt;div className={classes.error}&gt;{`${error}`}&lt;/div&gt;
        ) : loading ? (
          `Uploading...${completed}/${total}`
        ) : completed ? (
          &lt;h2&gt;Uploaded &lt;/h2&gt;
        ) : null}       
        &lt;DialogActions&gt;
                   
          &lt;Button
            style={{ textTransform: &#x27;none&#x27; }}
            onClick={async () =&gt; {
              try {
                if (images) {
                  setLoading(true)
                  setError(undefined)
                  setCompleted(0)
                  setTotal(images.length)
                  await Promise.all(
                    Array.from(images).map(async image =&gt; {
                      const data = new FormData()
                      data.append(&#x27;message&#x27;, message)
                      data.append(&#x27;user&#x27;, user)
                      data.append(&#x27;date&#x27;, new Date().toLocaleString())
                      data.append(&#x27;filename&#x27;, image.name)
                      data.append(&#x27;contentType&#x27;, image.type)
                      const res = await myfetch(API_ENDPOINT + &#x27;/postFile&#x27;, {
                        method: &#x27;POST&#x27;,
                        body: data,
                      })

                      await myfetch(res.uploadURL, {
                        method: &#x27;PUT&#x27;,
                        body: image,
                      })

                      setCompleted(completed =&gt; completed + 1)
                    }),
                  )
                  setTimeout(() =&gt; {
                    handleClose()
                  }, 500)
                }
              } catch (e) {
                setError(e)
              }
            }}
            color=&quot;primary&quot;
          &gt;
                       upload          
          &lt;/Button&gt;
                   &lt;Button
            onClick={handleClose}
            color=&quot;primary&quot;
            style={{ textTransform: &#x27;none&#x27; }}
          &gt;
                       cancel          
          &lt;/Button&gt;       
        &lt;/DialogActions&gt;
             
      &lt;/DialogContent&gt;   
    &lt;/Dialog&gt;
  )
}
</code></pre><p>template.yaml for AWS</p><pre><code> AWSTemplateFormatVersion: 2010-09-09
 Transform: AWS::Serverless-2016-10-31
 Description: S3 Uploader

 Resources:
  filesDynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: &quot;timestamp&quot;
          AttributeType: &quot;N&quot;
      KeySchema:
        - AttributeName: &quot;timestamp&quot;
          KeyType: &quot;HASH&quot;
      ProvisionedThroughput:
        ReadCapacityUnits: &quot;5&quot;
        WriteCapacityUnits: &quot;5&quot;
      TableName: &quot;files&quot;

  # HTTP API
  MyApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      # CORS configuration - this is open for development only and
 should be restricted in prod.
      # See
 &lt;https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-httpapicorsconfiguration.html&gt;
      CorsConfiguration:
        AllowMethods:
          - GET
          - POST
          - DELETE
          - OPTIONS
        AllowHeaders:
          - &quot;*&quot;
        AllowOrigins:
          - &quot;*&quot;

  UploadRequestFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambdas/postFile/
      Handler: app.handler
      Runtime: nodejs12.x
      Timeout: 3
      MemorySize: 128
      Environment:
        Variables:
          UploadBucket: !Ref S3UploadBucket
      Policies:
        - AmazonDynamoDBFullAccess
        - S3WritePolicy:
            BucketName: !Ref S3UploadBucket
        - Statement:
            - Effect: Allow
              Resource: !Sub &quot;arn:aws:s3:::${S3UploadBucket}/&quot;
              Action:
                - s3:putObjectAcl
      Events:
        UploadAssetAPI:
          Type: HttpApi
          Properties:
            Path: /postFile
            Method: post
            ApiId: !Ref MyApi


  FileReadFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambdas/getFiles/
      Handler: app.handler
      Runtime: nodejs12.x
      Timeout: 3
      MemorySize: 128
      Policies:
        - AmazonDynamoDBFullAccess
      Events:
        UploadAssetAPI:
          Type: HttpApi
          Properties:
            Path: /getFiles
            Method: get
            ApiId: !Ref MyApi

  ## S3 bucket
  S3UploadBucket:
    Type: AWS::S3::Bucket
    Properties:
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - &quot;*&quot;
            AllowedMethods:
              - GET
              - PUT
              - HEAD
            AllowedOrigins:
              - &quot;*&quot;


 ## Take a note of the outputs for deploying the workflow templates
 in this sample application
 Outputs:
  APIendpoint:
    Description: &quot;HTTP API endpoint URL&quot;
    Value: !Sub
 &quot;https://${MyApi}.execute-api.${AWS::Region}.amazonaws.com&quot;
  S3UploadBucketName:
    Description: &quot;S3 bucket for application uploads&quot;
    Value: !Ref &quot;S3UploadBucket&quot;

</code></pre><p>To display all the pictures I use a switch from video or img tag based
on contentType.startsWith(&#x27;video&#x27;). I also use the &quot;figcaption&quot; HTML tag
to have a little caption on the pics/videos</p><p>./frontend/src/App.tsx</p><pre><code> function Media({
  file,
  style,
  onClick,
  children,
 }: {
  file: File;
  onClick?: Function;
  style?: React.CSSProperties;
  children?: React.ReactNode;
 }) {
  const { filename, contentType } = file;
  const src = `${BUCKET}/${filename}`;
  return (
    &lt;figure style={{ display: &quot;inline-block&quot; }}&gt;
      &lt;picture&gt;
        {contentType.startsWith(&quot;video&quot;) ? (
          &lt;video style={style} src={src} controls onClick={onClick as
 any} /&gt;
        ) : (
          &lt;img style={style} src={src} onClick={onClick as any} /&gt;
        )}
      &lt;/picture&gt;
      &lt;figcaption&gt;{children}&lt;/figcaption&gt;
    &lt;/figure&gt;
  );
 }
</code></pre><p>Now the really fun part: if you get an image of a picture frame
like <a href="https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T">https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T</a></p><p>You can make it a border for any image or video using border-image CSS</p><pre><code>     style = {
         border: &quot;30px solid&quot;,
         borderImage: `url(borders/${border}) 30 round`
     }
</code></pre><p><img src="/media/638602799897329664_0.png"/></p><p>Summary</p><p>The template.yaml automatically deploys the lambdas for postFile/getFile
and the files table in dynamoDB</p><p>The React app uses postFile for each file in an <code>&lt;input type=&quot;file&quot;/&gt;</code>,
the code uses React hooks and functional components but is hopefully not
too complex</p><p>I also added commenting on photos. The code is not shown here but you
can look in the source code for details</p><p><img src="/media/638602799897329664_1.png"/></p><p>Overall this has been a good experience learning to develop this app and
learning to automate the cloud deployment is really good for ensuring
reliability and fast iteration.</p><p>Also quick note on serverless CLI vs aws-sam. I had tried a serverless
CLI tutorial from another user but it didn&#x27;t click with me, while the
aws-sam tutorial from
<a href="https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1">https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1</a> was
a great kick start for me. I am sure the serverless CLI is great too and
it ensures a bit less vendor lock in, but then is also a little bit
removed from the native aws config schemas. Probably fine though</p><p>Source code <a href="https://github.com/cmdcolin/aws_photo_gallery/">https://github.com/cmdcolin/aws_photo_gallery/</a></p></article></div></main></div><footer style="margin-top:20px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Making a serverless website for photo and video upload pt. 2","date":"2020-12-26","slug":"2020-12-26","mdxSource":{"compiledSource":"var c=Object.defineProperty,m=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(e,t,o)=\u003et in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,a=(e,t)=\u003e{for(var o in t||(t={}))i.call(t,o)\u0026\u0026l(e,o,t[o]);if(n)for(var o of n(t))r.call(t,o)\u0026\u0026l(e,o,t[o]);return e},p=(e,t)=\u003em(e,u(t));var d=(e,t)=\u003e{var o={};for(var s in e)i.call(e,s)\u0026\u0026t.indexOf(s)\u003c0\u0026\u0026(o[s]=e[s]);if(e!=null\u0026\u0026n)for(var s of n(e))t.indexOf(s)\u003c0\u0026\u0026r.call(e,s)\u0026\u0026(o[s]=e[s]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var s=o,{components:e}=s,t=d(s,[\"components\"]);return mdx(MDXLayout,p(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`This post follows\non\\xA0`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://cmdcolin.github.io/2020-12-24.html\"}),\"https://cmdcolin.github.io/2020-12-24.html\")),mdx(\"p\",null,`It is possible I zoomed ahead too fast to make this a continuous\ntutorial, but overall I just wanted to post an update`),mdx(\"p\",null,\"In pt. 1 I learned how to use the \",mdx(\"inlineCode\",{parentName:\"p\"},\"aws-sam\"),` CLI tool. This was a great\ninsight for me about automating deployments. I can now simply run `,mdx(\"inlineCode\",{parentName:\"p\"},\"sam deploy\"),\" and it will create new dynamodb tables, lambda functions, etc.\"),mdx(\"p\",null,`After writing pt 1. I converted the existing vue-js app that was in the\naws tutorial and converted it to react. Then I extended the app to allow`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Posting comments on photos\"),mdx(\"li\",{parentName:\"ul\"},\"Uploading multiple files\"),mdx(\"li\",{parentName:\"ul\"},`Uploading videos\netc.`)),mdx(\"p\",null,`It will be hard to summarize all the changes since now the app has taken\noff a little bit but it looks like this:`),mdx(\"p\",null,\"Repo structure\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),` ./frontend # created using npx create-react-app frontend --template\n typescript\n ./frontend/src/App.tsx # main frontend app code in react\n ./lambdas/\n ./lambdas/postFile # post a file to the lambda, this uploads a row to\n dynamodb and returns a pre-signed URL for uploading (note that if the\n client failed it's upload, that row in the lambda DB might be in a bad\n state...)\n ./lambdas/getFiles # get all files that were ever posted\n ./lambdas/postComment # post a comment on a picture with POST\n request\n ./lambdas/getComments?file=filename.jpg # get comments on a\n picture/video with GET request\n`)),mdx(\"p\",null,`Here is a detailed code for uploading the file. We upload one file at a\ntime, but the client code post to the lambda endpoint individually for\neach file`),mdx(\"p\",null,`This generates a pre-signed URL to allow the client-side JS (not the\nlambda itself) to directly upload to S3, and also posts a row in the S3\nto the filename that will. It is very similar code in\nto\\xA0`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://cmdcolin.github.io/2020-12-24.html\"}),\"https://cmdcolin.github.io/2020-12-24.html\")),mdx(\"p\",null,\"./lambdas/postFile/app.js\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\"}),`'use strict'\n\nconst AWS = require('aws-sdk')\nconst multipart = require('./multipart')\nAWS.config.update({ region: process.env.AWS_REGION })\nconst s3 = new AWS.S3()\n\n// Change this value to adjust the signed URL's expiration\nconst URL_EXPIRATION_SECONDS = 300\n\n// Main Lambda entry point\nexports.handler = async event =\u003e {\n  return await getUploadURL(event)\n}\n\nconst { AWS_REGION: region } = process.env\n\nconst dynamodb = new AWS.DynamoDB({ apiVersion: '2012-08-10', region })\n\nasync function uploadPic({\n  timestamp,\n  filename,\n  message,\n  user,\n  date,\n  contentType,\n}) {\n  const params = {\n    Item: {\n      timestamp: {\n        N: \\`\\${timestamp}\\`,\n      },\n      filename: {\n        S: filename,\n      },\n      message: {\n        S: message,\n      },\n      user: {\n        S: user,\n      },\n      date: {\n        S: date,\n      },\n      contentType: {\n        S: contentType,\n      },\n    },\n    TableName: 'files',\n  }\n  return dynamodb.putItem(params).promise()\n}\n\nconst getUploadURL = async function (event) {\n  try {\n    const data = multipart.parse(event)\n    const { filename, contentType, user, message, date } = data\n    const timestamp = +Date.now()\n    const Key = \\`\\${timestamp}-\\${filename}\\` // Get signed URL from S3\n\n    const s3Params = {\n      Bucket: process.env.UploadBucket,\n      Key,\n      Expires: URL_EXPIRATION_SECONDS,\n      ContentType: contentType, // This ACL makes the uploaded object publicly readable. You must also uncomment // the extra permission for the Lambda function in the SAM template.\n\n      ACL: 'public-read',\n    }\n\n    const uploadURL = await s3.getSignedUrlPromise('putObject', s3Params)\n\n    await uploadPic({\n      timestamp,\n      filename: Key,\n      message,\n      user,\n      date,\n      contentType,\n    })\n\n    return JSON.stringify({\n      uploadURL,\n      Key,\n    })\n  } catch (e) {\n    const response = {\n      statusCode: 500,\n      body: JSON.stringify({ message: \\`\\${e}\\` }),\n    }\n    return response\n  }\n}\n`)),mdx(\"p\",null,\"./lambdas/getFiles/app.js\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\"}),`// eslint-disable-next-line import/no-unresolved\nconst AWS = require('aws-sdk')\n\nconst { AWS_REGION: region } = process.env\n\nconst docClient = new AWS.DynamoDB.DocumentClient()\n\nconst getItems = function () {\n  const params = {\n    TableName: 'files',\n  }\n\n  return docClient.scan(params).promise()\n}\n\nexports.handler = async event =\u003e {\n  try {\n    const result = await getItems()\n    return {\n      statusCode: 200,\n      body: JSON.stringify(result),\n    }\n  } catch (e) {\n    return {\n      statusCode: 400,\n      body: JSON.stringify({ message: \\`\\${e}\\` }),\n    }\n  }\n}\n`)),mdx(\"p\",null,\"./frontend/src/App.tsx (excerpt)\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-tsx\"}),`async function myfetch(params: string, opts?: any) {\n  const response = await fetch(params, opts)\n  if (!response.ok) {\n    throw new Error(\\`HTTP \\${response.status}\n \\${response.statusText}\\`)\n  }\n  return response.json()\n}\n\nfunction UploadDialog({\n  open,\n  onClose,\n}: {\n  open: boolean\n  onClose: () =\u003e void\n}) {\n  const [images, setImages] = useState\u003cFileList\u003e()\n  const [error, setError] = useState\u003cError\u003e()\n  const [loading, setLoading] = useState(false)\n  const [total, setTotal] = useState(0)\n  const [completed, setCompleted] = useState(0)\n  const [user, setUser] = useState('')\n  const [message, setMessage] = useState('')\n  const classes = useStyles()\n\n  const handleClose = () =\u003e {\n    setError(undefined)\n    setLoading(false)\n    setImages(undefined)\n    setCompleted(0)\n    setTotal(0)\n    setMessage('')\n    onClose()\n  }\n\n  return (\n    \u003cDialog onClose={handleClose} open={open}\u003e\n      \\xA0 \\xA0 \\xA0\u003cDialogTitle\u003eupload a file (supports picture or video)\u003c/DialogTitle\u003e\\xA0\n      \\xA0 \\xA0\u003cDialogContent\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0\u003clabel htmlFor=\"user\"\u003ename (optional) \u003c/label\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0\u003cinput\n          type=\"text\"\n          value={user}\n          onChange={event =\u003e setUser(event.target.value)}\n          id=\"user\"\n        /\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0\u003cbr /\u003e\\xA0 \\xA0 \\xA0 \\xA0\u003clabel htmlFor=\"user\"\u003emessage (optional) \u003c/label\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0\n        \u003cinput\n          type=\"text\"\n          value={message}\n          onChange={event =\u003e setMessage(event.target.value)}\n          id=\"message\"\n        /\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0\u003cbr /\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0\n        \u003cinput\n          multiple\n          type=\"file\"\n          onChange={e =\u003e {\n            let files = e.target.files\n            if (files \u0026\u0026 files.length) {\n              setImages(files)\n            }\n          }}\n        /\u003e\n        \\xA0 \\xA0 \\xA0 \\xA0{error ? (\n          \u003cdiv className={classes.error}\u003e{\\`\\${error}\\`}\u003c/div\u003e\n        ) : loading ? (\n          \\`Uploading...\\${completed}/\\${total}\\`\n        ) : completed ? (\n          \u003ch2\u003eUploaded \u003c/h2\u003e\n        ) : null}\\xA0 \\xA0 \\xA0 \\xA0\n        \u003cDialogActions\u003e\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\n          \u003cButton\n            style={{ textTransform: 'none' }}\n            onClick={async () =\u003e {\n              try {\n                if (images) {\n                  setLoading(true)\n                  setError(undefined)\n                  setCompleted(0)\n                  setTotal(images.length)\n                  await Promise.all(\n                    Array.from(images).map(async image =\u003e {\n                      const data = new FormData()\n                      data.append('message', message)\n                      data.append('user', user)\n                      data.append('date', new Date().toLocaleString())\n                      data.append('filename', image.name)\n                      data.append('contentType', image.type)\n                      const res = await myfetch(API_ENDPOINT + '/postFile', {\n                        method: 'POST',\n                        body: data,\n                      })\n\n                      await myfetch(res.uploadURL, {\n                        method: 'PUT',\n                        body: image,\n                      })\n\n                      setCompleted(completed =\u003e completed + 1)\n                    }),\n                  )\n                  setTimeout(() =\u003e {\n                    handleClose()\n                  }, 500)\n                }\n              } catch (e) {\n                setError(e)\n              }\n            }}\n            color=\"primary\"\n          \u003e\n            \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0upload \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\n          \u003c/Button\u003e\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\u003cButton\n            onClick={handleClose}\n            color=\"primary\"\n            style={{ textTransform: 'none' }}\n          \u003e\n            \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cancel \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\n          \u003c/Button\u003e\\xA0 \\xA0 \\xA0 \\xA0\n        \u003c/DialogActions\u003e\n        \\xA0 \\xA0 \\xA0\n      \u003c/DialogContent\u003e\\xA0 \\xA0\n    \u003c/Dialog\u003e\n  )\n}\n`)),mdx(\"p\",null,\"template.yaml for AWS\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),` AWSTemplateFormatVersion: 2010-09-09\n Transform: AWS::Serverless-2016-10-31\n Description: S3 Uploader\n\n Resources:\n \\xA0filesDynamoDBTable:\n \\xA0 \\xA0Type: AWS::DynamoDB::Table\n \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0AttributeDefinitions:\n \\xA0 \\xA0 \\xA0 \\xA0- AttributeName: \"timestamp\"\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0AttributeType: \"N\"\n \\xA0 \\xA0 \\xA0KeySchema:\n \\xA0 \\xA0 \\xA0 \\xA0- AttributeName: \"timestamp\"\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0KeyType: \"HASH\"\n \\xA0 \\xA0 \\xA0ProvisionedThroughput:\n \\xA0 \\xA0 \\xA0 \\xA0ReadCapacityUnits: \"5\"\n \\xA0 \\xA0 \\xA0 \\xA0WriteCapacityUnits: \"5\"\n \\xA0 \\xA0 \\xA0TableName: \"files\"\n\n \\xA0# HTTP API\n \\xA0MyApi:\n \\xA0 \\xA0Type: AWS::Serverless::HttpApi\n \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0# CORS configuration - this is open for development only and\n should be restricted in prod.\n \\xA0 \\xA0 \\xA0# See\n \u003chttps://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-httpapicorsconfiguration.html\u003e\n \\xA0 \\xA0 \\xA0CorsConfiguration:\n \\xA0 \\xA0 \\xA0 \\xA0AllowMethods:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- GET\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- POST\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- DELETE\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- OPTIONS\n \\xA0 \\xA0 \\xA0 \\xA0AllowHeaders:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- \"*\"\n \\xA0 \\xA0 \\xA0 \\xA0AllowOrigins:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- \"*\"\n\n \\xA0UploadRequestFunction:\n \\xA0 \\xA0Type: AWS::Serverless::Function\n \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0CodeUri: lambdas/postFile/\n \\xA0 \\xA0 \\xA0Handler: app.handler\n \\xA0 \\xA0 \\xA0Runtime: nodejs12.x\n \\xA0 \\xA0 \\xA0Timeout: 3\n \\xA0 \\xA0 \\xA0MemorySize: 128\n \\xA0 \\xA0 \\xA0Environment:\n \\xA0 \\xA0 \\xA0 \\xA0Variables:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0UploadBucket: !Ref S3UploadBucket\n \\xA0 \\xA0 \\xA0Policies:\n \\xA0 \\xA0 \\xA0 \\xA0- AmazonDynamoDBFullAccess\n \\xA0 \\xA0 \\xA0 \\xA0- S3WritePolicy:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0BucketName: !Ref S3UploadBucket\n \\xA0 \\xA0 \\xA0 \\xA0- Statement:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- Effect: Allow\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Resource: !Sub \"arn:aws:s3:::\\${S3UploadBucket}/\"\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Action:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- s3:putObjectAcl\n \\xA0 \\xA0 \\xA0Events:\n \\xA0 \\xA0 \\xA0 \\xA0UploadAssetAPI:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Type: HttpApi\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Path: /postFile\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Method: post\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ApiId: !Ref MyApi\n\n\n \\xA0FileReadFunction:\n \\xA0 \\xA0Type: AWS::Serverless::Function\n \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0CodeUri: lambdas/getFiles/\n \\xA0 \\xA0 \\xA0Handler: app.handler\n \\xA0 \\xA0 \\xA0Runtime: nodejs12.x\n \\xA0 \\xA0 \\xA0Timeout: 3\n \\xA0 \\xA0 \\xA0MemorySize: 128\n \\xA0 \\xA0 \\xA0Policies:\n \\xA0 \\xA0 \\xA0 \\xA0- AmazonDynamoDBFullAccess\n \\xA0 \\xA0 \\xA0Events:\n \\xA0 \\xA0 \\xA0 \\xA0UploadAssetAPI:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Type: HttpApi\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Path: /getFiles\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Method: get\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ApiId: !Ref MyApi\n\n \\xA0## S3 bucket\n \\xA0S3UploadBucket:\n \\xA0 \\xA0Type: AWS::S3::Bucket\n \\xA0 \\xA0Properties:\n \\xA0 \\xA0 \\xA0CorsConfiguration:\n \\xA0 \\xA0 \\xA0 \\xA0CorsRules:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- AllowedHeaders:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- \"*\"\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0AllowedMethods:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- GET\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- PUT\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- HEAD\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0AllowedOrigins:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- \"*\"\n\n\n ## Take a note of the outputs for deploying the workflow templates\n in this sample application\n Outputs:\n \\xA0APIendpoint:\n \\xA0 \\xA0Description: \"HTTP API endpoint URL\"\n \\xA0 \\xA0Value: !Sub\n \"https://\\${MyApi}.execute-api.\\${AWS::Region}.amazonaws.com\"\n \\xA0S3UploadBucketName:\n \\xA0 \\xA0Description: \"S3 bucket for application uploads\"\n \\xA0 \\xA0Value: !Ref \"S3UploadBucket\"\n\n`)),mdx(\"p\",null,`To display all the pictures I use a switch from video or img tag based\non contentType.startsWith('video'). I also use the\\xA0\"figcaption\" HTML tag\nto have a little caption on the pics/videos`),mdx(\"p\",null,\"./frontend/src/App.tsx\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),` function Media({\n \\xA0file,\n \\xA0style,\n \\xA0onClick,\n \\xA0children,\n }: {\n \\xA0file: File;\n \\xA0onClick?: Function;\n \\xA0style?: React.CSSProperties;\n \\xA0children?: React.ReactNode;\n }) {\n \\xA0const { filename, contentType } = file;\n \\xA0const src = \\`\\${BUCKET}/\\${filename}\\`;\n \\xA0return (\n \\xA0 \\xA0\u003cfigure style={{ display: \"inline-block\" }}\u003e\n \\xA0 \\xA0 \\xA0\u003cpicture\u003e\n \\xA0 \\xA0 \\xA0 \\xA0{contentType.startsWith(\"video\") ? (\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\u003cvideo style={style} src={src} controls onClick={onClick as\n any} /\u003e\n \\xA0 \\xA0 \\xA0 \\xA0) : (\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\u003cimg style={style} src={src} onClick={onClick as any} /\u003e\n \\xA0 \\xA0 \\xA0 \\xA0)}\n \\xA0 \\xA0 \\xA0\u003c/picture\u003e\n \\xA0 \\xA0 \\xA0\u003cfigcaption\u003e{children}\u003c/figcaption\u003e\n \\xA0 \\xA0\u003c/figure\u003e\n \\xA0);\n }\n`)),mdx(\"p\",null,`Now the really fun part: if you get an image of a picture frame\nlike\\xA0`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T\"}),\"https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T\")),mdx(\"p\",null,\"You can make it a border for any image or video using border-image CSS\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),` \\xA0 \\xA0 style = {\n \\xA0 \\xA0 \\xA0 \\xA0 border: \"30px solid\",\n \\xA0 \\xA0 \\xA0 \\xA0 borderImage: \\`url(borders/\\${border}) 30 round\\`\n \\xA0 \\xA0 }\n`)),mdx(\"p\",null,mdx(\"img\",a({parentName:\"p\"},{src:\"/media/638602799897329664_0.png\",alt:null}))),mdx(\"p\",null,\"Summary\"),mdx(\"p\",null,`The template.yaml automatically deploys the lambdas for postFile/getFile\nand the files table in dynamoDB`),mdx(\"p\",null,\"The React app uses postFile for each file in an \",mdx(\"inlineCode\",{parentName:\"p\"},'\u003cinput type=\"file\"/\u003e'),`,\nthe code uses React hooks and functional components but is hopefully not\ntoo complex`),mdx(\"p\",null,`I also added commenting on photos. The code is not shown here but you\ncan look in the source code for details`),mdx(\"p\",null,mdx(\"img\",a({parentName:\"p\"},{src:\"/media/638602799897329664_1.png\",alt:null}))),mdx(\"p\",null,`Overall this has been a good experience learning to develop this app and\nlearning to automate the cloud deployment is really good for ensuring\nreliability and fast iteration.`),mdx(\"p\",null,`Also quick note on serverless CLI vs aws-sam. I had tried a serverless\nCLI tutorial from another user but it didn't click with me, while the\naws-sam tutorial from\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1\"}),\"https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1\"),`\\xA0was\na great kick start for me. I am sure the serverless CLI is great too and\nit ensures a bit less vendor lock in, but then is also a little bit\nremoved from the native aws config schemas. Probably fine though`),mdx(\"p\",null,\"Source code\\xA0\",mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/cmdcolin/aws_photo_gallery/\"}),\"https://github.com/cmdcolin/aws_photo_gallery/\")))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2020-12-26"},"buildId":"0tjr6FsYvWOBkn9QJhA2V","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>