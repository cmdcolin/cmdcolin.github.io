<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="description" content="Astro description"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v6.0.0-beta.1"><title>How to make your own npm package with typescript</title><style>.container[data-astro-cid-4oxc2zqz]{max-width:800px;margin:0 auto;padding:0 1rem}article[data-astro-cid-lvjzyg5v]{max-width:100%}.post-content[data-astro-cid-lvjzyg5v]{margin:2rem 0;line-height:1.6}
</style>
<link rel="stylesheet" href="/_astro/Layout.Ca4IH_rv.css"></head> <body> <div class="mb-8"> <a href="/">Misc scribbles</a> </div>  <div class="container" data-astro-cid-4oxc2zqz>  <article data-astro-cid-lvjzyg5v> <div data-astro-cid-lvjzyg5v> <h1 data-astro-cid-lvjzyg5v>How to make your own npm package with typescript</h1> <h4 data-astro-cid-lvjzyg5v>2021-12-31</h4> </div> <div class="post-content" data-astro-cid-lvjzyg5v> <p>There is a lot of mystery around making your own <code>npm</code> package. Every package
likely does it a bit differently, and it can be tricky to get a setup you like.
Should you use a “starter kit” or a boilerplate example? Or just roll your own?
Should you use a bundler? How do you use typescript? Well, why don’t we try
starting from scratch and seeing where we can get?</p>
<p>TLDR: here is a github repo with a template package
<a href="https://github.com/cmdcolin/npm-package-tutorial/">https://github.com/cmdcolin/npm-package-tutorial/</a></p>
<h2 id="introduction">Introduction</h2>
<p>An <code>npm</code> package can be very bare bones. In some sense, npmjs.com is just an
arbitrary file host, and you can upload pretty much anything you want to it.</p>
<p>The magic is in the package.json file, which tells npm:</p>
<ul>
<li>what files are part of your package (by default, the whole folder with your
package.json is published, with the “files” field you can say what particular
folders or files are uploaded or you can use .npmignore to choose which files
NOT to publish)</li>
<li>what to use as the “entry point” (e.g. the file that should be referenced when
you say <code>const lib = require('mypackage')</code>, this is governed by the “main”
field, “module” field which is bundler specific, and “export maps” which are
newer but tricky)</li>
<li>what pre- and post- processing steps should be done when the package is being
published (the various “scripts”, where you can have “clean”, “build”, “test”,
“lint”, “prebuild”, etc)</li>
<li>and more!</li>
</ul>
<p>Let’s try an experiment…</p>
<h1 id="part-1-the-most-basic-package-with-plain-js-code-in-commonjs-format">Part 1: the most basic package with plain JS code in commonjs format</h1>
<p>Open up a terminal, and run</p>
<pre><code class="language-sh"><a-f>mkdir</a-f> mypackage
<a-f>cd</a-f> mypackage
<a-f>git</a-f> init <a-c># make mypackage version controlled</a-c>
<a-f>npm</a-f> init <a-c># or yarn init</a-c>
</code></pre>
<p>This init command outputs something like this, and we accept the defaults</p>
<pre><code class="language-sh"><a-f>This</a-f> utility will walk you through creating a package.json file.
<a-f>It</a-f> only covers the most common items, and tries to guess sensible defaults.

<a-f>See</a-f> <a-eb>`</a-eb><a-f>npm</a-f><a-eb> help init`</a-eb> for definitive documentation on these fields
<a-f>and</a-f> exactly what they do.

<a-f>Use</a-f> `<a-f>npm</a-f> install <a-o>&#x3C;</a-o>pkg<a-o>></a-o>` <a-f>afterwards</a-f> to install a package and
<a-f>save</a-f> it as a dependency in the package.json file.

<a-f>Press</a-f> ^C at any time to quit.
<a-f>package</a-f> name: (<a-f>mypackage</a-f>)
<a-f>version:</a-f> (<a-f>1.0.0</a-f>)
<a-f>description:</a-f>
<a-f>entry</a-f> point: (<a-f>index.js</a-f>)
<a-f>test</a-f> command:
<a-f>git</a-f> repository:
<a-f>keywords:</a-f>
<a-f>license:</a-f> (<a-f>ISC</a-f>)
<a-f>About</a-f> to write to /home/cdiesh/mypackage/package.json:

{
  <a-s>"name"</a-s><a-f>:</a-f> <a-s>"mypackage"</a-s>,
  <a-s>"version"</a-s><a-f>:</a-f> <a-s>"1.0.0"</a-s>,
  <a-s>"description"</a-s><a-f>:</a-f> <a-s>""</a-s>,
  <a-s>"main"</a-s><a-f>:</a-f> <a-s>"index.js"</a-s>,
  <a-s>"scripts"</a-s><a-f>:</a-f> {
    <a-s>"test"</a-s><a-f>:</a-f> <a-s>"echo \"Error: no test specified\" &#x26;&#x26; exit 1"</a-s>
  },
  <a-s>"author"</a-s><a-f>:</a-f> <a-s>"Colin"</a-s>,
  <a-s>"license"</a-s><a-f>:</a-f> <a-s>"ISC"</a-s>
<a-f>}</a-f>
</code></pre>
<p>Then, you can create a file named <code>index.js</code> (in your package.json it says
<code>"main": "index.js"</code> to refer to this file, the entrypoint)</p>
<p>In your <code>index.js</code> file, generally, you would do things like export a function
or functions. I will use commonjs exports here for maximum compatibility:</p>
<pre><code class="language-js"><a-v>module</a-v><a-p>.</a-p><a-pr>exports</a-pr> <a-o>=</a-o> <a-p>{</a-p>
  <a-f>hello</a-f>: <a-p>()</a-p> <a-o>=></a-o> <a-p>{</a-p>
    <a-v>console</a-v><a-p>.</a-p><a-f>log</a-f><a-p>(</a-p><a-s>'hello world'</a-s><a-p>)</a-p>
  <a-p>},</a-p>
<a-p>}</a-p>
</code></pre>
<h2 id="publishing-a-package">Publishing a package</h2>
<p>This npm package, <code>mypackage</code> can now be published to <code>npm</code> with a simple
command.</p>
<pre><code class="language-sh"><a-f>npm</a-f> publish
<a-c># or</a-c>
<a-f>yarn</a-f> publish
</code></pre>
<p>This will prompt you for your npmjs.com username, password, email, and if
needed, 2FA token (highly recommended)</p>
<h2 id="using-your-package-after-it-is-published">Using your package after it is published</h2>
<p>Once it is published, you can use it in your create-react-app app or other npm
package.</p>
<pre><code class="language-sh"><a-f>npm</a-f> install mypackage
<a-c># or</a-c>
<a-f>yarn</a-f> add mypackage
</code></pre>
<p>Then you can use</p>
<pre><code class="language-js"><a-k>import</a-k> <a-p>{</a-p> <a-v>hello</a-v> <a-p>}</a-p> <a-k>from</a-k> <a-s>'mypackage'</a-s>
</code></pre>
<p>in any of your other codebases</p>
<h2 id="summary-of-the-simplest-npm-package">Summary of the simplest NPM package</h2>
<p>This all seems pretty boring thus far but it tells us a couple things</p>
<ol>
<li>packages can be very very bare bones</li>
<li>no transpiler or bundler is needed for publishing an npm package</li>
<li>our package can consist of a single file and it is uploaded to npm, and the
“main” field in package.json provides an entry point</li>
<li>the filename index.js is not special, probably it is a hangover from the name
index.html. you can use whatever name you want</li>
</ol>
<h1 id="part-2-adding-typescript">Part 2: Adding typescript</h1>
<p>Let’s try adding typescript</p>
<p>To do this, we will use the typescript compiler to compile a directory of files
in our “src” directory and output the compiled files to a directory named “dist”</p>
<p>To start, let’s add typescript</p>
<pre><code class="language-sh"><a-f>npm</a-f> install <a-co>--save-dev</a-co> typescript
<a-c># or</a-c>
<a-f>yarn</a-f> add <a-co>-D</a-co> typescript
</code></pre>
<p>Our package.json now will have <code>typescript</code> in it’s <code>devDependencies</code> (this
means that when someone installs your package, it they don’t get typescript as a
dependency, it is just a dependency for while you are developing the library
locally).</p>
<p>Then we need to create a tsconfig.json for typescript to use</p>
<pre><code class="language-sh"><a-f>yarn</a-f> tsc <a-co>--init</a-co>
<a-c># or</a-c>
<a-f>npx</a-f> tsc <a-co>--init</a-co>
</code></pre>
<p>This will generate a <code>tsconfig.json</code> file (needed by <code>typescript</code>) with a bunch
of options, but I have stripped it down in my projects to look like this</p>
<pre><code class="language-json">{
  <a-s>"include"</a-s>: [<a-s>"src"</a-s>],
  <a-s>"compilerOptions"</a-s>: {
    <a-s>"target"</a-s>: <a-s>"es2018"</a-s>,
    <a-s>"moduleResolution"</a-s>: <a-s>"node"</a-s>, <a-c>// don't have to import actual filenames, can import extensionless files</a-c>
    <a-s>"declaration"</a-s>: <a-co>true</a-co>, <a-c>// generate .d.ts files</a-c>
    <a-s>"sourceMap"</a-s>: <a-co>true</a-co>, <a-c>// generate source map</a-c>
    <a-s>"outDir"</a-s>: <a-s>"dist"</a-s>, <a-c>// output compiled js, d.ts, and source map to dist folder</a-c>
    <a-s>"strict"</a-s>: <a-co>true</a-co>,
    <a-s>"esModuleInterop"</a-s>: <a-co>true</a-co>
  }
}
</code></pre>
<p>Now, let’s wrote a little typescript. We can now use “ESM” style code, we will
compile it to commonjs format.</p>
<p>util.ts</p>
<pre><code class="language-typescript"><a-k>export</a-k> <a-k>function</a-k> <a-f>getMessage</a-f><a-p>()</a-p> <a-p>{</a-p>
  <a-k>return</a-k> <a-s>'hello'</a-s>
<a-p>}</a-p>
</code></pre>
<p>index.ts</p>
<pre><code class="language-typescript"><a-k>import</a-k> <a-p>{</a-p> <a-v>getMessage</a-v> <a-p>}</a-p> <a-k>from</a-k> <a-s>'./util'</a-s>
<a-k>export</a-k> <a-k>function</a-k> <a-f>sayMessage</a-f><a-p>()</a-p> <a-p>{</a-p>
  <a-v>console</a-v><a-p>.</a-p><a-f>log</a-f><a-p>(</a-p><a-f>getMessage</a-f><a-p>())</a-p>
<a-p>}</a-p>
</code></pre>
<p>And then we will add a <code>"build"</code> script to <code>package.json</code> to compile the
library, and refer to the <code>"dist"</code> directory for the <code>"files"</code> and <code>"main"</code>
fields in <code>package.json</code></p>
<pre><code class="language-json">{
  <a-s>"name"</a-s>: <a-s>"mypackage"</a-s>,
  <a-s>"version"</a-s>: <a-s>"1.0.0"</a-s>,
  <a-s>"description"</a-s>: <a-s>""</a-s>,
  <a-s>"main"</a-s>: <a-s>"src/index.js"</a-s>,
  <a-s>"files"</a-s>: [<a-s>"dist"</a-s>, <a-s>"src"</a-s>], <a-c>// we publish both dist and src to get proper sourceMaps</a-c>
  <a-s>"scripts"</a-s>: {
    <a-s>"build"</a-s>: <a-s>"tsc --module commonjs"</a-s>
  },
  <a-s>"author"</a-s>: <a-s>"Colin"</a-s>,
  <a-s>"license"</a-s>: <a-s>"ISC"</a-s>,
  <a-s>"devDependencies"</a-s>: {
    <a-s>"typescript"</a-s>: <a-s>"^4.5.4"</a-s>
  }
}
</code></pre>
<p>We can now run</p>
<pre><code class="language-sh"><a-f>npm</a-f> run build
<a-c># or</a-c>
<a-f>yarn</a-f> build
</code></pre>
<p>And this will run the <code>"build"</code> script we created, which in turn, just runs
<code>tsc</code> with no arguments.</p>
<p>You can also add a <code>"prebuild"</code> script that clears out the old contents. In
fact, npm scripts generalizes the naming system — you can make scripts with
whatever name you want, e.g.</p>
<pre><code class="language-json">{
  <a-s>"scripts"</a-s>: {
    <a-s>"preparty"</a-s>: <a-s>"echo preparty"</a-s>,
    <a-s>"party"</a-s>: <a-s>"echo party"</a-s>,
    <a-s>"postparty"</a-s>: <a-s>"echo postparty"</a-s>
  }
}
</code></pre>
<p>Then running</p>
<pre><code class="language-sh"><a-o>$</a-o><a-f> </a-f><a-pr>yarn</a-pr> party
<a-f>preparty</a-f>
<a-f>party</a-f>
<a-f>postparty</a-f>
</code></pre>
<p>To make this useful, we will use <code>rimraf</code> (a node package) to make a
cross-platform removal of the <code>dist</code> directory</p>
<pre><code class="language-sh"><a-f>npm</a-f> install <a-co>--save-dev</a-co> rimraf
<a-c># or</a-c>
<a-f>yarn</a-f> add <a-co>-D</a-co> rimraf
</code></pre>
<p>and then update your package.json</p>
<pre><code class="language-json">{
  ...
  <a-s>"scripts"</a-s>: {
    <a-s>"clean"</a-s>: <a-s>"rimraf dist"</a-s>,
    <a-s>"prebuild"</a-s>: <a-s>"npm run clean"</a-s>,
    <a-s>"build"</a-s>: <a-s>"tsc --module commonjs"</a-s>
  },
  <a-s>"devDependencies"</a-s>: {
    <a-s>"rimraf"</a-s>: <a-s>"^3.0.2"</a-s>,
    <a-s>"typescript"</a-s>: <a-s>"^4.5.4"</a-s>
  }
}
</code></pre>
<p>We could make it say “rm -rf dist” instead of “rimraf dist” (e.g. run arbitrary
shell commands), but rimraf allows it to be cross-platform</p>
<h2 id="making-sure-you-create-a-fresh-build-before-you-publish">Making sure you create a fresh build before you publish</h2>
<p>Without extra instructions, your <code>yarn publish</code> command would not create a fresh
build and you could publish an older version that was lingering in the <code>dist</code>
folder.</p>
<p>We can use a <code>preversion</code> script that will automatically get invoked when you
run <code>yarn publish</code> to make sure you get a fresh build in the <code>dist</code> folder
before you publish</p>
<pre><code class="language-json">{
  ...
  <a-s>"scripts"</a-s>: {
    ...
    <a-s>"preversion"</a-s>: <a-s>"npm run build"</a-s>,
  },
}
</code></pre>
<h2 id="making-sure-you-push-your-tag-to-github-after-publish">Making sure you push your tag to github after publish</h2>
<p>When you run <code>yarn publish</code>, npm will automatically create a commit with the
version name and a git tag, it <em>will not</em> automatically push tag to your
repository.</p>
<p>Add a <code>postversion</code> script that pushes the tag to your repo after your publish</p>
<pre><code class="language-json">{
  ...
  <a-s>"scripts"</a-s>: {
    ...
    <a-s>"postversion"</a-s>: <a-s>"git push --follow-tags"</a-s>,
  },
}
</code></pre>
<h2 id="incremental-builds">Incremental builds</h2>
<p>We can use this to do incremental/watch builds</p>
<pre><code class="language-sh"><a-f>npm</a-f> run build <a-co>--watch</a-co>
<a-c># or</a-c>
<a-f>yarn</a-f> build <a-co>--watch</a-co>
</code></pre>
<h2 id="adding-testing-with-ts-jest">Adding testing with ts-jest</h2>
<p>You can use ts-jest to test your code. This involves installing jest,
typescript, ts-jest, @types/jest, and then initializing a jest.config.json</p>
<pre><code class="language-sh"><a-f>npm</a-f> i <a-co>-D</a-co> jest typescript
<a-c># or</a-c>
<a-f>yarn</a-f> add <a-co>--dev</a-co> jest typescript
</code></pre>
<pre><code class="language-sh"><a-f>npm</a-f> i <a-co>-D</a-co> ts-jest @types/jest
<a-c># or</a-c>
<a-f>yarn</a-f> add <a-co>--dev</a-co> ts-jest @types/jest
</code></pre>
<pre><code class="language-sh"><a-f>npx</a-f> ts-jest config:init
<a-c># or</a-c>
<a-f>yarn</a-f> ts-jest config:init
</code></pre>
<p>We can then create a test</p>
<p><code>test/util.spec.ts</code></p>
<pre><code class="language-typescript"><a-k>import</a-k> <a-p>{</a-p> <a-v>getMessage</a-v> <a-p>}</a-p> <a-k>from</a-k> <a-s>'../src/util'</a-s>
<a-f>test</a-f><a-p>(</a-p><a-s>'expected message returned'</a-s><a-p>,</a-p> <a-p>()</a-p> <a-o>=></a-o> <a-p>{</a-p>
  <a-f>expect</a-f><a-p>(</a-p><a-f>getMessage</a-f><a-p>()).</a-p><a-f>toBe</a-f><a-p>(</a-p><a-s>'hello'</a-s><a-p>)</a-p>
<a-p>})</a-p>
</code></pre>
<p>Then we can then create a script in the package.json that says <code>"test": "jest"</code>,
and then we can say</p>
<pre><code class="language-sh"><a-f>npm</a-f> run test
<a-c># or</a-c>
<a-f>yarn</a-f> test
</code></pre>
<p>You can also create an alternative system where you use <code>babel-eslint</code> and
various babel strategies to test your code, but if you are using <code>typescript</code>,
<code>ts-jest</code> and <code>typescript</code> works great.</p>
<h2 id="add-a-gitignore">Add a .gitignore</h2>
<p>Create a .gitignore with just a line that references this <code>dist</code> folder and
<code>node_modules</code> folder</p>
<pre><code>dist
node_modules
</code></pre>
<h2 id="the-future-of-esm-modules">The future of ESM modules</h2>
<p>There is a shift happening where modules are changing to be pure ESM rather than
keeping commonjs equivalents</p>
<p><a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></p>
<p>There are many challenges here, but one shortcut that I have used is to actually
go “halfway to ESM” and just publish a “dual” package: one “main” field in the
package.json referring to a commonjs file, and one “module” field with an ESM
style build for bundlers. I do it like this:</p>
<pre><code class="language-json">{
  <a-s>"files"</a-s>: [<a-s>"dist"</a-s>, <a-s>"esm"</a-s>, <a-s>"src"</a-s>],
  <a-s>"scripts"</a-s>: {
     ...
    <a-s>"clean"</a-s>: <a-s>"rimraf dist esm"</a-s>,
    <a-s>"prebuild"</a-s>: <a-s>"npm run clean"</a-s>,
    <a-s>"build:cjs"</a-s>: <a-s>"tsc --module commonjs --ourDir dist"</a-s>,
    <a-s>"build:esm"</a-s>: <a-s>"tsc --target es2018 --outDir esm"</a-s>,
    <a-s>"build"</a-s>: <a-s>"npm run build:esm &#x26;&#x26; npm run build:cjs"</a-s>
  },
  <a-s>"main"</a-s>: <a-s>"dist/index.js"</a-s>,
  <a-s>"module"</a-s>: <a-s>"esm/index.js"</a-s>
}
</code></pre>
<p>The “module” field is understood by bundlers like webpack and you can do
slightly less polyfilling/babeling on it (hence the different <code>--target</code>
attributes)</p>
<p>This is not “pure ESM” with the “type”:“module” in package.json, but it does
help to have less “babelification” (which in our case is done by tsc) of your
source code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This tutorial shows you how you can create a basic package that you can publish
to <code>npm</code>. This little boilerplate includes these features:</p>
<ul>
<li>Makes clean build when running <code>yarn build</code> or <code>yarn publish</code></li>
<li>Pushes to github after publish</li>
<li>Uses <code>ts-jest</code> for testing</li>
<li>Uses esm modules</li>
</ul>
<p>You also have full control, and understand the decisions we took to get to this
point. This package does not use any bundling (rollup or webpack or otherwise).
It just uses <code>tsc</code> is used to compile the files to the <code>dist</code> folder, and the
dist folder is published to <code>npm</code>!</p>
<p>If you need your package to be usable by consumers that don’t themselves use
bundlers, consider looking into <code>&#x3C;script type="module"></code> for importing ESM
modules in the browser, or you can bundle your library using rollup or webpack
and output e.g. a UMD bundle</p>
<h2 id="final-product">Final product</h2>
<p>See <a href="https://github.com/cmdcolin/npm-package-tutorial/">https://github.com/cmdcolin/npm-package-tutorial/</a></p>
<p>This is a setup that works for me, but there are many ways to publish a package
so take it with a grain of salt!</p>
<p>Also see my follow up rant: you may not need a bundler
<a href="https://cmdcolin.github.io/posts/2022-05-27-youmaynotneedabundler">https://cmdcolin.github.io/posts/2022-05-27-youmaynotneedabundler</a></p>
<h2 id="footnote-1---what-about-monorepos">Footnote 1 - what about monorepos?</h2>
<p>There are many high powered “monorepo” setups like lerna, nx, turborepo, etc.</p>
<p>I think for many purposes, these can be a bit overkill. I would start with yarn
workspaces. Basically, the way this works is you can have e.g. in your root
package.json in your repo something likely</p>
<pre><code class="language-json">{
  <a-s>"name"</a-s>: <a-s>"root"</a-s>,
  <a-s>"private"</a-s>: <a-co>true</a-co>,
  <a-s>"workspaces"</a-s>: [<a-s>"lib"</a-s>, <a-s>"app"</a-s>]
}
</code></pre>
<p>And then in your <code>lib</code> directory you can have your library as we created above
and <code>app</code> for example can be an instance of a <code>vite</code> app that uses your library.
You can reference your lib by name in the <code>app</code> folders package.json, and it
will automatically get the latest version of it that you have built from the
<code>lib</code> directory e.g. your <code>app</code> will look at the libs “dist” folder: it’s
compiled outputs. That means you can run <code>yarn tsc --watch</code> in the lib folder to
continuously build it, and then e.g. when you are running e.g. <code>yarn dev</code> in the
<code>app</code> directory, it will see updates to the <code>lib</code> dist directory and auto-update
via hot module refresh</p>
<p>High powered solutions like nx, turborepo, etc may have solutions for
‘automatically building all the stuff’ without you explicitly having to run the
build in the <code>lib</code> directory, but for simple monorepo setups, this works ok</p>
<h2 id="footnote-2---2025-update">Footnote 2 - 2025 update</h2>
<p>See <a href="https://cmdcolin.github.io/posts/2025-01-12-pureesm">https://cmdcolin.github.io/posts/2025-01-12-pureesm</a></p> </div> <div id="giscus"></div> <script>
  const script = document.createElement('script');
  script.src = 'https://giscus.app/client.js';
  script.setAttribute('data-repo', 'cmdcolin/cmdcolin.github.io');
  script.setAttribute('data-repo-id', 'MDEwOlJlcG9zaXRvcnkyNjE0OTY3Nw==');
  script.setAttribute('data-category', 'General');
  script.setAttribute('data-category-id', 'DIC_kwDOAY8DLc4CO-L9');
  script.setAttribute('data-mapping', 'pathname');
  script.setAttribute('data-strict', '0');
  script.setAttribute('data-reactions-enabled', '1');
  script.setAttribute('data-emit-metadata', '0');
  script.setAttribute('data-input-position', 'bottom');
  script.setAttribute('data-theme', 'light');
  script.setAttribute('data-lang', 'en');
  script.setAttribute('crossorigin', 'anonymous');
  script.async = true;
  document.getElementById('giscus').appendChild(script);
</script> </article>  </div>   <footer class="footer-style" data-astro-cid-k2f5zb5c> <a class="footer-link" href="/" data-astro-cid-k2f5zb5c>Home</a> <a class="footer-link" href="/archive" data-astro-cid-k2f5zb5c>Blog archive</a> <a class="footer-link" href="https://github.com/cmdcolin/" data-astro-cid-k2f5zb5c>Github</a> <a class="footer-link" href="/projects" data-astro-cid-k2f5zb5c>Projects</a> <a class="footer-link" href="/about" data-astro-cid-k2f5zb5c>About</a> </footer> </body></html> 