<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="description" content="Astro description"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v5.16.8"><title>You may not need a bundler for your NPM library</title><style>.container[data-astro-cid-4oxc2zqz]{max-width:800px;margin:0 auto;padding:0 1rem}article[data-astro-cid-lvjzyg5v]{max-width:100%}.post-content[data-astro-cid-lvjzyg5v]{margin:2rem 0;line-height:1.6}
.footer-style[data-astro-cid-k2f5zb5c]{margin-top:4rem}.footer-link[data-astro-cid-k2f5zb5c]{margin:.5rem}body{font-family:Helvetica,Arial,sans-serif;background-color:Canvas;color:CanvasText;color-scheme:light dark;overflow-wrap:break-word}img{max-width:100%}pre{max-width:100%;overflow:auto}li+li{margin-top:10px}pre{padding:10px;border-radius:5px}
</style></head> <body> <div class="mb-8"> <a href="/">Misc scribbles</a> </div>  <div class="container" data-astro-cid-4oxc2zqz>  <article data-astro-cid-lvjzyg5v> <div data-astro-cid-lvjzyg5v> <h1 data-astro-cid-lvjzyg5v>You may not need a bundler for your NPM library</h1> <h4 data-astro-cid-lvjzyg5v>2022-05-27</h4> </div> <div class="post-content" data-astro-cid-lvjzyg5v> <p>I have seen a couple threads on twitter where people complain about the
difficulty with publishing NPM libraries or ask what starter kit they should use
(or, people recommended starter packs anyways)</p>
<p>Example threads</p>
<ul>
<li><a href="https://twitter.com/cramforce/status/1513903035197526017">https://twitter.com/cramforce/status/1513903035197526017</a></li>
<li><a href="https://twitter.com/oleg008/status/1510006191296061441">https://twitter.com/oleg008/status/1510006191296061441</a></li>
<li><a href="https://twitter.com/iansu/status/1524860613943382017">https://twitter.com/iansu/status/1524860613943382017</a></li>
<li><a href="https://twitter.com/mpocock1/status/1525075901905522691">https://twitter.com/mpocock1/status/1525075901905522691</a></li>
</ul>
<p>One thing that is notable to me in these threads is that people often recommend
that you use a bundler (a program that combines multiple src files into a single
or fewer output files) when developing a library</p>
<p>Examples of starter packs suggested in these threads that use bundlers</p>
<ul>
<li><code>microbundle</code> - <a href="https://github.com/developit/microbundle">https://github.com/developit/microbundle</a> - uses rollup</li>
<li><code>esno</code> - <a href="https://www.npmjs.com/package/esno">https://www.npmjs.com/package/esno</a> - uses esbuild</li>
<li><code>unbuild</code> - <a href="https://github.com/unjs/unbuild">https://github.com/unjs/unbuild</a> - uses rollup</li>
<li><code>preconstruct</code> - <a href="https://github.com/preconstruct/preconstruct">https://github.com/preconstruct/preconstruct</a> - uses rollup</li>
<li><code>tsup</code> - <a href="https://github.com/egoist/tsup">https://github.com/egoist/tsup</a> - uses esbuild</li>
<li><code>tsdx</code> - <a href="https://github.com/jaredpalmer/tsdx">https://github.com/jaredpalmer/tsdx</a> - uses rollup</li>
<li><code>vite library mode</code> - <a href="https://vitejs.dev/guide/build.html#library-mode">https://vitejs.dev/guide/build.html#library-mode</a> - uses
rollup</li>
<li><code>packemon</code> - <a href="https://github.com/milesj/packemon">https://github.com/milesj/packemon</a> - uses rollup</li>
<li><code>ts-library-template</code> - <a href="https://github.com/shortercode/ts-library-template">https://github.com/shortercode/ts-library-template</a> -
uses rollup</li>
<li><code>parcel</code> - <a href="https://twitter.com/devongovett/status/1524944991402999810">https://twitter.com/devongovett/status/1524944991402999810</a> - uses
parcel</li>
<li><code>dts</code> - <a href="https://weiran-zsd.github.io/dts-cli/">https://weiran-zsd.github.io/dts-cli/</a> - uses rollup</li>
<li><code>pkgroll</code> - <a href="https://github.com/privatenumber/pkgroll">https://github.com/privatenumber/pkgroll</a> - uses rollup</li>
<li><code>mkdist</code> - <a href="https://github.com/unjs/mkdist">https://github.com/unjs/mkdist</a> - referenced by <code>unbuild</code>, uses
esbuild</li>
</ul>
<p>Not using bundlers</p>
<ul>
<li><code>gts</code> - <a href="https://github.com/google/gts">https://github.com/google/gts</a></li>
<li><code>ts-react-toolbox</code> - <a href="https://github.com/zzarcon/ts-react-toolbox/">https://github.com/zzarcon/ts-react-toolbox/</a></li>
</ul>
<p>In summary 2/15 do not use a bundler, 13/15 do use a bundler. Sidenote: webpack
notably absent. Sidenote 2: I don’t necessarily give praise to the two not using
bundlers, just saying they exist.</p>
<h2 id="why-would-you-not-want-a-bundler-for-your-library">Why would you <em>NOT</em> want a bundler for your library?</h2>
<p>My main argument is that the consumer of your library is the one that should use
a bundler if it is relevant to them. If the library uses a bundler:</p>
<ul>
<li>in the best case, it has no impact on the consumer</li>
<li>in the worst case, it affects the complexity of your library and makes
possible limitations for your consumers also.</li>
</ul>
<p>An example where it can actually create limitations, you might consider code
splitting with async <code>import()</code>. If you create a single file bundle, then the
consumer of your library may not be able to do code splitting properly via async
<code>import()</code></p>
<p>Another example is the now common usage of ‘use client’ in source code. A
library targeted bundler (e.g. rollup) can’t reasonably bundle this properly and
prints error messages (see <a href="https://github.com/rollup/rollup/issues/4699">https://github.com/rollup/rollup/issues/4699</a>)</p>
<h2 id="why-would-you-maybe-want-a-bundler-for-your-library">Why would you <em>MAYBE</em> want a bundler for your library</h2>
<p>If you really care about producing a <code>UMD</code> bundle that can be used in a script
tag, maybe you want a bundler, but the future does not seem to be in <code>UMD</code>. One
other possible bundle type is maybe you like the idea of a single file <code>ESM</code>
module. It is similar where you could maybe reference this from a script tag
with type module, but this seems like a niche usage. For example, you would
still have to consider:</p>
<ul>
<li>If you are not bundling dependencies, then what is the benefit of using a
bundler?</li>
<li>If you are bundling dependencies, you are not allowing people to get updates
to your sub-dependencies with semver!</li>
</ul>
<p>Add-on: Another concern brought up by users in discussion thread: There is a
cost to having many small files, e.g. in app startup cost on serverless or any
nodejs application to loading many small files off disk. To me, this is an app
level concern, similar to bundling for the browser though.</p>
<h2 id="my-suggestion-no-bundler-no-starter-pack-just-tsc">My suggestion: no bundler, no starter pack, just <code>tsc</code></h2>
<p>I’d recommend just compiling your code with <code>tsc</code>, no bundler involved. This
way, you can develop with typescript, it will output <code>js</code> files, and you can
directly deploy a <code>dist</code> folder of <code>js</code> files to NPM.</p>
<h3 id="example-packagejson">Example <code>package.json</code></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="json"><code><span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#79B8FF">  "name"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"yourlib"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "version"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"1.0.0"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "main"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"dist/index.js"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "scripts"</span><span style="color:#E1E4E8">: {</span></span>
<span class="line"><span style="color:#79B8FF">    "clean"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"rimraf dist"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "prebuild"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"npm run clean"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "build"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"tsc"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "preversion"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"npm run build"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "postversion"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"git push --follow-tags"</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#79B8FF">  "files"</span><span style="color:#E1E4E8">: [</span><span style="color:#9ECBFF">"dist"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"src"</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#79B8FF">  "devDependencies"</span><span style="color:#E1E4E8">: {</span></span>
<span class="line"><span style="color:#79B8FF">    "rimraf"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"^3.0.2"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "typescript"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"^4.6.2"</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h4 id="features-of-the-above-packagejson">Features of the above <code>package.json</code></h4>
<ul>
<li>We can use a single command, <code>yarn publish</code> to publish to npm</li>
<li>The single <code>yarn publish</code> automatically runs <code>clean</code> and <code>build</code> via
<code>preversion</code>, then <code>postversion</code>, which pushes the tag to the remote repo</li>
<li>The <code>"files": ["dist", "src"]</code> refers to publishing the <code>dist</code> and <code>src</code>
directories, and src is used for the <code>sourceMap</code></li>
</ul>
<h3 id="example-tsconfigjson">Example<code> tsconfig.json</code></h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="json"><code><span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#79B8FF">  "include"</span><span style="color:#E1E4E8">: [</span><span style="color:#9ECBFF">"src"</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#79B8FF">  "compilerOptions"</span><span style="color:#E1E4E8">: {</span></span>
<span class="line"><span style="color:#79B8FF">    "target"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"es2018"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "outDir"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"dist"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "lib"</span><span style="color:#E1E4E8">: [</span><span style="color:#9ECBFF">"dom"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"esnext"</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#79B8FF">    "declaration"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "moduleResolution"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"node"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "sourceMap"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "strict"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">    "esModuleInterop"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">true</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h4 id="features-of-the-above-tsconfigjson">Features of the above <code>tsconfig.json</code></h4>
<ul>
<li>Uses <code>"moduleResolution": "node"</code> - this is not pure-ESM because pure-ESM
expects you to import filenames with their file extension, while node module
resolution can import extensionless paths, but node module resolution
generally works well with consumers that use bundlers themselves</li>
<li>Uses <code>"target": "es2018"</code> - This is does a small amount of transpilation of
super modern features, but would generally not require your users to babel-ify
their <code>node_modules</code> if they consume your library</li>
</ul>
<h2 id="what-about-testing">What about testing?</h2>
<p>Adding testing is not immediately solved by the above, but bundling doesn’t
really help testing anyways. It’s just a starter pack feature we can add on.
Some options you have include</p>
<ul>
<li>Use <code>ts-jest</code></li>
<li>Use <code>jest</code> on it’s own, plus a <code>babel</code> config with <code>@babel/preset-typescript</code></li>
<li>Use <code>jest</code> on it’s own, run over the compiled output without a <code>babel</code> config</li>
<li>Use <code>vitest</code> (edit 2024: this is probably the most popular way to do things
now)</li>
<li>Possibly something else? Node now has a built-in test runner. It will be a
slow road to adoption but might become more popular over time
<a href="https://fusebit.io/blog/node-testing-comes-to-core/">https://fusebit.io/blog/node-testing-comes-to-core/</a></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>It is tempting to have nice zero-config solutions and starter kits, but to me,
it is not really beneficial to use the bundler aspect of many of these for
publishing to NPM. Am I wrong? Let me know if I am.</p>
<p>Also, these starter kits may not be maintained for perpetuity. Our team used
<code>tsdx</code> for some time, but it was not maintained well, and used old typescript
version 3.x, and it ended up being hard to remove from our codebase. Learning
the basic tools like <code>tsc</code> will help</p>
<h2 id="footnote-1-shipping-pure-esm">Footnote 1: Shipping “pure-ESM”</h2>
<p>Do you want to make a pure-ESM package? Then you do not want to use
<code>"moduleResolution": "node"</code> in <code>tsconfig.json</code>, and you will want to set
<code>"type": "module"</code> in <code>package.json</code>.</p>
<p>You may also need to explicitly import with <code>.js</code> extensions in your source
code, even if you write <code>.ts</code>.</p>
<p>This is awkward, and something the community is still grappling with. This is
ACTUALLY one of the areas that a bundler can help, because by bundling, you
don’t ever encounter any actual imported files in the published artifacts.</p>
<p>You will also probably use the “exports” field in package.json.</p>
<p>If you have ever stumbled on this topic, you will probably want to see this link
<a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></p>
<h2 id="footnote-2-shipping-esm-and-commonjs-side-by-side-without-going-pure-esm">Footnote 2: Shipping ESM and CommonJS side by side without going “pure-ESM”</h2>
<p>It can be tricky to go pure-ESM, but you can go most of the way there by using
both the “main” and “module” fields in package.json</p>
<ul>
<li>Compile with tsc with <code>tsc --module commonjs --outDir dist</code></li>
<li>Compile with tsc again with <code>tsc --module esnext --outDir esm</code></li>
<li>Then set “main”:“dist/index.js” for node and <code>"module":"esm/index.js"</code> for
bundlers</li>
</ul>
<p>The “module” field is a field only bundlers recognizes
<a href="https://stackoverflow.com/questions/42708484/what-is-the-module-package-json-field-for">https://stackoverflow.com/questions/42708484/what-is-the-module-package-json-field-for</a></p>
<p>Note: This is different from the “type”:“module” which marks your module as
pure-ESM!</p>
<p>I have found this technique can go a long ways towards keeping your package
compatible with nodeJS and bundlers and it does not require “export maps” or
anything which I have found to be difficult to configure</p>
<h2 id="footnote-3-what-does-it-look-like-when-you-compile-with-tsc">Footnote 3: What does it look like when you compile with tsc?</h2>
<p>When I refer to compiling with tsc above, I compile a <code>src</code> directory into a
<code>dist</code> directory</p>
<p>So if I have:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>src/index.ts</span></span>
<span class="line"><span>src/util.ts</span></span>
<span class="line"><span>src/components/Button.ts</span></span></code></pre>
<p>Running <code>tsc</code> will output:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>dist/index.js</span></span>
<span class="line"><span>dist/index.d.ts</span></span>
<span class="line"><span>dist/index.js.map</span></span>
<span class="line"><span>dist/util.js</span></span>
<span class="line"><span>dist/util.d.ts</span></span>
<span class="line"><span>dist/util.js.map</span></span>
<span class="line"><span>dist/components/Button.js</span></span>
<span class="line"><span>dist/components/Button.d.ts</span></span>
<span class="line"><span>dist/components/Button.js.map</span></span></code></pre>
<p>Then, the <code>dist</code> and <code>src</code> directories are published to npm which enables the
<code>sourceMaps</code> to work.</p>
<p>Note: We do not need to explicitly say where the typescript types are with
“types” in <code>package.json</code>, many starter packs do this but it is unneeded for
this package as the d.ts files are automatically found.</p>
<p>See <a href="https://cmdcolin.github.io/posts/2021-12-31-npm-package">https://cmdcolin.github.io/posts/2021-12-31-npm-package</a> for my article on
creating a typescript package for npm</p>
<h2 id="footnote-4-publishing-the-raw-js-with-jsdoc-checked-types">Footnote 4: Publishing the raw JS with JSDoc checked types</h2>
<p>You may not even need <code>tsc</code> to compile your dist folder. You can literally
publish your source <code>.js</code> files as-is to NPM. This suggestion comes from
@trevmanz <a href="https://twitter.com/trevmanz/status/1534962190008172545">1</a>
<a href="https://twitter.com/trevmanz/status/1534962940348092417">2</a>. I don’t personally
use this technique yet but there are many users with this workflow</p>
<p>An interesting thing is you can write in <code>.js</code> but still get <code>typescript</code> to get
type checking using <code>jsdoc</code>, just use <code>allowJs</code>/<code>checkJs</code> flags in
<code>tsconfig.json</code></p>
<h2 id="footnote-5-what-about-if-your-library-is-using-jsxreact">Footnote 5: What about if your library is using JSX/React?</h2>
<p>What about using React in your library? Bundlers are still not needed, and not
even babel is needed: you can code your library as in <code>jsx</code> or <code>tsx</code> files and
use <code>tsc</code> to compile it, and it will be converted to React.createElement
statements (or the newer jsx transform if you elect to use it in your tsconfig).</p>
<h2 id="footnote-6-2025-update">Footnote 6: 2025 update</h2>
<ul>
<li>A new article where we make a “Pure ESM” package with just tsc
<a href="https://cmdcolin.github.io/posts/2025-01-12-pureesm">https://cmdcolin.github.io/posts/2025-01-12-pureesm</a></li>
<li>A new article where I complain about vite library mode bundling dependencies
<a href="https://cmdcolin.github.io/posts/2025-02-23-vitelibrarymode">https://cmdcolin.github.io/posts/2025-02-23-vitelibrarymode</a></li>
</ul> </div> <div id="giscus"></div> <script>
  const script = document.createElement('script');
  script.src = 'https://giscus.app/client.js';
  script.setAttribute('data-repo', 'cmdcolin/cmdcolin.github.io');
  script.setAttribute('data-repo-id', 'MDEwOlJlcG9zaXRvcnkyNjE0OTY3Nw==');
  script.setAttribute('data-category', 'General');
  script.setAttribute('data-category-id', 'DIC_kwDOAY8DLc4CO-L9');
  script.setAttribute('data-mapping', 'pathname');
  script.setAttribute('data-strict', '0');
  script.setAttribute('data-reactions-enabled', '1');
  script.setAttribute('data-emit-metadata', '0');
  script.setAttribute('data-input-position', 'bottom');
  script.setAttribute('data-theme', 'light');
  script.setAttribute('data-lang', 'en');
  script.setAttribute('crossorigin', 'anonymous');
  script.async = true;
  document.getElementById('giscus').appendChild(script);
</script> </article>  </div>   <footer class="footer-style" data-astro-cid-k2f5zb5c> <a class="footer-link" href="/" data-astro-cid-k2f5zb5c>Home</a> <a class="footer-link" href="/archive" data-astro-cid-k2f5zb5c>Blog archive</a> <a class="footer-link" href="https://github.com/cmdcolin/" data-astro-cid-k2f5zb5c>Github</a> <a class="footer-link" href="/projects" data-astro-cid-k2f5zb5c>Projects</a> <a class="footer-link" href="/about" data-astro-cid-k2f5zb5c>About</a> </footer> </body></html> 