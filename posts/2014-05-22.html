<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>High DPI rendering on HTML5 canvas - some problems and solutions</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/0e13ae09fdc48bba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0e13ae09fdc48bba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-01f10f588aa1f712.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-896947e153b7d53e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d6e6a35eb3960502.js" defer=""></script><script src="/_next/static/chunks/996-9e3c12b77542c098.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-cbd064b69a90a980.js" defer=""></script><script src="/_next/static/u2rlAXrc1BPl3_OSGsRf8/_buildManifest.js" defer=""></script><script src="/_next/static/u2rlAXrc1BPl3_OSGsRf8/_ssgManifest.js" defer=""></script><script src="/_next/static/u2rlAXrc1BPl3_OSGsRf8/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>High DPI rendering on HTML5 canvas - some problems and solutions</h1><h4>2014-05-22</h4></div><p>Recently our code has been moving towards the use of HTML5 canvas, as it has
many benefits. I felt that if we were going to keep this going towards canvas,
the rendering needed to match the quality of regular HTML based tracks.
Unfortunately, the HTML5 canvas by default looks very &quot;fuzzy&quot; on a high
resolution display (Figure 1).</p>
<!-- --><p><img src="/media/86542847038_0.jpg" alt=""/></p>
<!-- --><p><em>Figure 1.</em> An example of really bad font rendering before and after enabling
high resolution on the HTML5 canvas.<!-- --></p>
<!-- --><p>**Background **</p>
<!-- --><p>Major credit goes to the tutorial at
http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for pioneering this!
 The html5rocks tutorial, written in 2010 it still remains relevant. The major
thing it introduces is these browser variables called devicePixelRatio and
backingStoreRatio that can be used to adjust your canvas drawing. In my
interpretation, these two variables have the following purpose:</p>
<!-- --><p><em>devicePixelRatio</em></p>
<!-- --><p>On high DPI displays, screen pixels are actually abstracted away from the
physical pixels, so, when you create some HTML element with width 100, height
100, that element actually takes up a larger number of pixels than 100x100. The
actual ratio of the pixels that it takes up is 100<!-- --><em>devicePixelRatio x
100</em>devicePixelRatio. On a high DPI platform like Retina, the devicePixelRatio
is normally 2 at 100% zoom.<!-- --></p>
<!-- --><p><em>backingStoreRatio</em></p>
<!-- --><p>The backing store ratio doesn&#x27;t seem to change as much from platform to
platform, but my interpretation of this value is that it essentially gives the
size of the memory buffer for the canvas. On my platform, the backingStoreRatio
is &quot;1&quot;. I think this value had more historical use, but it may not really be
used anymore (update aug 7th, 2015 deprecated?
http://stackoverflow.com/questions/24332639/why-context2d-backingstorepixelratio-deprecated)</p>
<!-- --><p>So, what are the consequences of the backing store ratio and the device pixel
ratio? If the backing store ratio equals the device pixel ratio, then no
scaling takes place, but what we often see is that they are not equal, so the
image is up-scaled from the backing store to the screen, and then it is
stretched and blurred.</p>
<!-- --><p><strong>So, how do you enable the high DPI mode?</strong></p>
<!-- --><p>The solution to properly scale your HTML5 canvas content involves a couple of
steps that are described in the tutorial here
http://www.html5rocks.com/en/tutorials/canvas/hidpi/, but here is the
essence:</p>
<!-- --><ol>
<!-- --><li>
<!-- --><p>Use the canvas.scale method, which tells the canvas&#x27;s drawing area to become
bigger, but keeps drawing operations consistent.</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>The scaling factor for the canvas.scale method is
devicePixelRatio/backingStoreRatio. This will be 2 for instance on a Retina
screen at a typical 100% zoom level. The zoom level is relevant which will be
discussed later in this post...</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>Multiply the width and height attributes of the canvas by
devicePixelRatio/backingStoreRatio, so that the &quot;canvas object&quot; is as big as
the scaled size.</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>Here&#x27;s the tricky part: set the CSS width and height attributes to be the
UNSCALED size that you want.</p>
<!-- --></li>
<!-- --></ol>
<!-- --><p>Note: you can also set CSS width:100% or something and then the canvas will be
sized appropriately. Normally though, what you will have is something like
<!-- --><code>&lt;canvas width=640 height=480 style=&quot;width:320px;height:240px&quot;&gt;</code> so you can see
that the canvas size is larger than what the CSS actually resizes it to be.<!-- --></p>
<!-- --><p>**Issues: Browser zoom and fractional devicePixelRatios **</p>
<!-- --><p>When I first started this project, the benefit of this high resolution
rendering seemed limited to the fancy people who had Retina or other High DPI
screens. However, what I didn&#x27;t even realize is that the devicePixelRatio value
changes depending on browser zoom settings, so even people with a regular
screen can have improved rendering of the HTML5 canvas. (Update: we even saw
that if you have customized canvas renderings, then you an generate good
screenshots of the canvas with PhantomJS too. See <!-- --><a href="http://searchvoidstar.tumblr.com/post/112494997473/creating-high-resolution-screenshots-of-jbrowse">my other more recent
article</a>)<!-- --></p>
<!-- --><p>The issue with these zoom settings though is that when you change the zoom
level, especially on chrome and firefox browsers, the devicePixelRatio can end
up being a fractional value e.g. 2.223277 which can result in sub-pixel
rendering problems.</p>
<!-- --><p>Remember that when we scaled the canvas, it also scales the drawing functions
to be consistent, so that essentially if you draw a 1 pixel width line on a
scaled canvas, it might draw a 2.223277 pixel width line. Hence, we can get
fuzzy rendering issues.</p>
<!-- --><p>This issue is very noticeable if you draw many 1px wide lines right next to
each other. In this case, there will be noticeable gaps between the lines due
to the imperfect rendering (see green box below).</p>
<!-- --><p><img src="/media/86542847038_1.png" alt=""/></p>
<!-- --><p><em>Figure 2.</em> Examples of 1px wide lines rendered next to each other when there
is fractional devicePixelRatio.<!-- --></p>
<!-- --><p>Bottom Green box: 1px wide lines drawn 1px apart. (note: bad rendering! tiny
gaps)  Middle Blue box: 1px wide line rendered every 2 px (intentional gaps for
demonstration).  Top Red box: 1.3px wide lines (a fudge factor is used to make
eliminate the tiny gaps).</p>
<!-- --><p>**My solution: The Red Box -- add a fudge factor **</p>
<!-- --><p>As you can see in the above figure, my solution to the sub-pixel rendering is
to add a &quot;fudge factor&quot; to the line width to make it render lines that are
1.3px wide instead of 1px wide when the devicePixelRatio is not a whole number,
which effectively eliminates any gaps due to the sub-pixel rendering problem.</p>
<!-- --><p>I heuristically determined the value 1.3px to be sufficient, as testing values
like 1.1px, 1.2px and even 1.25px were too small. I&#x27;d love to see a proof of
determining this value empirically, or even better, something that isn&#x27;t this
big of a hack, but for now that&#x27;s what I have.</p>
<!-- --><p>You can see the effect of the fudge factor (red box) vs the bad rendering
(green box) in Figure 2. You can also try this out yourself here
http://jsfiddle.net/4xe4d/, just zoom your browser and then refresh (zooming
and not refreshing doesn&#x27;t modify device pixel ratio) to test out different
values of devicePixelRatio.</p>
<!-- --><p><strong>Conclusion</strong></p>
<!-- --><p>In conclusion...we now have high resolution rendering on canvas! The solution
for drawing lots of lines right next to each other is sort of suboptimal, so
the question continues...what shall be done in this case?</p>
<!-- --><p>Maybe someone could implement some sort of library that replaces the
canvas.scale method to do better layout and obtain more pixel perfect
rendering. Alternatively, you could force the scaling factor to always round to
a whole number. This is actually not a bad solution, because the canvas is
already being resized, and then you can control your rendering better.</p>
<!-- --><p>Thanks for reading</p><div style="margin-top:200px"><giscus-widget id="comments" repo="cmdcolin/cmdcolin.github.io" repoid="MDEwOlJlcG9zaXRvcnkyNjE0OTY3Nw==" category="General" categoryid="DIC_kwDOAY8DLc4CO-L9" mapping="pathname" term="Welcome to @giscus/react component!" reactionsenabled="1" emitmetadata="0" inputposition="top" lang="en" loading="lazy"></giscus-widget></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <!-- --><a href="/archive">Blog archive</a> <!-- --><a href="https://github.com/cmdcolin/">Github</a> <!-- --><a href="https://twitter.com/cmdcolin">Twitter</a> <!-- --><a href="/projects">Projects</a> <!-- --><a href="/photos">Photos</a> <!-- --><a href="/rss.xml">RSS</a><a href="/about">About</a> <!-- --></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"High DPI rendering on HTML5 canvas - some problems and solutions","date":"2014-05-22","slug":"2014-05-22","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      img: \"img\",\n      em: \"em\",\n      strong: \"strong\",\n      ol: \"ol\",\n      li: \"li\",\n      code: \"code\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Recently our code has been moving towards the use of HTML5 canvas, as it has\\nmany benefits. I felt that if we were going to keep this going towards canvas,\\nthe rendering needed to match the quality of regular HTML based tracks.\\nUnfortunately, the HTML5 canvas by default looks very \\\"fuzzy\\\" on a high\\nresolution display (Figure 1).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/86542847038_0.jpg\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"Figure 1.\"\n        }), \" An example of really bad font rendering before and after enabling\\nhigh resolution on the HTML5 canvas.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"**Background **\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Major credit goes to the tutorial at\\nhttp://www.html5rocks.com/en/tutorials/canvas/hidpi/ for pioneering this!\\n The html5rocks tutorial, written in 2010 it still remains relevant. The major\\nthing it introduces is these browser variables called devicePixelRatio and\\nbackingStoreRatio that can be used to adjust your canvas drawing. In my\\ninterpretation, these two variables have the following purpose:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"devicePixelRatio\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"On high DPI displays, screen pixels are actually abstracted away from the\\nphysical pixels, so, when you create some HTML element with width 100, height\\n100, that element actually takes up a larger number of pixels than 100x100. The\\nactual ratio of the pixels that it takes up is 100\", _jsx(_components.em, {\n          children: \"devicePixelRatio x\\n100\"\n        }), \"devicePixelRatio. On a high DPI platform like Retina, the devicePixelRatio\\nis normally 2 at 100% zoom.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"backingStoreRatio\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The backing store ratio doesn't seem to change as much from platform to\\nplatform, but my interpretation of this value is that it essentially gives the\\nsize of the memory buffer for the canvas. On my platform, the backingStoreRatio\\nis \\\"1\\\". I think this value had more historical use, but it may not really be\\nused anymore (update aug 7th, 2015 deprecated?\\nhttp://stackoverflow.com/questions/24332639/why-context2d-backingstorepixelratio-deprecated)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So, what are the consequences of the backing store ratio and the device pixel\\nratio? If the backing store ratio equals the device pixel ratio, then no\\nscaling takes place, but what we often see is that they are not equal, so the\\nimage is up-scaled from the backing store to the screen, and then it is\\nstretched and blurred.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"So, how do you enable the high DPI mode?\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The solution to properly scale your HTML5 canvas content involves a couple of\\nsteps that are described in the tutorial here\\nhttp://www.html5rocks.com/en/tutorials/canvas/hidpi/, but here is the\\nessence:\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Use the canvas.scale method, which tells the canvas's drawing area to become\\nbigger, but keeps drawing operations consistent.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"The scaling factor for the canvas.scale method is\\ndevicePixelRatio/backingStoreRatio. This will be 2 for instance on a Retina\\nscreen at a typical 100% zoom level. The zoom level is relevant which will be\\ndiscussed later in this post...\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Multiply the width and height attributes of the canvas by\\ndevicePixelRatio/backingStoreRatio, so that the \\\"canvas object\\\" is as big as\\nthe scaled size.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Here's the tricky part: set the CSS width and height attributes to be the\\nUNSCALED size that you want.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: you can also set CSS width:100% or something and then the canvas will be\\nsized appropriately. Normally though, what you will have is something like\\n\", _jsx(_components.code, {\n          children: \"\u003ccanvas width=640 height=480 style=\\\"width:320px;height:240px\\\"\u003e\"\n        }), \" so you can see\\nthat the canvas size is larger than what the CSS actually resizes it to be.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"**Issues: Browser zoom and fractional devicePixelRatios **\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When I first started this project, the benefit of this high resolution\\nrendering seemed limited to the fancy people who had Retina or other High DPI\\nscreens. However, what I didn't even realize is that the devicePixelRatio value\\nchanges depending on browser zoom settings, so even people with a regular\\nscreen can have improved rendering of the HTML5 canvas. (Update: we even saw\\nthat if you have customized canvas renderings, then you an generate good\\nscreenshots of the canvas with PhantomJS too. See \", _jsx(_components.a, {\n          href: \"http://searchvoidstar.tumblr.com/post/112494997473/creating-high-resolution-screenshots-of-jbrowse\",\n          children: \"my other more recent\\narticle\"\n        }), \")\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The issue with these zoom settings though is that when you change the zoom\\nlevel, especially on chrome and firefox browsers, the devicePixelRatio can end\\nup being a fractional value e.g. 2.223277 which can result in sub-pixel\\nrendering problems.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Remember that when we scaled the canvas, it also scales the drawing functions\\nto be consistent, so that essentially if you draw a 1 pixel width line on a\\nscaled canvas, it might draw a 2.223277 pixel width line. Hence, we can get\\nfuzzy rendering issues.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This issue is very noticeable if you draw many 1px wide lines right next to\\neach other. In this case, there will be noticeable gaps between the lines due\\nto the imperfect rendering (see green box below).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/86542847038_1.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"Figure 2.\"\n        }), \" Examples of 1px wide lines rendered next to each other when there\\nis fractional devicePixelRatio.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Bottom Green box: 1px wide lines drawn 1px apart. (note: bad rendering! tiny\\ngaps)  Middle Blue box: 1px wide line rendered every 2 px (intentional gaps for\\ndemonstration).  Top Red box: 1.3px wide lines (a fudge factor is used to make\\neliminate the tiny gaps).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"**My solution: The Red Box -- add a fudge factor **\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"As you can see in the above figure, my solution to the sub-pixel rendering is\\nto add a \\\"fudge factor\\\" to the line width to make it render lines that are\\n1.3px wide instead of 1px wide when the devicePixelRatio is not a whole number,\\nwhich effectively eliminates any gaps due to the sub-pixel rendering problem.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I heuristically determined the value 1.3px to be sufficient, as testing values\\nlike 1.1px, 1.2px and even 1.25px were too small. I'd love to see a proof of\\ndetermining this value empirically, or even better, something that isn't this\\nbig of a hack, but for now that's what I have.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You can see the effect of the fudge factor (red box) vs the bad rendering\\n(green box) in Figure 2. You can also try this out yourself here\\nhttp://jsfiddle.net/4xe4d/, just zoom your browser and then refresh (zooming\\nand not refreshing doesn't modify device pixel ratio) to test out different\\nvalues of devicePixelRatio.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Conclusion\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In conclusion...we now have high resolution rendering on canvas! The solution\\nfor drawing lots of lines right next to each other is sort of suboptimal, so\\nthe question continues...what shall be done in this case?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Maybe someone could implement some sort of library that replaces the\\ncanvas.scale method to do better layout and obtain more pixel perfect\\nrendering. Alternatively, you could force the scaling factor to always round to\\na whole number. This is actually not a bad solution, because the canvas is\\nalready being resized, and then you can control your rendering better.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Thanks for reading\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2014-05-22"},"buildId":"u2rlAXrc1BPl3_OSGsRf8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>