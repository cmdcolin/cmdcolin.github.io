<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>How to make your own npm package with typescript</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/53d80a6545e3cb78.css" as="style"/><link rel="stylesheet" href="/_next/static/css/53d80a6545e3cb78.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-6db65d5e18d8108f.js" defer=""></script><script src="/_next/static/sbN1qP19t1p32bZbSoLsI/_buildManifest.js" defer=""></script><script src="/_next/static/sbN1qP19t1p32bZbSoLsI/_ssgManifest.js" defer=""></script><script src="/_next/static/sbN1qP19t1p32bZbSoLsI/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>How to make your own npm package with typescript</h1><h4>2021-12-31</h4></div><p>There is a lot of mystery around making your own <code>npm</code> package. Every package
likely does it a bit differently, and it can be tricky to get a setup you like.
Should you use a &quot;starter kit&quot; or a boilerplate example? Or just roll your own?
Should you use a bundler? How do you use typescript?</p><p><strong>*<!-- -->Record scratch <!-- -->*<!-- -->*</strong></p><p>Why don&#x27;t we try starting from scratch and seeing where we can get?</p><p>TLDR: here is a github repo with a template package
<a href="https://github.com/cmdcolin/npm-package-tutorial/">https://github.com/cmdcolin/npm-package-tutorial/</a></p><h2>Introduction</h2><p>An <code>npm</code> package can be very bare bones. In some sense, npmjs.com is just an
arbitrary file host, and you can upload pretty much anything you want to it.</p><p>The magic is in the package.json file, which tells npm:</p><ul><li>what files are part of your package</li><li>what to use as the &quot;entry point&quot; (e.g. the file that should be referenced
when you say <code>const lib = require(&#x27;mypackage&#x27;)</code>)</li><li>what pre- and post- processing steps should be done when the package is being
published</li><li>and more!</li></ul><p>Let&#x27;s try an experiment...</p><h2>Initializing a package</h2><p>Open up a terminal, and run</p><pre><code class="language-sh">mkdir mypackage
cd mypackage
git init # make mypackage version controlled
npm init
# or
yarn init
</code></pre><p>This init command outputs something like this, and we accept the defaults</p><pre><code class="language-sh">This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (mypackage)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
license: (ISC)
About to write to /home/cdiesh/mypackage/package.json:

{
  &quot;name&quot;: &quot;mypackage&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;Colin&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre><p>Then, you can create a file named <code>index.js</code> (in your package.json it says
<code>&quot;main&quot;: &quot;index.js&quot;</code> to refer to this file, the entrypoint)</p><p>In your <code>index.js</code> file, generally, you would do things like export a function
or functions. I will use commonjs exports here for maximum compatibility:</p><pre><code class="language-js">module.exports = {
  hello: () =&gt; {
    console.log(&#x27;hello world&#x27;)
  },
}
</code></pre><h2>Publishing a package</h2><p>This npm package, <code>mypackage</code> can now be published to <code>npm</code> with a simple
command.</p><pre><code class="language-sh">npm publish
# or
yarn publish
</code></pre><p>This will prompt you for your npmjs.com username, password, email, and if
needed, 2FA token (highly recommended)</p><h2>Using your package after it is published</h2><p>Once it is published, you can use it in your create-react-app app or other npm
package.</p><pre><code class="language-sh">npm install mypackage
# or
yarn add mypackage
</code></pre><p>Then you can use</p><pre><code class="language-js">import { hello } from &#x27;mypackage&#x27;
</code></pre><p>in any of your other codebases</p><h2>Summary of the simplest NPM package</h2><p>This all seems pretty boring thus far but it tells us a couple things</p><ol><li>packages can be very very bare bones</li><li>no transpiler or bundler is needed for publishing an npm package</li><li>our package can consist of a single file and it is uploaded to npm, and the
&quot;main&quot; field in package.json provides an entry point</li><li>the filename index.js is not special, probably it is a hangover from the
name index.html. you can use whatever name you want</li></ol><h2>Adding typescript</h2><p>Let&#x27;s try adding typescript</p><p>To do this, we will use the typescript compiler to compile a directory of files
in our &quot;src&quot; directory and output the compiled files to a directory named
&quot;dist&quot;</p><p>To start, let&#x27;s add typescript</p><pre><code class="language-sh">npm install --save-dev typescript
# or
yarn add -D typescript
</code></pre><p>Our package.json now will have <code>typescript</code> in it&#x27;s <code>devDependencies</code> (this
means that when someone installs your package, it they don&#x27;t get typescript as
a dependency, it is just a dependency for while you are developing the library
locally).</p><p>Then we need to create a tsconfig.json for typescript to use</p><pre><code class="language-sh">yarn tsc --init
# or
npx tsc --init
</code></pre><p>This will generate a <code>tsconfig.json</code> file (needed by <code>typescript</code>) with a bunch of
options, but I have stripped it down in my projects to look like this</p><pre><code class="language-json">{
  &quot;include&quot;: [&quot;src&quot;],
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es2018&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;declaration&quot;: true, // generate .d.ts files
    &quot;sourceMap&quot;: true, // generate source map
    &quot;outDir&quot;: &quot;dist&quot;, // output compiled js, d.ts, and source map to dist folder
    &quot;strict&quot;: true,
    &quot;esModuleInterop&quot;: true
  }
}
</code></pre><p>Now, we want to change our <code>js</code> to <code>ts</code> files to use <code>typescript</code>, let&#x27;s change them
to use normal ESM import/exports</p><p>util.ts</p><pre><code class="language-typescript">export function getMessage() {
  return &#x27;hello&#x27;
}
</code></pre><p>index.ts</p><pre><code class="language-typescript">import { getMessage } from &#x27;./util&#x27;
export function sayMessage() {
  console.log(getMessage())
}
</code></pre><p>And then we will add a <code>&quot;build&quot;</code> script to <code>package.json</code> to compile the
library, and refer to the <code>&quot;dist&quot;</code> directory for the <code>&quot;files&quot;</code> and <code>&quot;main&quot;</code>
fields in <code>package.json</code></p><pre><code class="language-json">{
  &quot;name&quot;: &quot;mypackage&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;src/index.js&quot;,
  &quot;files&quot;: [&quot;dist&quot;],
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc&quot;
  },
  &quot;author&quot;: &quot;Colin&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;typescript&quot;: &quot;^4.5.4&quot;
  }
}
</code></pre><p>We can now run</p><pre><code class="language-sh">npm run build
# or
yarn build
</code></pre><p>And this will run the <code>&quot;build&quot;</code> script we created, which in turn, just runs
<code>tsc</code> with no arguments.</p><p>You can also add a <code>&quot;prebuild&quot;</code> script that clears out the old contents. In fact,
npm scripts generalizes the naming system -- you can make scripts with whatever name you want, e.g.</p><pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;preparty&quot;: &quot;echo preparty&quot;,
    &quot;party&quot;: &quot;echo party&quot;,
    &quot;postparty&quot;: &quot;echo postparty&quot;
  }
}
</code></pre><p>Then running</p><pre><code class="language-sh">$ yarn party
preparty
party
postparty
</code></pre><p>To make this useful, we will use <code>rimraf</code> (a node package) to make a
cross-platform removal of the <code>dist</code> directory</p><pre><code class="language-sh">npm install --save-dev rimraf
# or
yarn add -D rimraf
</code></pre><p>and then update your package.json</p><pre><code class="language-json">{
  ...
  &quot;scripts&quot;: {
    &quot;clean&quot;: &quot;rimraf dist&quot;,
    &quot;prebuild&quot;: &quot;npm run clean&quot;,
    &quot;build&quot;: &quot;tsc&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;rimraf&quot;: &quot;^3.0.2&quot;,
    &quot;typescript&quot;: &quot;^4.5.4&quot;
  }
}
</code></pre><p>We could make it say &quot;rm -rf dist&quot; instead of &quot;rimraf dist&quot; (e.g. run arbitrary
shell commands), but rimraf allows it to be cross-platform</p><h2>Making sure you create a fresh build before you publish</h2><p>Without extra instructions, your <code>yarn publish</code> command would not create a
fresh build and you could publish an older version that was lingering in the
<code>dist</code> folder.</p><p>We can use a <code>preversion</code> script that will automatically get invoked when you
run <code>yarn publish</code> to make sure you get a fresh build in the <code>dist</code> folder
before you publish</p><pre><code class="language-json">{
  ...
  &quot;scripts&quot;: {
    ...
    &quot;preversion&quot;: &quot;npm run build&quot;,
  },
}
</code></pre><h2>Making sure you push your tag to github after publish</h2><p>When you run <code>yarn publish</code>, npm will automatically create a commit with the
version name and a git tag, it <em>will not</em> automatically push tag to your
repository.</p><p>Add a <code>postversion</code> script that pushes the tag to your repo after your publish</p><pre><code class="language-json">{
  ...
  &quot;scripts&quot;: {
    ...
    &quot;postversion&quot;: &quot;git push --follow-tags&quot;,
  },
}
</code></pre><h2>Incremental builds</h2><p>We can use this to do incremental/watch builds</p><pre><code>npm run build --watch
# or
yarn build --watch
</code></pre><h2>Adding testing with ts-jest</h2><p>You can use ts-jest to test your code. This involves installing jest, typescript, ts-jest, @types/jest, and then initializing a jest.config.json</p><pre><code class="language-sh">npm i -D jest typescript
# or
yarn add --dev jest typescript
</code></pre><pre><code class="language-sh">npm i -D ts-jest @types/jest
# or
yarn add --dev ts-jest @types/jest
</code></pre><pre><code class="language-sh">npx ts-jest config:init
# or
yarn ts-jest config:init
</code></pre><p>We can then create a test</p><p><code>test/util.spec.ts</code></p><pre><code class="language-typescript">import { getMessage } from &#x27;../src/util&#x27;
test(&#x27;expected message returned&#x27;, () =&gt; {
  expect(getMessage()).toBe(&#x27;hello&#x27;)
})
</code></pre><p>Then we can then create a script in the package.json that says <code>&quot;test&quot;: &quot;jest&quot;</code>, and then we can say</p><pre><code>npm run test
# or
yarn test
</code></pre><p>You can also create an alternative system where you use <code>babel-eslint</code> and
various babel strategies to test your code, but if you are using typescript,
ts-jest+typescript works great.</p><h2>Add a .gitignore</h2><p>Create a .gitignore with just a line that references this <code>dist</code> folder and <code>node_modules</code> folder</p><pre><code>dist
node_modules
</code></pre><h2>The future of ESM modules</h2><p>There is a shift happening where modules are changing to be pure ESM rather
than keeping commonjs equivalents</p><p><a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></p><p>There are many challenges here, and will not be discussed, but it may be a
useful further reading page</p><h2>Conclusion</h2><p>This tutorial shows you how you can create a basic package that you can publish
to <code>npm</code>. This little boilerplate includes these features:</p><ul><li>Makes clean build when running <code>yarn build</code> or <code>yarn publish</code></li><li>Pushes to github after publish</li><li>Uses ts-jest for testing</li><li>Uses esm modules</li></ul><p>You also have full control, and understand the decisions we took to get to this
point. This package does not use any bundling (rollup or webpack or otherwise).
It just uses <code>tsc</code> is used to compile the files to the <code>dist</code> folder, and the
dist folder is published to <code>npm</code>! If you need your package to be usable by
consumers that don&#x27;t themselves use bundlers, consider looking into <code>&lt;script type=&quot;module&quot;&gt;</code> for importing ESM modules in the browser, or you can bundle
your library using rollup or webpack and output e.g. a UMD bundle</p><h2>Final product</h2><p>See <a href="https://github.com/cmdcolin/npm-package-tutorial/">https://github.com/cmdcolin/npm-package-tutorial/</a></p></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="https://scholar.google.com/citations?view_op=list_works&amp;hl=en&amp;user=--FwzsgAAAAJ">Publications</a> <a href="/sketches">Sketches</a> <a href="/kitty">Kitty</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"How to make your own npm package with typescript","date":"2021-12-31","slug":"2021-12-31-npm-package","mdxSource":{"compiledSource":"var c=Object.defineProperty,u=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var s=(a,n,t)=\u003en in a?c(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t,e=(a,n)=\u003e{for(var t in n||(n={}))p.call(n,t)\u0026\u0026s(a,t,n[t]);if(o)for(var t of o(n))r.call(n,t)\u0026\u0026s(a,t,n[t]);return a},l=(a,n)=\u003eu(a,m(n));var d=(a,n)=\u003e{var t={};for(var i in a)p.call(a,i)\u0026\u0026n.indexOf(i)\u003c0\u0026\u0026(t[i]=a[i]);if(a!=null\u0026\u0026o)for(var i of o(a))n.indexOf(i)\u003c0\u0026\u0026r.call(a,i)\u0026\u0026(t[i]=a[i]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var i=t,{components:a}=i,n=d(i,[\"components\"]);return mdx(MDXLayout,l(e(e({},layoutProps),n),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"There is a lot of mystery around making your own \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` package. Every package\nlikely does it a bit differently, and it can be tricky to get a setup you like.\nShould you use a \"starter kit\" or a boilerplate example? Or just roll your own?\nShould you use a bundler? How do you use typescript?`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"*\",\"Record scratch \",\"*\",\"*\")),mdx(\"p\",null,\"Why don't we try starting from scratch and seeing where we can get?\"),mdx(\"p\",null,`TLDR: here is a github repo with a template package\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cmdcolin/npm-package-tutorial/\"}),\"https://github.com/cmdcolin/npm-package-tutorial/\")),mdx(\"h2\",null,\"Introduction\"),mdx(\"p\",null,\"An \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` package can be very bare bones. In some sense, npmjs.com is just an\narbitrary file host, and you can upload pretty much anything you want to it.`),mdx(\"p\",null,\"The magic is in the package.json file, which tells npm:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"what files are part of your package\"),mdx(\"li\",{parentName:\"ul\"},`what to use as the \"entry point\" (e.g. the file that should be referenced\nwhen you say `,mdx(\"inlineCode\",{parentName:\"li\"},\"const lib = require('mypackage')\"),\")\"),mdx(\"li\",{parentName:\"ul\"},`what pre- and post- processing steps should be done when the package is being\npublished`),mdx(\"li\",{parentName:\"ul\"},\"and more!\")),mdx(\"p\",null,\"Let's try an experiment...\"),mdx(\"h2\",null,\"Initializing a package\"),mdx(\"p\",null,\"Open up a terminal, and run\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`mkdir mypackage\ncd mypackage\ngit init # make mypackage version controlled\nnpm init\n# or\nyarn init\n`)),mdx(\"p\",null,\"This init command outputs something like this, and we accept the defaults\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`This utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee \\`npm help init\\` for definitive documentation on these fields\nand exactly what they do.\n\nUse \\`npm install \u003cpkg\u003e\\` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\npackage name: (mypackage)\nversion: (1.0.0)\ndescription:\nentry point: (index.js)\ntest command:\ngit repository:\nkeywords:\nlicense: (ISC)\nAbout to write to /home/cdiesh/mypackage/package.json:\n\n{\n  \"name\": \"mypackage\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\\\"Error: no test specified\\\\\" \u0026\u0026 exit 1\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\"\n}\n\n`)),mdx(\"p\",null,\"Then, you can create a file named \",mdx(\"inlineCode\",{parentName:\"p\"},\"index.js\"),` (in your package.json it says\n`,mdx(\"inlineCode\",{parentName:\"p\"},'\"main\": \"index.js\"'),\" to refer to this file, the entrypoint)\"),mdx(\"p\",null,\"In your \",mdx(\"inlineCode\",{parentName:\"p\"},\"index.js\"),` file, generally, you would do things like export a function\nor functions. I will use commonjs exports here for maximum compatibility:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`module.exports = {\n  hello: () =\u003e {\n    console.log('hello world')\n  },\n}\n`)),mdx(\"h2\",null,\"Publishing a package\"),mdx(\"p\",null,\"This npm package, \",mdx(\"inlineCode\",{parentName:\"p\"},\"mypackage\"),\" can now be published to \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` with a simple\ncommand.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm publish\n# or\nyarn publish\n`)),mdx(\"p\",null,`This will prompt you for your npmjs.com username, password, email, and if\nneeded, 2FA token (highly recommended)`),mdx(\"h2\",null,\"Using your package after it is published\"),mdx(\"p\",null,`Once it is published, you can use it in your create-react-app app or other npm\npackage.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm install mypackage\n# or\nyarn add mypackage\n`)),mdx(\"p\",null,\"Then you can use\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`import { hello } from 'mypackage'\n`)),mdx(\"p\",null,\"in any of your other codebases\"),mdx(\"h2\",null,\"Summary of the simplest NPM package\"),mdx(\"p\",null,\"This all seems pretty boring thus far but it tells us a couple things\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"packages can be very very bare bones\"),mdx(\"li\",{parentName:\"ol\"},\"no transpiler or bundler is needed for publishing an npm package\"),mdx(\"li\",{parentName:\"ol\"},`our package can consist of a single file and it is uploaded to npm, and the\n\"main\" field in package.json provides an entry point`),mdx(\"li\",{parentName:\"ol\"},`the filename index.js is not special, probably it is a hangover from the\nname index.html. you can use whatever name you want`)),mdx(\"h2\",null,\"Adding typescript\"),mdx(\"p\",null,\"Let's try adding typescript\"),mdx(\"p\",null,`To do this, we will use the typescript compiler to compile a directory of files\nin our \"src\" directory and output the compiled files to a directory named\n\"dist\"`),mdx(\"p\",null,\"To start, let's add typescript\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm install --save-dev typescript\n# or\nyarn add -D typescript\n`)),mdx(\"p\",null,\"Our package.json now will have \",mdx(\"inlineCode\",{parentName:\"p\"},\"typescript\"),\" in it's \",mdx(\"inlineCode\",{parentName:\"p\"},\"devDependencies\"),` (this\nmeans that when someone installs your package, it they don't get typescript as\na dependency, it is just a dependency for while you are developing the library\nlocally).`),mdx(\"p\",null,\"Then we need to create a tsconfig.json for typescript to use\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`yarn tsc --init\n# or\nnpx tsc --init\n`)),mdx(\"p\",null,\"This will generate a \",mdx(\"inlineCode\",{parentName:\"p\"},\"tsconfig.json\"),\" file (needed by \",mdx(\"inlineCode\",{parentName:\"p\"},\"typescript\"),`) with a bunch of\noptions, but I have stripped it down in my projects to look like this`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"moduleResolution\": \"node\",\n    \"declaration\": true, // generate .d.ts files\n    \"sourceMap\": true, // generate source map\n    \"outDir\": \"dist\", // output compiled js, d.ts, and source map to dist folder\n    \"strict\": true,\n    \"esModuleInterop\": true\n  }\n}\n`)),mdx(\"p\",null,\"Now, we want to change our \",mdx(\"inlineCode\",{parentName:\"p\"},\"js\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"ts\"),\" files to use \",mdx(\"inlineCode\",{parentName:\"p\"},\"typescript\"),`, let's change them\nto use normal ESM import/exports`),mdx(\"p\",null,\"util.ts\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`export function getMessage() {\n  return 'hello'\n}\n`)),mdx(\"p\",null,\"index.ts\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`import { getMessage } from './util'\nexport function sayMessage() {\n  console.log(getMessage())\n}\n`)),mdx(\"p\",null,\"And then we will add a \",mdx(\"inlineCode\",{parentName:\"p\"},'\"build\"'),\" script to \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),` to compile the\nlibrary, and refer to the `,mdx(\"inlineCode\",{parentName:\"p\"},'\"dist\"'),\" directory for the \",mdx(\"inlineCode\",{parentName:\"p\"},'\"files\"'),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},'\"main\"'),`\nfields in `,mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"name\": \"mypackage\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"src/index.js\",\n  \"files\": [\"dist\"],\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^4.5.4\"\n  }\n}\n`)),mdx(\"p\",null,\"We can now run\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm run build\n# or\nyarn build\n`)),mdx(\"p\",null,\"And this will run the \",mdx(\"inlineCode\",{parentName:\"p\"},'\"build\"'),` script we created, which in turn, just runs\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"tsc\"),\" with no arguments.\"),mdx(\"p\",null,\"You can also add a \",mdx(\"inlineCode\",{parentName:\"p\"},'\"prebuild\"'),` script that clears out the old contents. In fact,\nnpm scripts generalizes the naming system -- you can make scripts with whatever name you want, e.g.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"scripts\": {\n    \"preparty\": \"echo preparty\",\n    \"party\": \"echo party\",\n    \"postparty\": \"echo postparty\"\n  }\n}\n`)),mdx(\"p\",null,\"Then running\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`$ yarn party\npreparty\nparty\npostparty\n`)),mdx(\"p\",null,\"To make this useful, we will use \",mdx(\"inlineCode\",{parentName:\"p\"},\"rimraf\"),` (a node package) to make a\ncross-platform removal of the `,mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),\" directory\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm install --save-dev rimraf\n# or\nyarn add -D rimraf\n`)),mdx(\"p\",null,\"and then update your package.json\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  ...\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"prebuild\": \"npm run clean\",\n    \"build\": \"tsc\"\n  },\n  \"devDependencies\": {\n    \"rimraf\": \"^3.0.2\",\n    \"typescript\": \"^4.5.4\"\n  }\n}\n`)),mdx(\"p\",null,`We could make it say \"rm -rf dist\" instead of \"rimraf dist\" (e.g. run arbitrary\nshell commands), but rimraf allows it to be cross-platform`),mdx(\"h2\",null,\"Making sure you create a fresh build before you publish\"),mdx(\"p\",null,\"Without extra instructions, your \",mdx(\"inlineCode\",{parentName:\"p\"},\"yarn publish\"),` command would not create a\nfresh build and you could publish an older version that was lingering in the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),\" folder.\"),mdx(\"p\",null,\"We can use a \",mdx(\"inlineCode\",{parentName:\"p\"},\"preversion\"),` script that will automatically get invoked when you\nrun `,mdx(\"inlineCode\",{parentName:\"p\"},\"yarn publish\"),\" to make sure you get a fresh build in the \",mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),` folder\nbefore you publish`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  ...\n  \"scripts\": {\n    ...\n    \"preversion\": \"npm run build\",\n  },\n}\n`)),mdx(\"h2\",null,\"Making sure you push your tag to github after publish\"),mdx(\"p\",null,\"When you run \",mdx(\"inlineCode\",{parentName:\"p\"},\"yarn publish\"),`, npm will automatically create a commit with the\nversion name and a git tag, it `,mdx(\"em\",{parentName:\"p\"},\"will not\"),` automatically push tag to your\nrepository.`),mdx(\"p\",null,\"Add a \",mdx(\"inlineCode\",{parentName:\"p\"},\"postversion\"),\" script that pushes the tag to your repo after your publish\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  ...\n  \"scripts\": {\n    ...\n    \"postversion\": \"git push --follow-tags\",\n  },\n}\n`)),mdx(\"h2\",null,\"Incremental builds\"),mdx(\"p\",null,\"We can use this to do incremental/watch builds\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`npm run build --watch\n# or\nyarn build --watch\n`)),mdx(\"h2\",null,\"Adding testing with ts-jest\"),mdx(\"p\",null,\"You can use ts-jest to test your code. This involves installing jest, typescript, ts-jest, @types/jest, and then initializing a jest.config.json\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm i -D jest typescript\n# or\nyarn add --dev jest typescript\n`)),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm i -D ts-jest @types/jest\n# or\nyarn add --dev ts-jest @types/jest\n`)),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npx ts-jest config:init\n# or\nyarn ts-jest config:init\n`)),mdx(\"p\",null,\"We can then create a test\"),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"test/util.spec.ts\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`import { getMessage } from '../src/util'\ntest('expected message returned', () =\u003e {\n  expect(getMessage()).toBe('hello')\n})\n`)),mdx(\"p\",null,\"Then we can then create a script in the package.json that says \",mdx(\"inlineCode\",{parentName:\"p\"},'\"test\": \"jest\"'),\", and then we can say\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`npm run test\n# or\nyarn test\n`)),mdx(\"p\",null,\"You can also create an alternative system where you use \",mdx(\"inlineCode\",{parentName:\"p\"},\"babel-eslint\"),` and\nvarious babel strategies to test your code, but if you are using typescript,\nts-jest+typescript works great.`),mdx(\"h2\",null,\"Add a .gitignore\"),mdx(\"p\",null,\"Create a .gitignore with just a line that references this \",mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),\" folder and \",mdx(\"inlineCode\",{parentName:\"p\"},\"node_modules\"),\" folder\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`dist\nnode_modules\n`)),mdx(\"h2\",null,\"The future of ESM modules\"),mdx(\"p\",null,`There is a shift happening where modules are changing to be pure ESM rather\nthan keeping commonjs equivalents`),mdx(\"p\",null,mdx(\"a\",e({parentName:\"p\"},{href:\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\"}),\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\")),mdx(\"p\",null,`There are many challenges here, and will not be discussed, but it may be a\nuseful further reading page`),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`This tutorial shows you how you can create a basic package that you can publish\nto `,mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),\". This little boilerplate includes these features:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Makes clean build when running \",mdx(\"inlineCode\",{parentName:\"li\"},\"yarn build\"),\" or \",mdx(\"inlineCode\",{parentName:\"li\"},\"yarn publish\")),mdx(\"li\",{parentName:\"ul\"},\"Pushes to github after publish\"),mdx(\"li\",{parentName:\"ul\"},\"Uses ts-jest for testing\"),mdx(\"li\",{parentName:\"ul\"},\"Uses esm modules\")),mdx(\"p\",null,`You also have full control, and understand the decisions we took to get to this\npoint. This package does not use any bundling (rollup or webpack or otherwise).\nIt just uses `,mdx(\"inlineCode\",{parentName:\"p\"},\"tsc\"),\" is used to compile the files to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),` folder, and the\ndist folder is published to `,mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),`! If you need your package to be usable by\nconsumers that don't themselves use bundlers, consider looking into `,mdx(\"inlineCode\",{parentName:\"p\"},'\u003cscript type=\"module\"\u003e'),` for importing ESM modules in the browser, or you can bundle\nyour library using rollup or webpack and output e.g. a UMD bundle`),mdx(\"h2\",null,\"Final product\"),mdx(\"p\",null,\"See \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cmdcolin/npm-package-tutorial/\"}),\"https://github.com/cmdcolin/npm-package-tutorial/\")))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2021-12-31-npm-package"},"buildId":"sbN1qP19t1p32bZbSoLsI","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>