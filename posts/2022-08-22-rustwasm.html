<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Using Rust/WASM in a monorepo with create-react-app</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/9d066bf523979bbf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d066bf523979bbf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-8b8836cfd4de0dcd.js" defer=""></script><script src="/_next/static/chunks/framework-c0d8f0fd2eea5ac1.js" defer=""></script><script src="/_next/static/chunks/main-ad18704b098b4264.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d9139de5c3de3b6b.js" defer=""></script><script src="/_next/static/chunks/996-f78e375898643c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-34e532adea304c66.js" defer=""></script><script src="/_next/static/VIInqRrXW0scunbxIvd09/_buildManifest.js" defer=""></script><script src="/_next/static/VIInqRrXW0scunbxIvd09/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Using Rust/WASM in a monorepo with create-react-app</h1><h4>2022-08-22</h4></div><p>Behold, the buzzwords:</p>
<ul>
<li>Rust / WASM / wasm-bindgen</li>
<li>React</li>
<li>Monorepo / Yarn workspaces</li>
<li>Webpack 5 / create-react-app 5</li>
<li>Typescript</li>
</ul>
<p>TLDR: https://github.com/cmdcolin/rust_react_monorepo_template</p>
<p>The main goal though? To use Rust + WASM in a react app, inside a monorepo.
Here is a template you can use to set this up</p>
<h2>Basic steps</h2>
<h3>Create repo</h3>
<pre><code>mkdir template
cd template
git init
</code></pre>
<h3>Create root <code>package.json</code></h3>
<p>Then put this in the monorepo&#x27;s root <code>package.json</code></p>
<pre><code class="language-json">{
  &quot;private&quot;: true,
  &quot;workspaces&quot;: [&quot;hello-wasm&quot;, &quot;app&quot;]
}
</code></pre>
<p>This sets our repo up as a &quot;monorepo&quot; with two &quot;workspaces&quot;. one will be the
wasm code, in <code>hello-wasm</code>, one will be an instance of <code>create-react-app</code></p>
<h3>Add a <code>create-react-app</code> instance inside the monorepo</h3>
<pre><code class="language-sh">npx create-react-app --template typescript app
</code></pre>
<p>This will make an <code>app</code> subfolder inside our monorepo</p>
<h3>Download the hello world rust <code>wasm-bindgen</code> example and put it in a folder named <code>hello-wasm</code></h3>
<p>Download https://github.com/rustwasm/wasm-bindgen/tree/main/examples/hello_world to the hello-wasm folder</p>
<p>This link can help https://download-directory.github.io/?url=https%3A%2F%2Fgithub.com%2Frustwasm%2Fwasm-bindgen%2Ftree%2Fmain%2Fexamples%2Fhello_world</p>
<h3>Add some extra fields to the <code>package.json</code></h3>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;hello-wasm&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;files&quot;: [&quot;pkg&quot;],
  &quot;main&quot;: &quot;pkg/index.js&quot;
  ... rest
}
</code></pre>
<h3>Add the <code>hello-wasm</code> package to the <code>app</code> dependencies</h3>
<p>Add <code>&quot;hello-wasm&quot;:&quot;^1.0.0&quot;</code> to the <code>dependencies</code> array in <code>app/package.json</code>. This
will refer to our local monorepo&#x27;s rust wasm package!</p>
<h3>Build the <code>hello-wasm</code> pkg</h3>
<p>Go into the <code>hello-wasm</code> folder and run <code>yarn build</code>. This creates a directory
named <code>pkg</code> which has <code>.wasm</code> files and <code>.js</code> files. Now, the <code>hello-wasm</code>
folder is effectively a node package. We could publish this to <code>NPM</code> (see
footnote 1)</p>
<h3>Create craco config for <code>create-react-app</code></h3>
<p>As of writing, you have to customize the <code>create-react-app</code> to add extra webpack flags.</p>
<p>So, <code>yarn add @craco/craco</code> in the app folder, then create this <code>craco.config.js</code></p>
<pre><code class="language-js">const path = require(&quot;path&quot;);
const webpack = require(&quot;webpack&quot;);

module.exports = {
  webpack: {
    configure: (config) =&gt; {
      const wasmExtensionRegExp = /\.wasm$/;
      config.resolve.extensions.push(&quot;.wasm&quot;);
      config.experiments = {
        syncWebAssembly: true,
      };

      config.module.rules.forEach((rule) =&gt; {
        (rule.oneOf || []).forEach((oneOf) =&gt; {
          if (oneOf.type === &quot;asset/resource&quot;) {
            oneOf.exclude.push(wasmExtensionRegExp);
          }
        });
      });

      return config;
    },
  },
};
</code></pre>
<p>Note: this thread helped me to create the craco config
<a href="https://github.com/Emurgo/cardano-serialization-lib/issues/295">https://github.com/Emurgo/cardano-serialization-lib/issues/295</a></p>
<h3>Modify the <code>hello-wasm</code> example to return a value instead of making an alert</h3>
<p>I changed the rust code to return a String value instead of making an alert box</p>
<pre><code>#[wasm_bindgen]
pub fn greet(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}&quot;, name)
}
</code></pre>
<h3>Final step: Use async <code>import()</code> to import the <code>hello-wasm</code> greeting</h3>
<p>We use a <code>useEffect</code> hook to import the code asynchronously, and can call our
rust function, <code>greet</code>, from javascript!</p>
<pre><code class="language-tsx">function App() {
  const [greeting, setGreeting] = useState&lt;string&gt;();
  useEffect(() =&gt; {
    (async () =&gt; {
      try {
        const wasm = await import(&quot;hello-wasm&quot;);
        const greeting = wasm.greet(&quot;Colin&quot;);
        setGreeting(greeting);
      } catch (e) {
        console.error(e);
      }
    })();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;rust monorepo wasm demo&lt;/h1&gt;
      &lt;h2&gt;Greeting from wasm: {!greeting ? &quot;Loading...&quot; : greeting}&lt;/h2&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3>Run the app!</h3>
<p>Go into the <code>app</code> folder, and then run <code>yarn start</code></p>
<h2>Result!</h2>
<p>A screenshot of the app, showing the string &quot;Hello Colin&quot; which is generated
via rust and wasm</p>
<p><img src="/media/rust_wasm_demo.png" alt=""/></p>
<h2>Conclusion</h2>
<p>My main aim was to demonstrate creating a &quot;simple&quot; monorepo setup how you can
integrate Rust+WASM and React. Feel free to ask me any questions and go check
out the repo!</p>
<h2>Other resources</h2>
<p>This article is quite helpful also, but uses a file:/ reference in their
<code>package.json</code> while my approach uses a monorepo, it is fundamentally quite
similar though!
<a href="https://tkat0.github.io/posts/how-to-create-a-react-app-with-rust-and-wasm">https://tkat0.github.io/posts/how-to-create-a-react-app-with-rust-and-wasm</a></p>
<h2>Footnote 1: The <code>hello-wasm</code> folder IS a npm package with wasm files</h2>
<p>The <code>hello-wasm</code> folder can be published to NPM by itself. When consumers of
the package import the module, they would receive <code>pkg/index.js</code> from the
<code>main</code> field in <code>package.json</code>, and then <code>pkg/index.js</code> in turn imports the
<code>index.wasm</code> file. Then it is up to the consumers bundler to package that
correctly.</p>
<h2>Footnote 2: Bundlers and wasm</h2>
<p>As of writing, I am using <code>webpack</code> v5 (part of <code>create-react-app</code> v5), which has
&quot;native support&quot; for wasm. Still, it is hidden behind a flag called
&quot;experiments&quot; (see first google result for webpack wasm here
<a href="https://webpack.js.org/configuration/experiments/">https://webpack.js.org/configuration/experiments/</a>)
so I use <code>@craco/craco</code> to modify the <code>webpack</code> config of <code>create-react-app</code> v5 to
add this.</p>
<p>Note also: The first time I wrote this, I used <code>webpack</code> v4, which used a
slightly different workflow (used a special <code>webpack</code> loader called
<code>wasm-loader</code>)</p>
<p>If others have info on how other bundlers use wasm, feel free to leave a
comment.</p>
<h2>Footnote 3: Why do I have to use async imports?</h2>
<p>Fundamentally, the <code>.wasm</code> file has to be fetched asynchronously before it can
be run (it is not in my experience e.g. embedded as binary data inside a js
file) which means it would be difficult to use the wasm code as a synchronous
import.</p>
<p>There are hints that this may be possible but it would rely on the bundler
embedding the wasm code in the js itself, or maybe top level imports. If anyone
has more info, feel free to leave a comment!</p>
<h2>Footnote 4: Build setup</h2>
<p>The <code>hello-wasm</code> package does not automatically recompile when we are running
e.g. <code>yarn start</code> in the <code>app</code> folder. Therefore, changes to the rust requires
you to manually run <code>yarn build</code> in the <code>hello-wasm</code> folder. Just something to
be aware of</p>
<h2>Footnote 5: My first experience with trying to make this work was rocky!</h2>
<p>I first created an example of rust+wasm+react almost two years ago when
creating a fractal viewer
<a href="https://github.com/cmdcolin/logistic_chaos_map">https://github.com/cmdcolin/logistic_chaos_map</a>
and it has some development notes on the stumbling blocks I faced
<a href="https://github.com/cmdcolin/logistic_chaos_map/blob/master/NOTES.md">https://github.com/cmdcolin/logistic_chaos_map/blob/master/NOTES.md</a></p>
<h2>Footnote 6: I thought you said typescript too</h2>
<p>Yep! The wasm-bindgen example generates typescript .d.ts files! Check out the hello-wasm/pkg/ folder!</p><div style="margin-top:200px"></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin/">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Using Rust/WASM in a monorepo with create-react-app","date":"2022-08-22","slug":"2022-08-22-rustwasm","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Behold, the buzzwords:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Rust / WASM / wasm-bindgen\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"React\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Monorepo / Yarn workspaces\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Webpack 5 / create-react-app 5\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Typescript\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TLDR: https://github.com/cmdcolin/rust_react_monorepo_template\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main goal though? To use Rust + WASM in a react app, inside a monorepo.\\nHere is a template you can use to set this up\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Basic steps\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Create repo\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"mkdir template\\ncd template\\ngit init\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Create root \", _jsx(_components.code, {\n        children: \"package.json\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then put this in the monorepo's root \", _jsx(_components.code, {\n        children: \"package.json\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"private\\\": true,\\n  \\\"workspaces\\\": [\\\"hello-wasm\\\", \\\"app\\\"]\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This sets our repo up as a \\\"monorepo\\\" with two \\\"workspaces\\\". one will be the\\nwasm code, in \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \", one will be an instance of \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Add a \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" instance inside the monorepo\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"npx create-react-app --template typescript app\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This will make an \", _jsx(_components.code, {\n        children: \"app\"\n      }), \" subfolder inside our monorepo\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Download the hello world rust \", _jsx(_components.code, {\n        children: \"wasm-bindgen\"\n      }), \" example and put it in a folder named \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Download https://github.com/rustwasm/wasm-bindgen/tree/main/examples/hello_world to the hello-wasm folder\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This link can help https://download-directory.github.io/?url=https%3A%2F%2Fgithub.com%2Frustwasm%2Fwasm-bindgen%2Ftree%2Fmain%2Fexamples%2Fhello_world\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Add some extra fields to the \", _jsx(_components.code, {\n        children: \"package.json\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"name\\\": \\\"hello-wasm\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"files\\\": [\\\"pkg\\\"],\\n  \\\"main\\\": \\\"pkg/index.js\\\"\\n  ... rest\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Add the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" package to the \", _jsx(_components.code, {\n        children: \"app\"\n      }), \" dependencies\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Add \", _jsx(_components.code, {\n        children: \"\\\"hello-wasm\\\":\\\"^1.0.0\\\"\"\n      }), \" to the \", _jsx(_components.code, {\n        children: \"dependencies\"\n      }), \" array in \", _jsx(_components.code, {\n        children: \"app/package.json\"\n      }), \". This\\nwill refer to our local monorepo's rust wasm package!\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Build the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" pkg\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Go into the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder and run \", _jsx(_components.code, {\n        children: \"yarn build\"\n      }), \". This creates a directory\\nnamed \", _jsx(_components.code, {\n        children: \"pkg\"\n      }), \" which has \", _jsx(_components.code, {\n        children: \".wasm\"\n      }), \" files and \", _jsx(_components.code, {\n        children: \".js\"\n      }), \" files. Now, the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \"\\nfolder is effectively a node package. We could publish this to \", _jsx(_components.code, {\n        children: \"NPM\"\n      }), \" (see\\nfootnote 1)\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Create craco config for \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As of writing, you have to customize the \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" to add extra webpack flags.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, \", _jsx(_components.code, {\n        children: \"yarn add @craco/craco\"\n      }), \" in the app folder, then create this \", _jsx(_components.code, {\n        children: \"craco.config.js\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"const path = require(\\\"path\\\");\\nconst webpack = require(\\\"webpack\\\");\\n\\nmodule.exports = {\\n  webpack: {\\n    configure: (config) =\u003e {\\n      const wasmExtensionRegExp = /\\\\.wasm$/;\\n      config.resolve.extensions.push(\\\".wasm\\\");\\n      config.experiments = {\\n        syncWebAssembly: true,\\n      };\\n\\n      config.module.rules.forEach((rule) =\u003e {\\n        (rule.oneOf || []).forEach((oneOf) =\u003e {\\n          if (oneOf.type === \\\"asset/resource\\\") {\\n            oneOf.exclude.push(wasmExtensionRegExp);\\n          }\\n        });\\n      });\\n\\n      return config;\\n    },\\n  },\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note: this thread helped me to create the craco config\\n\", _jsx(_components.a, {\n        href: \"https://github.com/Emurgo/cardano-serialization-lib/issues/295\",\n        children: \"https://github.com/Emurgo/cardano-serialization-lib/issues/295\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Modify the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" example to return a value instead of making an alert\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I changed the rust code to return a String value instead of making an alert box\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"#[wasm_bindgen]\\npub fn greet(name: \u0026str) -\u003e String {\\n    format!(\\\"Hello {}\\\", name)\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Final step: Use async \", _jsx(_components.code, {\n        children: \"import()\"\n      }), \" to import the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" greeting\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We use a \", _jsx(_components.code, {\n        children: \"useEffect\"\n      }), \" hook to import the code asynchronously, and can call our\\nrust function, \", _jsx(_components.code, {\n        children: \"greet\"\n      }), \", from javascript!\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function App() {\\n  const [greeting, setGreeting] = useState\u003cstring\u003e();\\n  useEffect(() =\u003e {\\n    (async () =\u003e {\\n      try {\\n        const wasm = await import(\\\"hello-wasm\\\");\\n        const greeting = wasm.greet(\\\"Colin\\\");\\n        setGreeting(greeting);\\n      } catch (e) {\\n        console.error(e);\\n      }\\n    })();\\n  }, []);\\n\\n  return (\\n    \u003cdiv\u003e\\n      \u003ch1\u003erust monorepo wasm demo\u003c/h1\u003e\\n      \u003ch2\u003eGreeting from wasm: {!greeting ? \\\"Loading...\\\" : greeting}\u003c/h2\u003e\\n    \u003c/div\u003e\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Run the app!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Go into the \", _jsx(_components.code, {\n        children: \"app\"\n      }), \" folder, and then run \", _jsx(_components.code, {\n        children: \"yarn start\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Result!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A screenshot of the app, showing the string \\\"Hello Colin\\\" which is generated\\nvia rust and wasm\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/rust_wasm_demo.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"My main aim was to demonstrate creating a \\\"simple\\\" monorepo setup how you can\\nintegrate Rust+WASM and React. Feel free to ask me any questions and go check\\nout the repo!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Other resources\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This article is quite helpful also, but uses a file:/ reference in their\\n\", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \" while my approach uses a monorepo, it is fundamentally quite\\nsimilar though!\\n\", _jsx(_components.a, {\n        href: \"https://tkat0.github.io/posts/how-to-create-a-react-app-with-rust-and-wasm\",\n        children: \"https://tkat0.github.io/posts/how-to-create-a-react-app-with-rust-and-wasm\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"Footnote 1: The \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder IS a npm package with wasm files\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder can be published to NPM by itself. When consumers of\\nthe package import the module, they would receive \", _jsx(_components.code, {\n        children: \"pkg/index.js\"\n      }), \" from the\\n\", _jsx(_components.code, {\n        children: \"main\"\n      }), \" field in \", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \", and then \", _jsx(_components.code, {\n        children: \"pkg/index.js\"\n      }), \" in turn imports the\\n\", _jsx(_components.code, {\n        children: \"index.wasm\"\n      }), \" file. Then it is up to the consumers bundler to package that\\ncorrectly.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 2: Bundlers and wasm\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As of writing, I am using \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" v5 (part of \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" v5), which has\\n\\\"native support\\\" for wasm. Still, it is hidden behind a flag called\\n\\\"experiments\\\" (see first google result for webpack wasm here\\n\", _jsx(_components.a, {\n        href: \"https://webpack.js.org/configuration/experiments/\",\n        children: \"https://webpack.js.org/configuration/experiments/\"\n      }), \")\\nso I use \", _jsx(_components.code, {\n        children: \"@craco/craco\"\n      }), \" to modify the \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" config of \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" v5 to\\nadd this.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note also: The first time I wrote this, I used \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" v4, which used a\\nslightly different workflow (used a special \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" loader called\\n\", _jsx(_components.code, {\n        children: \"wasm-loader\"\n      }), \")\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If others have info on how other bundlers use wasm, feel free to leave a\\ncomment.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 3: Why do I have to use async imports?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Fundamentally, the \", _jsx(_components.code, {\n        children: \".wasm\"\n      }), \" file has to be fetched asynchronously before it can\\nbe run (it is not in my experience e.g. embedded as binary data inside a js\\nfile) which means it would be difficult to use the wasm code as a synchronous\\nimport.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are hints that this may be possible but it would rely on the bundler\\nembedding the wasm code in the js itself, or maybe top level imports. If anyone\\nhas more info, feel free to leave a comment!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 4: Build setup\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" package does not automatically recompile when we are running\\ne.g. \", _jsx(_components.code, {\n        children: \"yarn start\"\n      }), \" in the \", _jsx(_components.code, {\n        children: \"app\"\n      }), \" folder. Therefore, changes to the rust requires\\nyou to manually run \", _jsx(_components.code, {\n        children: \"yarn build\"\n      }), \" in the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder. Just something to\\nbe aware of\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 5: My first experience with trying to make this work was rocky!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I first created an example of rust+wasm+react almost two years ago when\\ncreating a fractal viewer\\n\", _jsx(_components.a, {\n        href: \"https://github.com/cmdcolin/logistic_chaos_map\",\n        children: \"https://github.com/cmdcolin/logistic_chaos_map\"\n      }), \"\\nand it has some development notes on the stumbling blocks I faced\\n\", _jsx(_components.a, {\n        href: \"https://github.com/cmdcolin/logistic_chaos_map/blob/master/NOTES.md\",\n        children: \"https://github.com/cmdcolin/logistic_chaos_map/blob/master/NOTES.md\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 6: I thought you said typescript too\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Yep! The wasm-bindgen example generates typescript .d.ts files! Check out the hello-wasm/pkg/ folder!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-08-22-rustwasm"},"buildId":"VIInqRrXW0scunbxIvd09","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>