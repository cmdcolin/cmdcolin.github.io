<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Structural variants and the SAM format - the long (reads) and short (reads) of it</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/f0ab904b10cea2d1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f0ab904b10cea2d1.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-190681eac4fd5da5.js" defer=""></script><script src="/_next/static/nopaLiXveJeQGAptlxv-U/_buildManifest.js" defer=""></script><script src="/_next/static/nopaLiXveJeQGAptlxv-U/_ssgManifest.js" defer=""></script><script src="/_next/static/nopaLiXveJeQGAptlxv-U/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div><a href="/">Misc scribbles</a></div><article><div><h1>Structural variants and the SAM format - the long (reads) and short (reads) of it</h1><h4>2022-02-06</h4></div><p>The <code>SAM</code> specification is pretty amazing
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a> but it is also fairly terse and
abstract, and true understanding comes from playing with real world data but I
will try to explain some stuff I have learned about reads, especially as they
relate to structural variants.</p><p>Disclaimer: I&#x27;m a developer of JBrowse 2. This document has some screenshots
and links for it, feel free to try it at <a href="https://jbrowse.org">https://jbrowse.org</a></p><p>Also note: When I refer to a <code>SAM</code> record in this document, it could come from
a <code>SAM</code>, <code>BAM</code>, or <code>CRAM</code> file as <code>BAM</code> and <code>CRAM</code> are just alternative
encodings of <code>SAM</code></p><h2>Basics</h2><h3>What is a <code>SAM</code> file and how does it relate to <code>BAM</code> and <code>CRAM</code>?</h3><p>A <code>SAM</code> file contains &quot;reads&quot; from a sequencer. The &quot;reads&quot; often originally
are from <code>FASTQ</code> format files. The reads from <code>FASTQ</code> format are inputted into
an aligner such as <code>bwa</code>, <code>bowtie</code>, <code>minimap2</code> (there are many others) which
map the reads to a reference genome, and output <code>SAM</code> format.</p><p><code>SAM</code> is a text format that you can read with your text editor. <code>BAM</code> and
<code>CRAM</code> are compressed representations of the <code>SAM</code> format, and you can use
<code>samtools view -h yourfile.bam</code> or <code>samtools view -h yourfile.cram</code> to convert
them back to <code>SAM</code>.</p><h3>What is in a <code>SAM</code> file</h3><p>A <code>SAM</code> file contains a header and series of records. <code>SAM</code> record is a single
line in the file. A <code>SAM</code> record generally corresponds to a single read, but as
we will see, a split alignment may produce multiple <code>SAM</code> records that refer to
the same source read.</p><p>Note: you can also store unaligned data in <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> (so-called uBAM
for example) but most of the time, the reads in <code>SAM</code> format are aligned to a
reference genome.</p><p>Also note: if a read failed to align to the reference genome, it may still be
in your <code>SAM</code> file, it will just be marked as unmapped. Sometimes, &quot;dumpster
diving&quot; (looking at the unmapped records from a <code>SAM</code> file) can reveal
structural variants.</p><h3>Bonus: Converting <code>SAM</code> to <code>BAM</code> or <code>CRAM</code></h3><p>I often find myself googling this, but conversion of <code>SAM</code> to <code>BAM</code> or <code>CRAM</code> is easy</p><p>Convert <code>SAM</code> to <code>BAM</code></p><pre><code>samtools view file.sam -o file.bam
</code></pre><p>Convert <code>SAM</code> to <code>CRAM</code></p><pre><code>samtools view -T reference.fa file.sam -o file.cram
</code></pre><h3>What is a <code>CIGAR</code> string</h3><p>A <code>CIGAR</code> string is a &quot;compact idiosyncratic gapped alignment report&quot;. Yes,
that&#x27;s an acronym. It can tell you where insertions and deletions are in an
alignment. Some <code>CIGAR</code> strings tell you where mismatches are (so-called
extended CIGAR, with the <code>X</code> indicating mismatches and &#x27;=&#x27; indicating matches),
but I don&#x27;t often see this.</p><p>One thing I would recommend: don&#x27;t fear the CIGAR (bioinformatics)</p><p>If you are working with <code>SAM</code> data, you will often write loops that directly parse CIGAR strings</p><p>Handy functions</p><pre><code class="language-typescript">function parseCigar(cigar: string) {
  return cigar.split(/([MIDNSHPX=])/)
}
</code></pre><p>Then parse the returned array two at a time</p><pre><code class="language-typescript">// this function does nothing, but is informative for how to parse interpret a
// CIGAR string
// @param cigar:CIGAR string from record
// @param readSeq: the SEQ from record
// @param refSeq: the reference sequence underlying the read
function interpretCigar(cigar: string, readSeq: string, refSeq: string) {
  const opts = parseCigar(cigar)
  let queryPosition = 0
  let targetPosition = 0
  for (let i = 0; i &lt; ops.length - 1; i += 2) {
    const length = parseInt(opts[i], 10)
    const operator = opts[i + 1]
    // do things. refer to the CIGAR chart in SAMv1.pdf for which operators &quot;consume reference&quot; to see whether to increment
    if (op === &#x27;M&#x27; || op === &#x27;=&#x27;) {
      // matches consume query and reference
      qpos += len
      tpos += len
    }
    if (op === &#x27;I&#x27;) {
      // insertions only consume query
      // sequence of the insertion from the read is
      const insSeq = readSeq.slice(qpos, qpos + len)
      qpos += len
    }
    if (op === &#x27;D&#x27;) {
      // deletions only consume reference
      // sequence of the deletion from the reference is
      const delSeq = refSeq.slice(tpos, tpos + len)
      tpad += len
    }
    if (op === &#x27;N&#x27;) {
      // skips only consume reference
      // skips are similar to deletions but are related to spliced alignments
      tpad += len
    }
    if (op === &#x27;X&#x27;) {
      // mismatch using the extended CIGAR format
      // could lookup the mismatch letter in a string containing the reference
      const mismatch = refSeq.slice(tpos, tpos + len)
      qpos += len
      tpos += len
    }
    if (op === &#x27;H&#x27;) {
      // does not consume query or reference
      // hardclip is just an indicator
    }
    if (op === &#x27;S&#x27;) {
      // softclip consumes query, contents of the softclip is
      const softClipStr = readSeq.slice(qpos, qpos + len)
      qpos += len
    }
  }
}
</code></pre><h3>What is an <code>MD</code> string</h3><p>An <code>MD</code> string is a tag in <code>SAM</code> file that helps tell you where the mismatches
are, and can be combined with a <code>CIGAR</code> to get the position of the mismatches
without looking at a reference genome.</p><p>The <code>MD</code> string is commonly seen in <code>BAM</code> files (not generally <code>CRAM</code> because
it already uses reference compression and requires a reference sequence to
decode). The <code>MD</code> tag contains information about deletions (including the bases
of the reference genome, which would otherwise not be indicated) and mismatches
(same, indicating the base of the reference genome at a SNPs position), but not
insertions.</p><p>The command <code>samtools calmd yourfile.bam --reference reference.fa</code> can add <code>MD</code>
tags to your <code>BAM</code> file. Note that there are some oddities about <code>MD</code> tags
leading to complaints (e.g. <a href="https://github.com/samtools/hts-specs/issues/505">https://github.com/samtools/hts-specs/issues/505</a>)
but it the <code>MD</code> tag can be helpful if you want to decode a file without
referring to it&#x27;s reference.</p><h2>Detecting SVs from long reads</h2><h3>What are split alignments?</h3><p>Split alignments, or chimeric alignments, are alignments where part of the read
aligns to perhaps chr1, and part of it maps to perhaps chr4. It is worth
reading the definition of &quot;Chimeric alignment&quot; from
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> when you get the
chance.</p><p>Split alignments are especially common with long reads, and it can indicate
that there may be a structural variant where the two chromosomes are fused
together (which may create gene fusions, or other types of phenomena).</p><p>There is no limitation on how many splits might occur so the split can align to
3, 4, or more different places. Each part of the split puts a new line in the
SAM file, and note that all the records also have the same <code>QNAME</code> (first
column of <code>SAM</code>). As SAMv1.pdf tells us, one record is marked as
&quot;representative&quot;, I call this the &quot;primary&quot; record, while the other components
of the split read are maked supplementary, given the 2048 flag. Only the
&quot;primary&quot; record generally has a <code>SEQ</code> field.</p><p>Note: split alignments are different from &quot;multi-mappers&quot; where the entire read
maps maps equally well to, say, chr4 and chr1. Split reads maps part to chr1,
and part to chr4. See again the
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> for the definition
of multi-mapping</p><h3>What is the <code>SA</code> tag?</h3><p>The <code>SA</code> tag is outputted on each part of the split alignment, e.g. the primary
contains an <code>SA</code> tag that refers to all the locations, <code>CIGAR</code> strings, and
more for all the supplementary reads, and each of the supplementary reads also
contains an <code>SA</code> tag that refers to the primary alignment and each other
supplementary alignment.</p><p>Fun fact: The <code>SA</code> tag conceptually can result in a &#x27;quadratic explosion&#x27; of
data, because each part of the split contains references to every other part.
For example, if a read is split into 4 pieces, then each record would would
have an SA tag with 3 segments, so 3<!-- -->*<!-- -->4 segments will be documented in the<code>SA</code>
tag.</p><h3>Reconstructing a split alignment given the primary alignment</h3><p>If we are given the the primary alignment of an arbitrary split read, then we
can construct what that split looks like compared to the reference genome.</p><p>If we are not given the primary alignment (e.g. we are starting from a
supplementary alignment) then we can search the <code>SA</code> list for the one that is
primary, because at least one will be.</p><p>Now that we have the primary alignment, it will have the <code>SEQ</code> (of the entire
read, the supplementary alignments typically have a blank <code>SEQ</code>!) and the <code>SA</code>
tag containing the <code>CIGAR</code> of all the different parts of the split. We can then
construct how the entire read, not just a particular record of the split
alignment, compares to the genome. In JBrowse 2 we implemented this and it uses
a synteny-style rendering. This functionality also exists in GenomeRibbon
(<a href="https://genomeribbon.org">https://genomeribbon.org</a>)</p><p><img src="/media/linear_alignment.png"/></p><p>Figure showing JBrowse 2 piecing together a long read vs the reference genome
from a single read</p><p>In order to do this reconstruction, it takes the <code>CIGAR</code> strings of the primary
alignment and each of the pieces of the <code>SA</code> tag (it is a semi-colon separated
list of chunks), sort them by the amount of softclipping (the softclipping
values will progressively trim off more of the <code>SEQ</code> telling you it aligned
further and further on in the long read), and then this tells me where each
piece of the split alignment came from in the original <code>SEQ</code>, so we can plot
the alignments of the read vs the reference genome using synteny style display.</p><h3>SAM vs VCF - Breakends vs split alignments</h3><p>An interesting outcome (to me) is that from a single record in a <code>SAM</code> file, I
can reconstruct the &quot;derived&quot; genome around a region of interest from a single
read.</p><p>If I was to try to do this with the <code>VCF</code> Breakend specification (section 5.4
of <a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">VCF4.3.pdf</a>), it may
actually be more challenging than from a <code>SAM</code> read. This is because a Breakend
in <code>VCF</code> format is only an edge in a graph (and the sequences are nodes).
Therefore, in order to properly reconstruct a structural variant from a <code>VCF</code>
with Breakends, I would have to construct a graph and decode paths through it.</p><p>I like the ability to reconstruct the derived genome from a single read, but it
can be noisy. That said, de novo assembled contigs can also be stored in <code>SAM</code>
format and is significantly less noisy (being composed of the aggregate
information of many reads).</p><p>The point though is that interpretation of the <code>VCF</code> breakend specification is
challenging due to imposing a sequence graph on the genome, while the <code>SA</code> tag
remains just a simple set of linear alignments that can easily be pieced
together, and you only need to refer to a single record in the <code>SAM</code> file to do
so.</p><p>I am not aware of a lot of tools that work on the VCF Breakend graph, and
expect more will need to be created to truly work with this standard. An
inversion for example may create 4 record in the VCF file (see section 5.4 in
the <a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">VCF4.3.pdf</a> for
example), and needs careful interpretation.</p><h3>Haplotype tagged reads</h3><p>A new trend has been to create <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> files with tagged reads,
which tells us which haplotype a read was inferred to have come from. This is
commonly done with the <code>HP</code> tag, which might have <code>HP=0</code> and <code>HP=1</code> for a
diploid genome. Tools like <code>whatshap</code> can add these tags to a <code>SAM</code> file, and
IGV and JBrowse 2 can color and sort by these tags.</p><p><img src="/media/color_by_tag.png"/></p><p>Screenshot of JBrowse 2 with the &quot;Color by tag&quot; and &quot;Sort by tag&quot; setting
enabled (coloring and sorting by the HP tag) letting us see that only one
haplotype has a deletion. Tutorial for how to do this in JBrowse 2 here
<a href="https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag">https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag</a></p><h2>How do you detect SVs with paired-end reads?</h2><p>Paired-end reads are short reads, e.g. 150bp each. This makes them unable to
recover some large structural variants.</p><p>However, paired-end reads have a number of attributes that can be used to
detect paired end reads</p><h3>Distance between pairs being abnormally large or short</h3><p>The distance between pairs is encoded by the <code>TLEN</code> column in the <code>SAM</code> format.
The distance between pairs with good mapping is relatively constant and called
the &quot;insert length&quot;. This comes from how the sequencing is done: paired-end
sequencing performs sequencing on both ends of a fragment.</p><p>But, if you are mapping reads vs the reference genome, and you observe that
they are abnormally far apart, say 50kb apart instead of 1kb apart, this may
indicate there your sample contains a deletion relative to the reference.</p><p><img src="/media/aberrant_size.png"/></p><p>Screenshot of JBrowse 1 with &quot;View as pairs&quot; enabled, and large insert size
colored as red (from <a href="https://jbrowse.org/docs/paired_reads.html">https://jbrowse.org/docs/paired_reads.html</a>). Note that
some of JBrowse 1&#x27;s View as pairs features are not yet available in JBrowse 2</p><h3>An abundance of reads being &quot;clipped&quot; at a particular position</h3><p>This can indicate that part of the reads map well, but then there was an abrupt
stop to the mapping. This might mean that there is a sequence that was an
insertion at that position, or a deletion, or a translocation.</p><p>The clipping is indicated by the <code>CIGAR</code> string, either at the start or end of
it by an <code>S</code> or an <code>H</code>. The <code>S</code> indicates &quot;soft clipping&quot;, and indicates that
the sequence of the clipped portion can be found in the <code>SEQ</code> field of the
primary alignment. The <code>H</code> is hard clipped, and the sequence that is hard
clipped will not appear in the <code>SEQ</code>.</p><p>You can visualize an excess of clipping in JBrowse 2, which creates an inverted
histogram at a particular position</p><p><img src="/media/clipping_pileup.png"/></p><p>Screenshot of JBrowse 2 showing blue clipping indicator with a &quot;pileup&quot; of soft-clipping at a particular position shown in blue.</p><p><img src="/media/show_soft_clipping.png"/></p><p>Screenshot of JBrowse 2 showing an insertion with both long reads and short
reads. With long reads, the read may completely span the insertion, so the
CIGAR string simply indicates a large <code>I</code> operator (purple indicator on track),
but for short reads, the reads near the insertion will be clipped since they
will not properly map to the reference genome. The &quot;Show soft clipping&quot; setting
in JBrowse 2 and IGV can be used to show visually the bases that extend into
the insertion (shown on the bottom track).</p><h3>Unexpected pair orientation</h3><p>With standard paired end sequencing, the pairs normally point at each other</p><pre><code>forward reverse
 ---&gt;    &lt;---
</code></pre><p>If the stranded-ness of the pair is off, then it could indicate a structural variant</p><p>This guide from IGV is helpful for interpreting the pair directionality with
patterns of SVs using &quot;Color by pair orientation&quot;</p><p><a href="https://software.broadinstitute.org/software/igv/interpreting_pair_orientations">https://software.broadinstitute.org/software/igv/interpreting_pair_orientations</a></p><p><img src="/media/inverted_duplication.png"/></p><p>Figure: This shows an inverted (tandem) duplication in 1000 genomes data. The
tandem duplication can produce green arrows which have reads pointing in
opposite directions e.g. <code>&lt;--</code> and <code>--&gt;</code>, while blue arrows which can indicate
an inversion point in the same direction e.g. <code>--&gt;</code> and <code>--&gt;</code></p><h3>Caveat about TLEN</h3><p>Note that <code>TLEN</code> is a field in the SAM format that is somewhat ill defined,
at least in the sense that different tools may use it differently
<a href="https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767">https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767</a></p><p>If needed, you can calculate <code>TLEN</code> yourself if you process the file yourself
(e.g. process all reads, get the actual records for the pairs, and calculate
distance) but I have not had trouble with relying on the <code>TLEN</code> from the data
files themselves.</p><h2>Calling copy number variants with your short or long reads</h2><p>Another type of SV that you can get from your <code>SAM</code> files are copy number
variants (CNVs). By looking at the depth-of-coverage for your data files, you
can look for abnormalities that may indicate copy number variants. By using a
tool like <code>mosdepth</code>, you can quickly get a file showing the coverage across
the genome.</p><p>Be aware that if you are comparing the coverage counts from different tools,
that they have different defaults that may affect comparison. Some discard
<code>QC_FAIL</code>, <code>DUP</code>, and <code>SECONDARY</code> flagged reads. This is probably appropriate,
and corresponds to what most genome browsers will display (see
<a href="https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af">https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af</a> for a short
summary of depth calculated from different tools)</p><p>Note that both long and short reads can be used for CNV detection. Long reads
may give more accurate measurements also, with their better ability to map
smoothly through difficult regions of the genome.</p><p><img src="/media/coverage_cnv.png"/></p><p>Screenshot showing coverage in BigWig format from nanopore reads on normal and
tumor tissue from a melanoma cancer cell line (COLO829) plotted using JBrowse 2
(<a href="https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json&amp;session=share-MZj3d18lzH&amp;password=3X7bS">demo</a>
and
<a href="https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv">tutorial</a>)</p><h2>The future, with graph genomes and de-novo assemblies</h2><p>Currently, SV visualization is highly based on comparing data versus a
reference genome (and the SAM format is a signature of this: it stores data in
terms of reference genome coordinates). In the future, SV visualization may
look more similar to comparative genomics, where we compare the an SV to a
population specific reference or something like this.</p><p>It is known that de-novo assembly has more power to detect SVs than some read
operations (<a href="https://twitter.com/lh3lh3/status/1362921612690010118/photo/1">https://twitter.com/lh3lh3/status/1362921612690010118/photo/1</a>) so
as de novo assembled genomes improve and become more widespread, we may see a
shift in how SVs are called</p><p>I would also like to see improved ability to do fast and accurate gene
prediction so that the structure of genes can be predicted quickly on the de
novo assembled genomes, and we can see what SNPs or modified splicing might
occur in CNV copies of genes.</p><h2>Conclusion</h2><p>Algorithms that actually call structural variants face many challenges, but
understanding how the reads are encoded in SAM format, and seeing what they
look like in the genome browser is a useful first step to gaining a better
understanding.</p><p>In summary, some of the signatures of SVs may include:</p><ul><li>Aberrant insert size (<code>TLEN</code>) detection (longer for deletion, shorter for insertion)</li><li>Split-read detection (<code>SA</code> tag)</li><li>CIGAR string processing (<code>D</code> operator for deletions, <code>I</code> operator for insertions)</li><li>Over-abundance of clipping (<code>S</code> or <code>H</code> operators in <code>CIGAR</code>)</li><li>Depth of coverage changes for CNVs</li><li>Aligning de-novo assembly vs a reference genome (<a href="https://twitter.com/lh3lh3/status/1362921612690010118/photo/1">https://twitter.com/lh3lh3/status/1362921612690010118/photo/1</a>) which can output <code>SAM</code>, but it can also output <a href="https://github.com/lh3/miniasm/blob/master/PAF.md"><code>PAF</code></a> format (which can be loaded in JBrowse 2 in the synteny views)</li></ul><p>If you have any ideas that you want to contribute to this blog post let me know!</p></article></div></main></div><footer style="margin-top:20px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Structural variants and the SAM format - the long (reads) and short (reads) of it","date":"2022-02-06","slug":"2022-02-06-sv-sam","mdxSource":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var p=(n,i,t)=\u003ei in n?h(n,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[i]=t,e=(n,i)=\u003e{for(var t in i||(i={}))r.call(i,t)\u0026\u0026p(n,t,i[t]);if(o)for(var t of o(i))s.call(i,t)\u0026\u0026p(n,t,i[t]);return n},l=(n,i)=\u003em(n,c(i));var d=(n,i)=\u003e{var t={};for(var a in n)r.call(n,a)\u0026\u0026i.indexOf(a)\u003c0\u0026\u0026(t[a]=n[a]);if(n!=null\u0026\u0026o)for(var a of o(n))i.indexOf(a)\u003c0\u0026\u0026s.call(n,a)\u0026\u0026(t[a]=n[a]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var a=t,{components:n}=a,i=d(a,[\"components\"]);return mdx(MDXLayout,l(e(e({},layoutProps),i),{components:n,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` specification is pretty amazing\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"https://samtools.github.io/hts-specs/SAMv1.pdf\"),` but it is also fairly terse and\nabstract, and true understanding comes from playing with real world data but I\nwill try to explain some stuff I have learned about reads, especially as they\nrelate to structural variants.`),mdx(\"p\",null,`Disclaimer: I'm a developer of JBrowse 2. This document has some screenshots\nand links for it, feel free to try it at `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org\"}),\"https://jbrowse.org\")),mdx(\"p\",null,\"Also note: When I refer to a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record in this document, it could come from\na `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\", or \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" file as \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` are just alternative\nencodings of `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\")),mdx(\"h2\",null,\"Basics\"),mdx(\"h3\",null,\"What is a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" file and how does it relate to \",mdx(\"inlineCode\",{parentName:\"h3\"},\"BAM\"),\" and \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CRAM\"),\"?\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file contains \"reads\" from a sequencer. The \"reads\" often originally\nare from `,mdx(\"inlineCode\",{parentName:\"p\"},\"FASTQ\"),\" format files. The reads from \",mdx(\"inlineCode\",{parentName:\"p\"},\"FASTQ\"),` format are inputted into\nan aligner such as `,mdx(\"inlineCode\",{parentName:\"p\"},\"bwa\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"bowtie\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"minimap2\"),` (there are many others) which\nmap the reads to a reference genome, and output `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" format.\"),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" is a text format that you can read with your text editor. \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),` and\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" are compressed representations of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format, and you can use\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"samtools view -h yourfile.bam\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"samtools view -h yourfile.cram\"),` to convert\nthem back to `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\".\"),mdx(\"h3\",null,\"What is in a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" file\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" file contains a header and series of records. \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record is a single\nline in the file. A `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record generally corresponds to a single read, but as\nwe will see, a split alignment may produce multiple `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` records that refer to\nthe same source read.`),mdx(\"p\",null,\"Note: you can also store unaligned data in \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` (so-called uBAM\nfor example) but most of the time, the reads in `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format are aligned to a\nreference genome.`),mdx(\"p\",null,`Also note: if a read failed to align to the reference genome, it may still be\nin your `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, it will just be marked as unmapped. Sometimes, \"dumpster\ndiving\" (looking at the unmapped records from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file) can reveal\nstructural variants.`),mdx(\"h3\",null,\"Bonus: Converting \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" to \",mdx(\"inlineCode\",{parentName:\"h3\"},\"BAM\"),\" or \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CRAM\")),mdx(\"p\",null,\"I often find myself googling this, but conversion of \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" is easy\"),mdx(\"p\",null,\"Convert \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`samtools view file.sam -o file.bam\n`)),mdx(\"p\",null,\"Convert \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`samtools view -T reference.fa file.sam -o file.cram\n`)),mdx(\"h3\",null,\"What is a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CIGAR\"),\" string\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` string is a \"compact idiosyncratic gapped alignment report\". Yes,\nthat's an acronym. It can tell you where insertions and deletions are in an\nalignment. Some `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings tell you where mismatches are (so-called\nextended CIGAR, with the `,mdx(\"inlineCode\",{parentName:\"p\"},\"X\"),` indicating mismatches and '=' indicating matches),\nbut I don't often see this.`),mdx(\"p\",null,\"One thing I would recommend: don't fear the CIGAR (bioinformatics)\"),mdx(\"p\",null,\"If you are working with \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" data, you will often write loops that directly parse CIGAR strings\"),mdx(\"p\",null,\"Handy functions\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`function parseCigar(cigar: string) {\n  return cigar.split(/([MIDNSHPX=])/)\n}\n`)),mdx(\"p\",null,\"Then parse the returned array two at a time\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`// this function does nothing, but is informative for how to parse interpret a\n// CIGAR string\n// @param cigar:CIGAR string from record\n// @param readSeq: the SEQ from record\n// @param refSeq: the reference sequence underlying the read\nfunction interpretCigar(cigar: string, readSeq: string, refSeq: string) {\n  const opts = parseCigar(cigar)\n  let queryPosition = 0\n  let targetPosition = 0\n  for (let i = 0; i \u003c ops.length - 1; i += 2) {\n    const length = parseInt(opts[i], 10)\n    const operator = opts[i + 1]\n    // do things. refer to the CIGAR chart in SAMv1.pdf for which operators \"consume reference\" to see whether to increment\n    if (op === 'M' || op === '=') {\n      // matches consume query and reference\n      qpos += len\n      tpos += len\n    }\n    if (op === 'I') {\n      // insertions only consume query\n      // sequence of the insertion from the read is\n      const insSeq = readSeq.slice(qpos, qpos + len)\n      qpos += len\n    }\n    if (op === 'D') {\n      // deletions only consume reference\n      // sequence of the deletion from the reference is\n      const delSeq = refSeq.slice(tpos, tpos + len)\n      tpad += len\n    }\n    if (op === 'N') {\n      // skips only consume reference\n      // skips are similar to deletions but are related to spliced alignments\n      tpad += len\n    }\n    if (op === 'X') {\n      // mismatch using the extended CIGAR format\n      // could lookup the mismatch letter in a string containing the reference\n      const mismatch = refSeq.slice(tpos, tpos + len)\n      qpos += len\n      tpos += len\n    }\n    if (op === 'H') {\n      // does not consume query or reference\n      // hardclip is just an indicator\n    }\n    if (op === 'S') {\n      // softclip consumes query, contents of the softclip is\n      const softClipStr = readSeq.slice(qpos, qpos + len)\n      qpos += len\n    }\n  }\n}\n`)),mdx(\"h3\",null,\"What is an \",mdx(\"inlineCode\",{parentName:\"h3\"},\"MD\"),\" string\"),mdx(\"p\",null,\"An \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),\" string is a tag in \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file that helps tell you where the mismatches\nare, and can be combined with a `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` to get the position of the mismatches\nwithout looking at a reference genome.`),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),\" string is commonly seen in \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" files (not generally \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` because\nit already uses reference compression and requires a reference sequence to\ndecode). The `,mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),` tag contains information about deletions (including the bases\nof the reference genome, which would otherwise not be indicated) and mismatches\n(same, indicating the base of the reference genome at a SNPs position), but not\ninsertions.`),mdx(\"p\",null,\"The command \",mdx(\"inlineCode\",{parentName:\"p\"},\"samtools calmd yourfile.bam --reference reference.fa\"),\" can add \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),`\ntags to your `,mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" file. Note that there are some oddities about \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),` tags\nleading to complaints (e.g. `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/samtools/hts-specs/issues/505\"}),\"https://github.com/samtools/hts-specs/issues/505\"),`)\nbut it the `,mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),` tag can be helpful if you want to decode a file without\nreferring to it's reference.`),mdx(\"h2\",null,\"Detecting SVs from long reads\"),mdx(\"h3\",null,\"What are split alignments?\"),mdx(\"p\",null,`Split alignments, or chimeric alignments, are alignments where part of the read\naligns to perhaps chr1, and part of it maps to perhaps chr4. It is worth\nreading the definition of \"Chimeric alignment\" from\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"SAMv1.pdf\"),` when you get the\nchance.`),mdx(\"p\",null,`Split alignments are especially common with long reads, and it can indicate\nthat there may be a structural variant where the two chromosomes are fused\ntogether (which may create gene fusions, or other types of phenomena).`),mdx(\"p\",null,`There is no limitation on how many splits might occur so the split can align to\n3, 4, or more different places. Each part of the split puts a new line in the\nSAM file, and note that all the records also have the same `,mdx(\"inlineCode\",{parentName:\"p\"},\"QNAME\"),` (first\ncolumn of `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),`). As SAMv1.pdf tells us, one record is marked as\n\"representative\", I call this the \"primary\" record, while the other components\nof the split read are maked supplementary, given the 2048 flag. Only the\n\"primary\" record generally has a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\" field.\"),mdx(\"p\",null,`Note: split alignments are different from \"multi-mappers\" where the entire read\nmaps maps equally well to, say, chr4 and chr1. Split reads maps part to chr1,\nand part to chr4. See again the\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"SAMv1.pdf\"),` for the definition\nof multi-mapping`),mdx(\"h3\",null,\"What is the \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SA\"),\" tag?\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag is outputted on each part of the split alignment, e.g. the primary\ncontains an `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),\" tag that refers to all the locations, \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings, and\nmore for all the supplementary reads, and each of the supplementary reads also\ncontains an `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag that refers to the primary alignment and each other\nsupplementary alignment.`),mdx(\"p\",null,\"Fun fact: The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag conceptually can result in a 'quadratic explosion' of\ndata, because each part of the split contains references to every other part.\nFor example, if a read is split into 4 pieces, then each record would would\nhave an SA tag with 3 segments, so 3`,\"*\",\"4 segments will be documented in the\",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),`\ntag.`),mdx(\"h3\",null,\"Reconstructing a split alignment given the primary alignment\"),mdx(\"p\",null,`If we are given the the primary alignment of an arbitrary split read, then we\ncan construct what that split looks like compared to the reference genome.`),mdx(\"p\",null,`If we are not given the primary alignment (e.g. we are starting from a\nsupplementary alignment) then we can search the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` list for the one that is\nprimary, because at least one will be.`),mdx(\"p\",null,\"Now that we have the primary alignment, it will have the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` (of the entire\nread, the supplementary alignments typically have a blank `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\"!) and the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),`\ntag containing the `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` of all the different parts of the split. We can then\nconstruct how the entire read, not just a particular record of the split\nalignment, compares to the genome. In JBrowse 2 we implemented this and it uses\na synteny-style rendering. This functionality also exists in GenomeRibbon\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://genomeribbon.org\"}),\"https://genomeribbon.org\"),\")\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/linear_alignment.png\",alt:null}))),mdx(\"p\",null,`Figure showing JBrowse 2 piecing together a long read vs the reference genome\nfrom a single read`),mdx(\"p\",null,\"In order to do this reconstruction, it takes the \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings of the primary\nalignment and each of the pieces of the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag (it is a semi-colon separated\nlist of chunks), sort them by the amount of softclipping (the softclipping\nvalues will progressively trim off more of the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` telling you it aligned\nfurther and further on in the long read), and then this tells me where each\npiece of the split alignment came from in the original `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),`, so we can plot\nthe alignments of the read vs the reference genome using synteny style display.`),mdx(\"h3\",null,\"SAM vs VCF - Breakends vs split alignments\"),mdx(\"p\",null,\"An interesting outcome (to me) is that from a single record in a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, I\ncan reconstruct the \"derived\" genome around a region of interest from a single\nread.`),mdx(\"p\",null,\"If I was to try to do this with the \",mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` Breakend specification (section 5.4\nof `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/VCFv4.3.pdf\"}),\"VCF4.3.pdf\"),`), it may\nactually be more challenging than from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` read. This is because a Breakend\nin `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` format is only an edge in a graph (and the sequences are nodes).\nTherefore, in order to properly reconstruct a structural variant from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),`\nwith Breakends, I would have to construct a graph and decode paths through it.`),mdx(\"p\",null,`I like the ability to reconstruct the derived genome from a single read, but it\ncan be noisy. That said, de novo assembled contigs can also be stored in `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),`\nformat and is significantly less noisy (being composed of the aggregate\ninformation of many reads).`),mdx(\"p\",null,\"The point though is that interpretation of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` breakend specification is\nchallenging due to imposing a sequence graph on the genome, while the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag\nremains just a simple set of linear alignments that can easily be pieced\ntogether, and you only need to refer to a single record in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file to do\nso.`),mdx(\"p\",null,`I am not aware of a lot of tools that work on the VCF Breakend graph, and\nexpect more will need to be created to truly work with this standard. An\ninversion for example may create 4 record in the VCF file (see section 5.4 in\nthe `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/VCFv4.3.pdf\"}),\"VCF4.3.pdf\"),` for\nexample), and needs careful interpretation.`),mdx(\"h3\",null,\"Haplotype tagged reads\"),mdx(\"p\",null,\"A new trend has been to create \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` files with tagged reads,\nwhich tells us which haplotype a read was inferred to have come from. This is\ncommonly done with the `,mdx(\"inlineCode\",{parentName:\"p\"},\"HP\"),\" tag, which might have \",mdx(\"inlineCode\",{parentName:\"p\"},\"HP=0\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"HP=1\"),` for a\ndiploid genome. Tools like `,mdx(\"inlineCode\",{parentName:\"p\"},\"whatshap\"),\" can add these tags to a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, and\nIGV and JBrowse 2 can color and sort by these tags.`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/color_by_tag.png\",alt:null}))),mdx(\"p\",null,`Screenshot of JBrowse 2 with the \"Color by tag\" and \"Sort by tag\" setting\nenabled (coloring and sorting by the HP tag) letting us see that only one\nhaplotype has a deletion. Tutorial for how to do this in JBrowse 2 here\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\"}),\"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\")),mdx(\"h2\",null,\"How do you detect SVs with paired-end reads?\"),mdx(\"p\",null,`Paired-end reads are short reads, e.g. 150bp each. This makes them unable to\nrecover some large structural variants.`),mdx(\"p\",null,`However, paired-end reads have a number of attributes that can be used to\ndetect paired end reads`),mdx(\"h3\",null,\"Distance between pairs being abnormally large or short\"),mdx(\"p\",null,\"The distance between pairs is encoded by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),\" column in the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format.\nThe distance between pairs with good mapping is relatively constant and called\nthe \"insert length\". This comes from how the sequencing is done: paired-end\nsequencing performs sequencing on both ends of a fragment.`),mdx(\"p\",null,`But, if you are mapping reads vs the reference genome, and you observe that\nthey are abnormally far apart, say 50kb apart instead of 1kb apart, this may\nindicate there your sample contains a deletion relative to the reference.`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/aberrant_size.png\",alt:null}))),mdx(\"p\",null,`Screenshot of JBrowse 1 with \"View as pairs\" enabled, and large insert size\ncolored as red (from `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/docs/paired_reads.html\"}),\"https://jbrowse.org/docs/paired_reads.html\"),`). Note that\nsome of JBrowse 1's View as pairs features are not yet available in JBrowse 2`),mdx(\"h3\",null,'An abundance of reads being \"clipped\" at a particular position'),mdx(\"p\",null,`This can indicate that part of the reads map well, but then there was an abrupt\nstop to the mapping. This might mean that there is a sequence that was an\ninsertion at that position, or a deletion, or a translocation.`),mdx(\"p\",null,\"The clipping is indicated by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` string, either at the start or end of\nit by an `,mdx(\"inlineCode\",{parentName:\"p\"},\"S\"),\" or an \",mdx(\"inlineCode\",{parentName:\"p\"},\"H\"),\". The \",mdx(\"inlineCode\",{parentName:\"p\"},\"S\"),` indicates \"soft clipping\", and indicates that\nthe sequence of the clipped portion can be found in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` field of the\nprimary alignment. The `,mdx(\"inlineCode\",{parentName:\"p\"},\"H\"),` is hard clipped, and the sequence that is hard\nclipped will not appear in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\".\"),mdx(\"p\",null,`You can visualize an excess of clipping in JBrowse 2, which creates an inverted\nhistogram at a particular position`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/clipping_pileup.png\",alt:null}))),mdx(\"p\",null,'Screenshot of JBrowse 2 showing blue clipping indicator with a \"pileup\" of soft-clipping at a particular position shown in blue.'),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/show_soft_clipping.png\",alt:null}))),mdx(\"p\",null,`Screenshot of JBrowse 2 showing an insertion with both long reads and short\nreads. With long reads, the read may completely span the insertion, so the\nCIGAR string simply indicates a large `,mdx(\"inlineCode\",{parentName:\"p\"},\"I\"),` operator (purple indicator on track),\nbut for short reads, the reads near the insertion will be clipped since they\nwill not properly map to the reference genome. The \"Show soft clipping\" setting\nin JBrowse 2 and IGV can be used to show visually the bases that extend into\nthe insertion (shown on the bottom track).`),mdx(\"h3\",null,\"Unexpected pair orientation\"),mdx(\"p\",null,\"With standard paired end sequencing, the pairs normally point at each other\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`forward reverse\n ---\u003e    \u003c---\n`)),mdx(\"p\",null,\"If the stranded-ness of the pair is off, then it could indicate a structural variant\"),mdx(\"p\",null,`This guide from IGV is helpful for interpreting the pair directionality with\npatterns of SVs using \"Color by pair orientation\"`),mdx(\"p\",null,mdx(\"a\",e({parentName:\"p\"},{href:\"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"}),\"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\")),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/inverted_duplication.png\",alt:null}))),mdx(\"p\",null,`Figure: This shows an inverted (tandem) duplication in 1000 genomes data. The\ntandem duplication can produce green arrows which have reads pointing in\nopposite directions e.g. `,mdx(\"inlineCode\",{parentName:\"p\"},\"\u003c--\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"--\u003e\"),`, while blue arrows which can indicate\nan inversion point in the same direction e.g. `,mdx(\"inlineCode\",{parentName:\"p\"},\"--\u003e\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"--\u003e\")),mdx(\"h3\",null,\"Caveat about TLEN\"),mdx(\"p\",null,\"Note that \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` is a field in the SAM format that is somewhat ill defined,\nat least in the sense that different tools may use it differently\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\"}),\"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\")),mdx(\"p\",null,\"If needed, you can calculate \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` yourself if you process the file yourself\n(e.g. process all reads, get the actual records for the pairs, and calculate\ndistance) but I have not had trouble with relying on the `,mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` from the data\nfiles themselves.`),mdx(\"h2\",null,\"Calling copy number variants with your short or long reads\"),mdx(\"p\",null,\"Another type of SV that you can get from your \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` files are copy number\nvariants (CNVs). By looking at the depth-of-coverage for your data files, you\ncan look for abnormalities that may indicate copy number variants. By using a\ntool like `,mdx(\"inlineCode\",{parentName:\"p\"},\"mosdepth\"),`, you can quickly get a file showing the coverage across\nthe genome.`),mdx(\"p\",null,`Be aware that if you are comparing the coverage counts from different tools,\nthat they have different defaults that may affect comparison. Some discard\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"QC_FAIL\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"DUP\"),\", and \",mdx(\"inlineCode\",{parentName:\"p\"},\"SECONDARY\"),` flagged reads. This is probably appropriate,\nand corresponds to what most genome browsers will display (see\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\"}),\"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\"),` for a short\nsummary of depth calculated from different tools)`),mdx(\"p\",null,`Note that both long and short reads can be used for CNV detection. Long reads\nmay give more accurate measurements also, with their better ability to map\nsmoothly through difficult regions of the genome.`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/coverage_cnv.png\",alt:null}))),mdx(\"p\",null,`Screenshot showing coverage in BigWig format from nanopore reads on normal and\ntumor tissue from a melanoma cancer cell line (COLO829) plotted using JBrowse 2\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json\u0026session=share-MZj3d18lzH\u0026password=3X7bS\"}),\"demo\"),`\nand\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv\"}),\"tutorial\"),\")\"),mdx(\"h2\",null,\"The future, with graph genomes and de-novo assemblies\"),mdx(\"p\",null,`Currently, SV visualization is highly based on comparing data versus a\nreference genome (and the SAM format is a signature of this: it stores data in\nterms of reference genome coordinates). In the future, SV visualization may\nlook more similar to comparative genomics, where we compare the an SV to a\npopulation specific reference or something like this.`),mdx(\"p\",null,`It is known that de-novo assembly has more power to detect SVs than some read\noperations (`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"}),\"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"),`) so\nas de novo assembled genomes improve and become more widespread, we may see a\nshift in how SVs are called`),mdx(\"p\",null,`I would also like to see improved ability to do fast and accurate gene\nprediction so that the structure of genes can be predicted quickly on the de\nnovo assembled genomes, and we can see what SNPs or modified splicing might\noccur in CNV copies of genes.`),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`Algorithms that actually call structural variants face many challenges, but\nunderstanding how the reads are encoded in SAM format, and seeing what they\nlook like in the genome browser is a useful first step to gaining a better\nunderstanding.`),mdx(\"p\",null,\"In summary, some of the signatures of SVs may include:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Aberrant insert size (\",mdx(\"inlineCode\",{parentName:\"li\"},\"TLEN\"),\") detection (longer for deletion, shorter for insertion)\"),mdx(\"li\",{parentName:\"ul\"},\"Split-read detection (\",mdx(\"inlineCode\",{parentName:\"li\"},\"SA\"),\" tag)\"),mdx(\"li\",{parentName:\"ul\"},\"CIGAR string processing (\",mdx(\"inlineCode\",{parentName:\"li\"},\"D\"),\" operator for deletions, \",mdx(\"inlineCode\",{parentName:\"li\"},\"I\"),\" operator for insertions)\"),mdx(\"li\",{parentName:\"ul\"},\"Over-abundance of clipping (\",mdx(\"inlineCode\",{parentName:\"li\"},\"S\"),\" or \",mdx(\"inlineCode\",{parentName:\"li\"},\"H\"),\" operators in \",mdx(\"inlineCode\",{parentName:\"li\"},\"CIGAR\"),\")\"),mdx(\"li\",{parentName:\"ul\"},\"Depth of coverage changes for CNVs\"),mdx(\"li\",{parentName:\"ul\"},\"Aligning de-novo assembly vs a reference genome (\",mdx(\"a\",e({parentName:\"li\"},{href:\"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"}),\"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"),\") which can output \",mdx(\"inlineCode\",{parentName:\"li\"},\"SAM\"),\", but it can also output \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/lh3/miniasm/blob/master/PAF.md\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"PAF\")),\" format (which can be loaded in JBrowse 2 in the synteny views)\")),mdx(\"p\",null,\"If you have any ideas that you want to contribute to this blog post let me know!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-02-06-sv-sam"},"buildId":"nopaLiXveJeQGAptlxv-U","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>