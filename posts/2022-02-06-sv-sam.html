<!DOCTYPE html><html lang="en"><head><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Structural variants and the SAM format - the long (reads) and short (reads) of it</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/f0ab904b10cea2d1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f0ab904b10cea2d1.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-d98b4a7f39fdfc80.js" defer=""></script><script src="/_next/static/chunks/pages/_app-76cd57bf65f05d70.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-190681eac4fd5da5.js" defer=""></script><script src="/_next/static/hu_1vi4ERKKV3-QuvTnTM/_buildManifest.js" defer=""></script><script src="/_next/static/hu_1vi4ERKKV3-QuvTnTM/_ssgManifest.js" defer=""></script><script src="/_next/static/hu_1vi4ERKKV3-QuvTnTM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><main><div><div><a href="/">Misc scribbles</a></div><article><div><h1>Structural variants and the SAM format - the long (reads) and short (reads) of it</h1><h4>2022-02-06</h4></div><p>The <code>SAM</code> specification is pretty amazing
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a> but it is also fairly terse and
abstract, and true understanding comes from playing with real world data but I
will try to explain some stuff I have learned about reads, especially as they
relate to structural variants.</p><p>Disclaimer: I&#x27;m a developer of JBrowse 2. This document has some screenshots
and links for it, feel free to try it at <a href="https://jbrowse.org">https://jbrowse.org</a></p><p>Also note: When I refer to a <code>SAM</code> record in this document, it could come from
a <code>SAM</code>, <code>BAM</code>, or <code>CRAM</code> file as <code>BAM</code> and <code>CRAM</code> are just alternative
encodings of <code>SAM</code></p><h2>Basics</h2><h3>What is a <code>SAM</code> file and how does it relate to <code>BAM</code> and <code>CRAM</code>?</h3><p>A <code>SAM</code> file contains &quot;reads&quot; from a sequencer. The &quot;reads&quot; often originally
are from <code>FASTQ</code> format files. The reads from <code>FASTQ</code> format are inputted into
an aligner such as <code>bwa</code>, <code>bowtie</code>, <code>minimap2</code> (there are many others) which
map the reads to a reference genome, and output <code>SAM</code> format.</p><p><code>SAM</code> is a text format that you can read with your text editor. <code>BAM</code> and
<code>CRAM</code> are compressed representations of the <code>SAM</code> format, and you can use
<code>samtools view -g yourfile.bam</code> or <code>samtools view -h yourfile.cram</code> to convert
them back to <code>SAM</code>.</p><h3>Converting <code>SAM</code> to <code>BAM</code> or <code>CRAM</code></h3><p>Quick tip:</p><p>Convert SAM to BAM</p><pre><code>samtools view file.sam -o file.bam
</code></pre><p>Convert SAM to CRAM</p><pre><code>samtools view -T reference.fa file.sam -o file.cram
</code></pre><h3>What is in a <code>SAM</code> file</h3><p>A <code>SAM</code> file contains a header and series of records. <code>SAM</code> record is a single
line in the file. A <code>SAM</code> record generally corresponds to a single read, but as
we will see, a split alignment may produce multiple <code>SAM</code> records that refer to
the same source read.</p><p>Note: you can also store unaligned data in <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> (so-called uBAM
for example) but most of the time, the reads in <code>SAM</code> format are aligned to a
reference genome.</p><p>Also note: if a read failed to align to the reference genome, it may still be
in your <code>SAM</code> file, it will just be marked as unmapped. Sometimes, &quot;dumpster
diving&quot; (looking at the unmapped reads from a <code>SAM</code> file) can reveal structural
variants.</p><h3>What is a <code>CIGAR</code> string</h3><p>A <code>CIGAR</code> string is a &quot;compact idiosyncratic gapped alignment report&quot;. Yes,
that&#x27;s an acronym. It can tell you where insertions and deletions are in an
alignment. Some <code>CIGAR</code> strings tell you where mismatches are (so-called
extended CIGAR, with the <code>X</code> letter), but I don&#x27;t often see this.</p><h3>What is an <code>MD</code> string</h3><p>An <code>MD</code> string is a tag in <code>SAM</code> file that helps tell you where the mismatches
are, and can be combined with a <code>CIGAR</code> to get the position of the mismatches
without looking at a reference genome.</p><p>The <code>MD</code> string is commonly seen in <code>BAM</code> files (not generally <code>CRAM</code> because
it already uses reference compression and requires a reference sequence to
decode).</p><p>The <code>MD</code> tag contains information about deletions (including the bases of the
reference genome, which would otherwise not be indicated) and mismatches (same,
indicating the base of the reference genome at a SNPs position), but not
insertions.</p><h2>Detecting SVs from long reads</h2><h3>What are split alignments?</h3><p>Split alignments, or chimeric-alignments are alignments where part of the read
aligns to perhaps chr1, and part of it maps to perhaps chr4. It is worth
reading the definition of &quot;Chimeric alignment&quot; from SAMv1.pdf (not reproduced
here)</p><p><a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a></p><p>There is no limitation on how many splits might occur so the split can align to
3, 4, or more different places. Each part of the split puts a new line in the
SAM file. As SAMv1.pdf tells us, one read is marked as &quot;representative&quot;, I call
this the &quot;primary&quot; read, while the other components of the split read are maked
supplementary, given the 2048 flag (0x80). Only the &quot;primary&quot; read generally
has a <code>SEQ</code> field (column 10)</p><p>Split alignments are especially common with long reads, and it can indicate
that there may be a structural variant where the two chromosomes are fused
together (which may create gene fusions, or other types of phenomena).</p><p>note: split alignments are different from &quot;multi-mappers&quot; where the entire read
maps maps equally well to, say, chr4 and chr1. Split reads maps part to chr1,
and part to chr4</p><p>See again the SAMv1.pdf for the definition of multi-mapping</p><h3>What is the <code>SA</code> tag?</h3><p>The <code>SA</code> tag is outputted on each part of the split alignment, e.g. the primary
contains an <code>SA</code> tag that refers to all the locations, <code>CIGAR</code> strings, and
more for all the supplementary reads, and each of the supplementary reads also
contains an <code>SA</code> tag that refers to the primary alignment and each other
supplementary alignment.</p><p>Fun fact: The <code>SA</code> tag conceptually can result in a &#x27;quadratic explosion&#x27; of
data, because each part of the split contains references to every other part.
For example, if a read is split into 4 pieces, then each read would would have
an SA tag with 3 segments, so 3<!-- -->*<!-- -->4 segments will be documented in the<code>SA</code> tag.</p><h3>Reconstructing a split alignment given the primary alignment</h3><p>If we are given the the primary alignment of an arbitrary split read, then we
can construct what that split looks like compared to the reference genome.</p><p>If we are not given the primary alignment (e.g. we are starting from a
supplementary alignment) then we can search the <code>SA</code> list for the one that is
primary, because at least one will be.</p><p>Now that we have the primary alignment, it will have the <code>SEQ</code> (of the entire
read, the supplementary alignments typically have a blank <code>SEQ</code>!) and the <code>SA</code>
tag containing the <code>CIGAR</code> of all the different parts of the split. We can then
construct how the entire read, not just a particular record of the split
alignment, compares to the genome. In JBrowse 2 we implemented this and it uses
a synteny-style rendering. This functionality also exists in GenomeRibbon
(<a href="https://genomeribbon.org">https://genomeribbon.org</a>)</p><p><img src="/media/linear_alignment.png"/></p><p>Figure showing JBrowse 2 piecing together a long read vs the reference genome from a single read</p><p>In order to do this reconstruction, it takes the <code>CIGAR</code> strings of the primary
alignment and each of the pieces of the <code>SA</code> tag (it is a semi-colon separated
list of chunks), sort them by the amount of softclipping (the softclipping
values will progressively trim off more of the <code>SEQ</code> telling you it aligned
further and further on in the long read), and then this tells me where each
piece of the split alignment came from in the original <code>SEQ</code>, so we can plot
the alignments of the read vs the reference genome using synteny style display.</p><h3>SAM vs VCF - Breakends vs split alignments</h3><p>An interesting outcome (to me) is that from a single record in a <code>SAM</code> file, I
can reconstruct the &quot;derived&quot; genome around a region of interest from a single
read.</p><p>If I was to try to do this with the <code>VCF</code> Breakend specification (section 5.4
of VCF4.3.pdf), it may actually be more challenging than from a <code>SAM</code> read.
This is because a Breakend in <code>VCF</code> format is only an edge in a graph (and the
sequences are nodes). Therefore, in order to properly reconstruct a structural
variant from a <code>VCF</code> with Breakends, I would have to construct the graph,</p><p>Now, this has caveats: a single read is noisy and does not contain as aggregate
evidence as looking at all the reads in a region. But still, interpretation of
the <code>VCF</code> breakend specification is challenging due to imposing a sequence graph
on the genome, while the <code>SA</code> tag remains just a simple set of linear alignments
that can easily be pieces together.</p><p>I am not aware of a lot of tools that work on the VCF Breakend graph, and
expect more will need to be created to truly work with this standard. An
inversion for example may create 4 record in the VCF file (see section 5.4 in
the VCF4.3.pdf for example), and needs careful interpretation</p><h3>Haplotype tagged reads</h3><p>A new trend has been to create <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> files with tagged reads,
which tells us which haplotype a read was inferred to have come from. This is
commonly done with the <code>HP</code> tag, which might have <code>HP=0</code> and <code>HP=1</code> for a
diploid genome. Tools like <code>whatshap</code> can add these tags to a <code>SAM</code> file, and
IGV and JBrowse 2 can color and sort by these tags.</p><p><img src="/media/color_by_tag.png"/></p><p>Screenshot of JBrowse 2 with the &quot;Color by tag&quot; and &quot;Sort by tag&quot; setting
enabled (coloring and sorting by the HP tag) letting us see that only one
haplotype has a deletion. Tutorial for how to do this in JBrowse 2 here
<a href="https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag">https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag</a></p><h2>How do you detect SVs with paired-end reads?</h2><p>Paired-end reads are short reads, e.g. 150bp each. This makes them unable to
recover some large structural variants.</p><p>However, paired-end reads have a number of attributes that can be used to
detect paired end reads</p><h3>Distance between pairs being abnormally large or short</h3><p>The distance between pairs is encoded by the <code>TLEN</code> column in the <code>SAM</code> format.
The distance between pairs with good mapping is relatively constant and called
the &quot;insert length&quot;. This comes from how the sequencing is done: paired-end
sequencing performs sequencing on both ends of a fragment.</p><p>But, if you are mapping reads vs the reference genome, and you observe that
they are abnormally far apart, say 50kb apart instead of 1kb apart, this may
indicate there your sample contains a deletion relative to the reference.</p><p><img src="/media/aberrant_size.png"/></p><p>Screenshot of JBrowse 1 with &quot;View as pairs&quot; enabled, and large insert size
colored as red (from <a href="https://jbrowse.org/docs/paired_reads.html">https://jbrowse.org/docs/paired_reads.html</a>). Note that
some of JBrowse 1&#x27;s View as pairs features are not yet available in JBrowse 2</p><h3>An abundance of reads being &quot;clipped&quot; at a particular position</h3><p>This can indicate that part of the reads map well, but then there was an abrupt
stop to the mapping. This might mean that there is a sequence that was an
insertion at that position, or a deletion, or a translocation.</p><p>The clipping is indicated by the <code>CIGAR</code> string, either at the start or end of
it by an <code>S</code> or an <code>H</code>. The <code>S</code> indicates &quot;soft clipping&quot;, and indicates that
the sequence of the clipped portion can be found in the <code>SEQ</code> field of the
primary alignment. The <code>H</code> is hard clipped, and the sequence that is hard
clipped will not appear in the <code>SEQ</code>.</p><p>You can visualize an excess of clipping in JBrowse 2, which creates an inverted
histogram at a particular position</p><p><img src="/media/clipping_pileup.png"/></p><p>Screenshot of JBrowse 2 showing blue clipping indicator with a &quot;pileup&quot; of soft-clipping at a particular position shown in blue.</p><p><img src="/media/show_soft_clipping.png"/></p><p>Screenshot of JBrowse 2 showing an insertion with both long reads and short
reads. With long reads, the read may completely span the insertion, so the
CIGAR string simply indicates a large <code>I</code> operator (purple indicator on track),
but for short reads, the reads near the insertion will be clipped since they
will not properly map to the reference genome. The &quot;Show soft clipping&quot; setting
in JBrowse 2 and IGV can be used to show visually the bases that extend into
the insertion (shown on the bottom track).</p><h3>Unexpected pair orientation</h3><p>With standard paired end sequencing, the pairs normally point at each other</p><pre><code>forward reverse
 ---&gt;    &lt;---
</code></pre><p>If the stranded-ness of the pair is off, then it could indicate a structural variant</p><pre><code class="language-typescript">// rnext: rnext column in sam
// ref: refname column in sam
// flags: flag integer in sam
// tlen: tlen column in sam
// code adapted from IGV
function getPairOrientation(
  flags: number,
  ref: string,
  rnext: string,
  tlen: number,
) {
  // this read is not unmapped &amp;&amp;
  // this read&#x27;s mate is also not unmapped &amp;&amp;
  // this read&#x27;s mate is on the same reference genome
  if (!flags &amp; 4 &amp;&amp; !flags &amp; 8 &amp;&amp; ref === rnext) {
    const s1 = flags &amp; 16 ? &#x27;R&#x27; : &#x27;F&#x27;
    const s2 = flags &amp; 32 ? &#x27;R&#x27; : &#x27;F&#x27;
    let o1 = &#x27; &#x27;
    let o2 = &#x27; &#x27;

    // if first in pair
    if (flags &amp; 64) {
      o1 = &#x27;1&#x27;
      o2 = &#x27;2&#x27;
    }

    // else if second in pair
    else if (flags &amp; 128) {
      o1 = &#x27;2&#x27;
      o2 = &#x27;1&#x27;
    }

    const tmp = []
    if (tlen &gt; 0) {
      tmp[0] = s1
      tmp[1] = o1
      tmp[2] = s2
      tmp[3] = o2
    } else {
      tmp[2] = s1
      tmp[3] = o1
      tmp[0] = s2
      tmp[1] = o2
    }
    return tmp.join(&#x27;&#x27;)
  }
  return null
}
</code></pre><p>If you have standard paired end reads, it will return <code>FR</code> forward-reverse, similar to the text diagram</p><pre><code>forward reverse
 ---&gt;    &lt;---
</code></pre><p>This guide from IGV is helpful for interpreting the pair directionality with
patterns of SVs using &quot;Color by pair orientation&quot;</p><p><a href="https://software.broadinstitute.org/software/igv/interpreting_pair_orientations">https://software.broadinstitute.org/software/igv/interpreting_pair_orientations</a></p><p>Example of an inverted duplication using JBrowse 2&#x27;s <code>Color by pair orientation</code> setting (very similar to IGV)</p><p><img src="/media/inverted_duplication.png"/></p><p>Figure: This shows an inverted (tandem) duplication in 1000 genomes data. The
tandem duplication can produce green arrows which have reads pointing in
opposite directions e.g. <code>&lt;--</code> and <code>--&gt;</code>, while blue arrows which can indicate
an inversion point in the same direction e.g. <code>--&gt;</code> and <code>--&gt;</code></p><h3>Caveat about TLEN</h3><p>Note that <code>TLEN</code> is a field in the SAM format that is somewhat ill defined,
at least in the sense that different tools may use it differently
<a href="https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767">https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767</a></p><p>If needed, you can calculate <code>TLEN</code> yourself if process the file yourself
(process all reads, get the actual records for the pairs, and calculate
distance) but I have not had trouble with basic usage of tools that rely on the
<code>TLEN</code> from the data files themselves</p><h2>Calling copy number variants with your short or long reads</h2><p>Another type of SV that you can get from your <code>SAM</code> files are copy number
variants (CNVs). By looking at the depth-of-coverage for your data files, you
can look for abnormalities that may indicate copy number variants. By using a
tool like <code>mosdepth</code>, you can quickly get a file showing the coverage across
the genome.</p><p>Be aware that if you are comparing the coverage counts from different tools,
that they have different defaults that may affect comparison. Some discard
<code>QC_FAIL</code>, <code>DUP</code>, and <code>SECONDARY</code> flagged reads. This is probably appropriate,
and corresponds to what most genome browsers will display (see
<a href="https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af">https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af</a> for a short
summary of depth calculated from different tools)</p><p>Note that both long and short reads can be used for CNV detection. Long reads
may give more accurate measurements also, with their better ability to map
smoothly through difficult regions of the genome.</p><p><img src="/media/coverage_cnv.png"/></p><p>Screenshot showing coverage in BigWig format from nanopore reads on normal and
tumor tissue from a melanoma cancer cell line plotted using JBrowse 2
(<a href="https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json&amp;session=share-MZj3d18lzH&amp;password=3X7bS">demo</a> and <a href="https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv">tutorial</a>)</p><h2>Future of SVs</h2><p>Currently, SV visualization is highly based on comparing data versus a
reference genome (and the SAM format is a signature of this: it stores data in
terms of reference genome coordinates). In the future, SV visualization may
look more similar to comparative genomics, where we compare the an SV to a
population specific reference or something like this.</p><p>As cheap de-novo assembled genomes and graph genomes are more widespread, the
tools and data formats may keep evolving to support these use cases. I have not
seen a lot of examples of annotations like gene structure stored in graph
format, and this may be a difficult endeavor.</p><p>As long as I&#x27;m rambling, storing gene structure in a graph may be somewhat
challenging. In fact, storing it &quot;properly&quot; (e.g. taking into account the path
through the graph) may be almost equivalent to performing variant effect
prediction. Taking into account mutations or SVs in the graph is complex, so
storing gene annotation structures in a graph format may not even be the end
goal of any data format. Instead, maybe there will be &quot;reference gene sets&quot;
(based on population specific references for example) so gene annotation
remains linear, and then variant effect predictors run against on samples
against those population specific references.</p><h2>Conclusion</h2><p>Algorithms that actually call structural variants face many challenges, but
understanding how the reads are encoded in SAM format, and seeing what they
look like in the genome browser is a useful first step to gaining a better
understanding.</p><p>In summary, some of the signatures of SVs may include:</p><ul><li>Aberrant insert size (TLEN) detection (longer for deletion, shorter for insertion)</li><li>Split-read detection</li><li>CIGAR string processing (D operator for deletions, I operator for insertions)</li><li>Over-abundance of clipping (S or H operators in CIGAR)</li><li>Depth of coverage changes for CNVs</li></ul><p>If you have any ideas that you want to contribute to this blog post let me know!</p></article></div></main></div><footer style="margin-top:20px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Structural variants and the SAM format - the long (reads) and short (reads) of it","date":"2022-02-06","slug":"2022-02-06-sv-sam","mdxSource":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var p=(n,a,t)=\u003ea in n?h(n,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[a]=t,e=(n,a)=\u003e{for(var t in a||(a={}))r.call(a,t)\u0026\u0026p(n,t,a[t]);if(o)for(var t of o(a))s.call(a,t)\u0026\u0026p(n,t,a[t]);return n},l=(n,a)=\u003em(n,c(a));var d=(n,a)=\u003e{var t={};for(var i in n)r.call(n,i)\u0026\u0026a.indexOf(i)\u003c0\u0026\u0026(t[i]=n[i]);if(n!=null\u0026\u0026o)for(var i of o(n))a.indexOf(i)\u003c0\u0026\u0026s.call(n,i)\u0026\u0026(t[i]=n[i]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var i=t,{components:n}=i,a=d(i,[\"components\"]);return mdx(MDXLayout,l(e(e({},layoutProps),a),{components:n,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` specification is pretty amazing\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"https://samtools.github.io/hts-specs/SAMv1.pdf\"),` but it is also fairly terse and\nabstract, and true understanding comes from playing with real world data but I\nwill try to explain some stuff I have learned about reads, especially as they\nrelate to structural variants.`),mdx(\"p\",null,`Disclaimer: I'm a developer of JBrowse 2. This document has some screenshots\nand links for it, feel free to try it at `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org\"}),\"https://jbrowse.org\")),mdx(\"p\",null,\"Also note: When I refer to a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record in this document, it could come from\na `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\", or \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" file as \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` are just alternative\nencodings of `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\")),mdx(\"h2\",null,\"Basics\"),mdx(\"h3\",null,\"What is a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" file and how does it relate to \",mdx(\"inlineCode\",{parentName:\"h3\"},\"BAM\"),\" and \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CRAM\"),\"?\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file contains \"reads\" from a sequencer. The \"reads\" often originally\nare from `,mdx(\"inlineCode\",{parentName:\"p\"},\"FASTQ\"),\" format files. The reads from \",mdx(\"inlineCode\",{parentName:\"p\"},\"FASTQ\"),` format are inputted into\nan aligner such as `,mdx(\"inlineCode\",{parentName:\"p\"},\"bwa\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"bowtie\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"minimap2\"),` (there are many others) which\nmap the reads to a reference genome, and output `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" format.\"),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" is a text format that you can read with your text editor. \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),` and\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" are compressed representations of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format, and you can use\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"samtools view -g yourfile.bam\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"samtools view -h yourfile.cram\"),` to convert\nthem back to `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\".\"),mdx(\"h3\",null,\"Converting \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" to \",mdx(\"inlineCode\",{parentName:\"h3\"},\"BAM\"),\" or \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CRAM\")),mdx(\"p\",null,\"Quick tip:\"),mdx(\"p\",null,\"Convert SAM to BAM\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`samtools view file.sam -o file.bam\n`)),mdx(\"p\",null,\"Convert SAM to CRAM\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`samtools view -T reference.fa file.sam -o file.cram\n`)),mdx(\"h3\",null,\"What is in a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" file\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" file contains a header and series of records. \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record is a single\nline in the file. A `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record generally corresponds to a single read, but as\nwe will see, a split alignment may produce multiple `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` records that refer to\nthe same source read.`),mdx(\"p\",null,\"Note: you can also store unaligned data in \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` (so-called uBAM\nfor example) but most of the time, the reads in `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format are aligned to a\nreference genome.`),mdx(\"p\",null,`Also note: if a read failed to align to the reference genome, it may still be\nin your `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, it will just be marked as unmapped. Sometimes, \"dumpster\ndiving\" (looking at the unmapped reads from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file) can reveal structural\nvariants.`),mdx(\"h3\",null,\"What is a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CIGAR\"),\" string\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` string is a \"compact idiosyncratic gapped alignment report\". Yes,\nthat's an acronym. It can tell you where insertions and deletions are in an\nalignment. Some `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings tell you where mismatches are (so-called\nextended CIGAR, with the `,mdx(\"inlineCode\",{parentName:\"p\"},\"X\"),\" letter), but I don't often see this.\"),mdx(\"h3\",null,\"What is an \",mdx(\"inlineCode\",{parentName:\"h3\"},\"MD\"),\" string\"),mdx(\"p\",null,\"An \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),\" string is a tag in \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file that helps tell you where the mismatches\nare, and can be combined with a `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` to get the position of the mismatches\nwithout looking at a reference genome.`),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),\" string is commonly seen in \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" files (not generally \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` because\nit already uses reference compression and requires a reference sequence to\ndecode).`),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),` tag contains information about deletions (including the bases of the\nreference genome, which would otherwise not be indicated) and mismatches (same,\nindicating the base of the reference genome at a SNPs position), but not\ninsertions.`),mdx(\"h2\",null,\"Detecting SVs from long reads\"),mdx(\"h3\",null,\"What are split alignments?\"),mdx(\"p\",null,`Split alignments, or chimeric-alignments are alignments where part of the read\naligns to perhaps chr1, and part of it maps to perhaps chr4. It is worth\nreading the definition of \"Chimeric alignment\" from SAMv1.pdf (not reproduced\nhere)`),mdx(\"p\",null,mdx(\"a\",e({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"https://samtools.github.io/hts-specs/SAMv1.pdf\")),mdx(\"p\",null,`There is no limitation on how many splits might occur so the split can align to\n3, 4, or more different places. Each part of the split puts a new line in the\nSAM file. As SAMv1.pdf tells us, one read is marked as \"representative\", I call\nthis the \"primary\" read, while the other components of the split read are maked\nsupplementary, given the 2048 flag (0x80). Only the \"primary\" read generally\nhas a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\" field (column 10)\"),mdx(\"p\",null,`Split alignments are especially common with long reads, and it can indicate\nthat there may be a structural variant where the two chromosomes are fused\ntogether (which may create gene fusions, or other types of phenomena).`),mdx(\"p\",null,`note: split alignments are different from \"multi-mappers\" where the entire read\nmaps maps equally well to, say, chr4 and chr1. Split reads maps part to chr1,\nand part to chr4`),mdx(\"p\",null,\"See again the SAMv1.pdf for the definition of multi-mapping\"),mdx(\"h3\",null,\"What is the \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SA\"),\" tag?\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag is outputted on each part of the split alignment, e.g. the primary\ncontains an `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),\" tag that refers to all the locations, \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings, and\nmore for all the supplementary reads, and each of the supplementary reads also\ncontains an `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag that refers to the primary alignment and each other\nsupplementary alignment.`),mdx(\"p\",null,\"Fun fact: The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag conceptually can result in a 'quadratic explosion' of\ndata, because each part of the split contains references to every other part.\nFor example, if a read is split into 4 pieces, then each read would would have\nan SA tag with 3 segments, so 3`,\"*\",\"4 segments will be documented in the\",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),\" tag.\"),mdx(\"h3\",null,\"Reconstructing a split alignment given the primary alignment\"),mdx(\"p\",null,`If we are given the the primary alignment of an arbitrary split read, then we\ncan construct what that split looks like compared to the reference genome.`),mdx(\"p\",null,`If we are not given the primary alignment (e.g. we are starting from a\nsupplementary alignment) then we can search the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` list for the one that is\nprimary, because at least one will be.`),mdx(\"p\",null,\"Now that we have the primary alignment, it will have the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` (of the entire\nread, the supplementary alignments typically have a blank `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\"!) and the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),`\ntag containing the `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` of all the different parts of the split. We can then\nconstruct how the entire read, not just a particular record of the split\nalignment, compares to the genome. In JBrowse 2 we implemented this and it uses\na synteny-style rendering. This functionality also exists in GenomeRibbon\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://genomeribbon.org\"}),\"https://genomeribbon.org\"),\")\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/linear_alignment.png\",alt:null}))),mdx(\"p\",null,\"Figure showing JBrowse 2 piecing together a long read vs the reference genome from a single read\"),mdx(\"p\",null,\"In order to do this reconstruction, it takes the \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings of the primary\nalignment and each of the pieces of the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag (it is a semi-colon separated\nlist of chunks), sort them by the amount of softclipping (the softclipping\nvalues will progressively trim off more of the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` telling you it aligned\nfurther and further on in the long read), and then this tells me where each\npiece of the split alignment came from in the original `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),`, so we can plot\nthe alignments of the read vs the reference genome using synteny style display.`),mdx(\"h3\",null,\"SAM vs VCF - Breakends vs split alignments\"),mdx(\"p\",null,\"An interesting outcome (to me) is that from a single record in a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, I\ncan reconstruct the \"derived\" genome around a region of interest from a single\nread.`),mdx(\"p\",null,\"If I was to try to do this with the \",mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` Breakend specification (section 5.4\nof VCF4.3.pdf), it may actually be more challenging than from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` read.\nThis is because a Breakend in `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` format is only an edge in a graph (and the\nsequences are nodes). Therefore, in order to properly reconstruct a structural\nvariant from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),\" with Breakends, I would have to construct the graph,\"),mdx(\"p\",null,`Now, this has caveats: a single read is noisy and does not contain as aggregate\nevidence as looking at all the reads in a region. But still, interpretation of\nthe `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` breakend specification is challenging due to imposing a sequence graph\non the genome, while the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag remains just a simple set of linear alignments\nthat can easily be pieces together.`),mdx(\"p\",null,`I am not aware of a lot of tools that work on the VCF Breakend graph, and\nexpect more will need to be created to truly work with this standard. An\ninversion for example may create 4 record in the VCF file (see section 5.4 in\nthe VCF4.3.pdf for example), and needs careful interpretation`),mdx(\"h3\",null,\"Haplotype tagged reads\"),mdx(\"p\",null,\"A new trend has been to create \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` files with tagged reads,\nwhich tells us which haplotype a read was inferred to have come from. This is\ncommonly done with the `,mdx(\"inlineCode\",{parentName:\"p\"},\"HP\"),\" tag, which might have \",mdx(\"inlineCode\",{parentName:\"p\"},\"HP=0\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"HP=1\"),` for a\ndiploid genome. Tools like `,mdx(\"inlineCode\",{parentName:\"p\"},\"whatshap\"),\" can add these tags to a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, and\nIGV and JBrowse 2 can color and sort by these tags.`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/color_by_tag.png\",alt:null}))),mdx(\"p\",null,`Screenshot of JBrowse 2 with the \"Color by tag\" and \"Sort by tag\" setting\nenabled (coloring and sorting by the HP tag) letting us see that only one\nhaplotype has a deletion. Tutorial for how to do this in JBrowse 2 here\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\"}),\"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\")),mdx(\"h2\",null,\"How do you detect SVs with paired-end reads?\"),mdx(\"p\",null,`Paired-end reads are short reads, e.g. 150bp each. This makes them unable to\nrecover some large structural variants.`),mdx(\"p\",null,`However, paired-end reads have a number of attributes that can be used to\ndetect paired end reads`),mdx(\"h3\",null,\"Distance between pairs being abnormally large or short\"),mdx(\"p\",null,\"The distance between pairs is encoded by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),\" column in the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format.\nThe distance between pairs with good mapping is relatively constant and called\nthe \"insert length\". This comes from how the sequencing is done: paired-end\nsequencing performs sequencing on both ends of a fragment.`),mdx(\"p\",null,`But, if you are mapping reads vs the reference genome, and you observe that\nthey are abnormally far apart, say 50kb apart instead of 1kb apart, this may\nindicate there your sample contains a deletion relative to the reference.`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/aberrant_size.png\",alt:null}))),mdx(\"p\",null,`Screenshot of JBrowse 1 with \"View as pairs\" enabled, and large insert size\ncolored as red (from `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/docs/paired_reads.html\"}),\"https://jbrowse.org/docs/paired_reads.html\"),`). Note that\nsome of JBrowse 1's View as pairs features are not yet available in JBrowse 2`),mdx(\"h3\",null,'An abundance of reads being \"clipped\" at a particular position'),mdx(\"p\",null,`This can indicate that part of the reads map well, but then there was an abrupt\nstop to the mapping. This might mean that there is a sequence that was an\ninsertion at that position, or a deletion, or a translocation.`),mdx(\"p\",null,\"The clipping is indicated by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` string, either at the start or end of\nit by an `,mdx(\"inlineCode\",{parentName:\"p\"},\"S\"),\" or an \",mdx(\"inlineCode\",{parentName:\"p\"},\"H\"),\". The \",mdx(\"inlineCode\",{parentName:\"p\"},\"S\"),` indicates \"soft clipping\", and indicates that\nthe sequence of the clipped portion can be found in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` field of the\nprimary alignment. The `,mdx(\"inlineCode\",{parentName:\"p\"},\"H\"),` is hard clipped, and the sequence that is hard\nclipped will not appear in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\".\"),mdx(\"p\",null,`You can visualize an excess of clipping in JBrowse 2, which creates an inverted\nhistogram at a particular position`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/clipping_pileup.png\",alt:null}))),mdx(\"p\",null,'Screenshot of JBrowse 2 showing blue clipping indicator with a \"pileup\" of soft-clipping at a particular position shown in blue.'),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/show_soft_clipping.png\",alt:null}))),mdx(\"p\",null,`Screenshot of JBrowse 2 showing an insertion with both long reads and short\nreads. With long reads, the read may completely span the insertion, so the\nCIGAR string simply indicates a large `,mdx(\"inlineCode\",{parentName:\"p\"},\"I\"),` operator (purple indicator on track),\nbut for short reads, the reads near the insertion will be clipped since they\nwill not properly map to the reference genome. The \"Show soft clipping\" setting\nin JBrowse 2 and IGV can be used to show visually the bases that extend into\nthe insertion (shown on the bottom track).`),mdx(\"h3\",null,\"Unexpected pair orientation\"),mdx(\"p\",null,\"With standard paired end sequencing, the pairs normally point at each other\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`forward reverse\n ---\u003e    \u003c---\n`)),mdx(\"p\",null,\"If the stranded-ness of the pair is off, then it could indicate a structural variant\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`// rnext: rnext column in sam\n// ref: refname column in sam\n// flags: flag integer in sam\n// tlen: tlen column in sam\n// code adapted from IGV\nfunction getPairOrientation(\n  flags: number,\n  ref: string,\n  rnext: string,\n  tlen: number,\n) {\n  // this read is not unmapped \u0026\u0026\n  // this read's mate is also not unmapped \u0026\u0026\n  // this read's mate is on the same reference genome\n  if (!flags \u0026 4 \u0026\u0026 !flags \u0026 8 \u0026\u0026 ref === rnext) {\n    const s1 = flags \u0026 16 ? 'R' : 'F'\n    const s2 = flags \u0026 32 ? 'R' : 'F'\n    let o1 = ' '\n    let o2 = ' '\n\n    // if first in pair\n    if (flags \u0026 64) {\n      o1 = '1'\n      o2 = '2'\n    }\n\n    // else if second in pair\n    else if (flags \u0026 128) {\n      o1 = '2'\n      o2 = '1'\n    }\n\n    const tmp = []\n    if (tlen \u003e 0) {\n      tmp[0] = s1\n      tmp[1] = o1\n      tmp[2] = s2\n      tmp[3] = o2\n    } else {\n      tmp[2] = s1\n      tmp[3] = o1\n      tmp[0] = s2\n      tmp[1] = o2\n    }\n    return tmp.join('')\n  }\n  return null\n}\n`)),mdx(\"p\",null,\"If you have standard paired end reads, it will return \",mdx(\"inlineCode\",{parentName:\"p\"},\"FR\"),\" forward-reverse, similar to the text diagram\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`forward reverse\n ---\u003e    \u003c---\n`)),mdx(\"p\",null,`This guide from IGV is helpful for interpreting the pair directionality with\npatterns of SVs using \"Color by pair orientation\"`),mdx(\"p\",null,mdx(\"a\",e({parentName:\"p\"},{href:\"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"}),\"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\")),mdx(\"p\",null,\"Example of an inverted duplication using JBrowse 2's \",mdx(\"inlineCode\",{parentName:\"p\"},\"Color by pair orientation\"),\" setting (very similar to IGV)\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/inverted_duplication.png\",alt:null}))),mdx(\"p\",null,`Figure: This shows an inverted (tandem) duplication in 1000 genomes data. The\ntandem duplication can produce green arrows which have reads pointing in\nopposite directions e.g. `,mdx(\"inlineCode\",{parentName:\"p\"},\"\u003c--\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"--\u003e\"),`, while blue arrows which can indicate\nan inversion point in the same direction e.g. `,mdx(\"inlineCode\",{parentName:\"p\"},\"--\u003e\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"--\u003e\")),mdx(\"h3\",null,\"Caveat about TLEN\"),mdx(\"p\",null,\"Note that \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` is a field in the SAM format that is somewhat ill defined,\nat least in the sense that different tools may use it differently\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\"}),\"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\")),mdx(\"p\",null,\"If needed, you can calculate \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` yourself if process the file yourself\n(process all reads, get the actual records for the pairs, and calculate\ndistance) but I have not had trouble with basic usage of tools that rely on the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),\" from the data files themselves\"),mdx(\"h2\",null,\"Calling copy number variants with your short or long reads\"),mdx(\"p\",null,\"Another type of SV that you can get from your \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` files are copy number\nvariants (CNVs). By looking at the depth-of-coverage for your data files, you\ncan look for abnormalities that may indicate copy number variants. By using a\ntool like `,mdx(\"inlineCode\",{parentName:\"p\"},\"mosdepth\"),`, you can quickly get a file showing the coverage across\nthe genome.`),mdx(\"p\",null,`Be aware that if you are comparing the coverage counts from different tools,\nthat they have different defaults that may affect comparison. Some discard\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"QC_FAIL\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"DUP\"),\", and \",mdx(\"inlineCode\",{parentName:\"p\"},\"SECONDARY\"),` flagged reads. This is probably appropriate,\nand corresponds to what most genome browsers will display (see\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\"}),\"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\"),` for a short\nsummary of depth calculated from different tools)`),mdx(\"p\",null,`Note that both long and short reads can be used for CNV detection. Long reads\nmay give more accurate measurements also, with their better ability to map\nsmoothly through difficult regions of the genome.`),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"/media/coverage_cnv.png\",alt:null}))),mdx(\"p\",null,`Screenshot showing coverage in BigWig format from nanopore reads on normal and\ntumor tissue from a melanoma cancer cell line plotted using JBrowse 2\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json\u0026session=share-MZj3d18lzH\u0026password=3X7bS\"}),\"demo\"),\" and \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv\"}),\"tutorial\"),\")\"),mdx(\"h2\",null,\"Future of SVs\"),mdx(\"p\",null,`Currently, SV visualization is highly based on comparing data versus a\nreference genome (and the SAM format is a signature of this: it stores data in\nterms of reference genome coordinates). In the future, SV visualization may\nlook more similar to comparative genomics, where we compare the an SV to a\npopulation specific reference or something like this.`),mdx(\"p\",null,`As cheap de-novo assembled genomes and graph genomes are more widespread, the\ntools and data formats may keep evolving to support these use cases. I have not\nseen a lot of examples of annotations like gene structure stored in graph\nformat, and this may be a difficult endeavor.`),mdx(\"p\",null,`As long as I'm rambling, storing gene structure in a graph may be somewhat\nchallenging. In fact, storing it \"properly\" (e.g. taking into account the path\nthrough the graph) may be almost equivalent to performing variant effect\nprediction. Taking into account mutations or SVs in the graph is complex, so\nstoring gene annotation structures in a graph format may not even be the end\ngoal of any data format. Instead, maybe there will be \"reference gene sets\"\n(based on population specific references for example) so gene annotation\nremains linear, and then variant effect predictors run against on samples\nagainst those population specific references.`),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`Algorithms that actually call structural variants face many challenges, but\nunderstanding how the reads are encoded in SAM format, and seeing what they\nlook like in the genome browser is a useful first step to gaining a better\nunderstanding.`),mdx(\"p\",null,\"In summary, some of the signatures of SVs may include:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Aberrant insert size (TLEN) detection (longer for deletion, shorter for insertion)\"),mdx(\"li\",{parentName:\"ul\"},\"Split-read detection\"),mdx(\"li\",{parentName:\"ul\"},\"CIGAR string processing (D operator for deletions, I operator for insertions)\"),mdx(\"li\",{parentName:\"ul\"},\"Over-abundance of clipping (S or H operators in CIGAR)\"),mdx(\"li\",{parentName:\"ul\"},\"Depth of coverage changes for CNVs\")),mdx(\"p\",null,\"If you have any ideas that you want to contribute to this blog post let me know!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-02-06-sv-sam"},"buildId":"hu_1vi4ERKKV3-QuvTnTM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>