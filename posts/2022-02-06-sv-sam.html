<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Structural variants and the SAM format - the long (reads) and short (reads) of it</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/9d066bf523979bbf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d066bf523979bbf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-8b8836cfd4de0dcd.js" defer=""></script><script src="/_next/static/chunks/framework-c0d8f0fd2eea5ac1.js" defer=""></script><script src="/_next/static/chunks/main-ad18704b098b4264.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d9139de5c3de3b6b.js" defer=""></script><script src="/_next/static/chunks/996-f78e375898643c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-34e532adea304c66.js" defer=""></script><script src="/_next/static/gSZKpEwUHnQkfXhED-jJR/_buildManifest.js" defer=""></script><script src="/_next/static/gSZKpEwUHnQkfXhED-jJR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><article><div><h1>Structural variants and the SAM format - the long (reads) and short (reads) of it</h1><h4>2022-02-06</h4></div><p>The <code>SAM</code> specification is pretty amazing
(<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">https://samtools.github.io/hts-specs/SAMv1.pdf</a>)
but it is also fairly terse and abstract. True understanding might come from
playing with real world data. I will try to relay some things I have learned
over the years, with a bit of a focus on how <code>SAM</code> file concepts can relate to
structural variants.</p>
<p>Disclaimer: I&#x27;m a developer of JBrowse 2. This document has some screenshots
and links for it, feel free to try it at
<a href="https://jbrowse.org">https://jbrowse.org</a>.</p>
<h2>Basics</h2>
<h3>What is a <code>SAM</code> file and how does it relate to <code>BAM</code> and <code>CRAM</code>?</h3>
<ul>
<li>
<p>A <code>SAM</code> file <strong>generally</strong> contains &quot;reads&quot; from a sequencer, with information
about how they are mapped to a reference genome [1][2].</p>
</li>
<li>
<p>A <code>SAM</code> file is <strong>generally</strong> produced when an aligner takes in raw unaligned reads
(often stored in <code>FASTQ</code> format files) and aligns them to a reference genome [3].</p>
</li>
<li>
<p>A <code>SAM</code> file is a text format that you can read with your text editor. <code>BAM</code> and
<code>CRAM</code> are compressed representations of the <code>SAM</code> format.</p>
</li>
</ul>
<p>You can convert <code>SAM</code> to <code>BAM</code> with samtools</p>
<p><code>samtools view file.sam -o file.bam</code></p>
<p>You can also convert a <code>BAM</code> back to <code>SAM</code> with samtools view</p>
<p><code>samtools view -h file.bam -o file.sam</code></p>
<p>The -h just makes sure to preserve the header.</p>
<p>If you are converting <code>SAM</code> to <code>CRAM</code>, it may require the -T argument to
specify your reference sequence (this is because the <code>CRAM</code> is &quot;reference
compressed&quot;)</p>
<p><code>samtools view -T reference.fa file.sam -o file.cram</code></p>
<p>Also see Appendix C: piping FASTQ from <code>minimap2</code> directly to CRAM</p>
<p>[1] <code>SAM</code> can contain any type of sequence, not specifically reads. If you
created a <em>de novo</em> assembly, you could align the contigs of the <em>de novo</em> assembly
to a reference genome and store the results in <code>SAM</code>.</p>
<p>[2] Does not always have to have information about mapping to a reference
genome. You can also store unaligned data in <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> (so-called
<code>uBAM</code> for example) but most of the time, the reads in <code>SAM</code> format are aligned
to a reference genome.</p>
<p>[3] Examples of programs that do alignment include <code>bwa</code>, <code>bowtie</code>, and <code>minimap2</code>
(there are many others). These programs all can produce <code>SAM</code> outputs</p>
<h3>What is in a <code>SAM</code> file</h3>
<p>A <code>SAM</code> file contains a header (<code>BAM</code> and <code>CRAM</code> files also have the <code>SAM</code>
header) and a series of records. A record is a single line in a <code>SAM</code> file, and
it generally corresponds to a single read, but as we will see, a split
alignment may produce multiple records that refer to the same source read.</p>
<p>Note: if a read failed to align to the reference genome, it may still be in
your <code>SAM</code> file, marked as unmapped using the flag column. Sometimes, &quot;dumpster
diving&quot; (looking at the unmapped records from a <code>SAM</code> file) can be used to aid
structural variant searches (e.g. there may be novel sequence in there not from
the reference genome that could be assembled)</p>
<h3>What are tags in a <code>SAM</code> file</h3>
<p>A SAM file has a core set of required fields, and then an arbitrary list of
extra columns called tags. The tags have a two character abbreviation like <code>MQ</code>
(mapping quality) or many others. They can be upper or lower case. Upper case
are reserved for official usages (except those with X, Y, or Z prefixed). See
<a href="https://samtools.github.io/hts-specs/SAMtags.pdf">SAMtags.pdf</a> for more
details</p>
<h3>What is a <code>CIGAR</code> string</h3>
<p>A <code>CIGAR</code> string is a &quot;compact idiosyncratic gapped alignment report&quot;. It tells
you about insertions, deletions, and clipping. It is a series of &quot;operators&quot;
with lengths.</p>
<p>Insertion example:</p>
<p><code>50M50I50M</code></p>
<p>That would be 50bp of matching bases (<code>50M</code>), followed by a 50bp insertion
(<code>50I</code>), followed by another 50bp of matches (<code>50M</code>). The 50bp insertion means
the read contains 50 bases in the middle which did not match the reference
genome that you are comparing the read to.</p>
<p>Clipping example:</p>
<p><code>50S50M50S</code></p>
<p>This means that 50bp matched (<code>50M</code> in the middle of the <code>CIGAR</code> string) and
both sides of the read are soft clipped. The clipping means the aligner was not
able to align the reads on either side. You could imagine clipping being like
&quot;an insertion on either side of the read&quot; if you like: basically those bases on
either side did not align.</p>
<p>Notes:</p>
<ul>
<li>
<p><em>Finding mismatches</em>: A <code>CIGAR</code> string match like <code>50M</code> means 50 bases
&quot;matched&quot; the reference genome, but that only means that there are no
insertions or deletions in those 50 bases. There could be underlying
mismatches in the read compared to the reference. Note: there is also
extended <code>CIGAR</code> that replaces <code>M</code> with <code>=</code> (exact match) and <code>X</code> (mismatch).
Also see Appendix D on the <code>MD</code> tag and finding where the mismatches are, but
note that <code>MD</code> tag is tricky</p>
</li>
<li>
<p><em>Ambiguity of representation</em>: A <code>CIGAR</code> string with insertions and deletions
could be <code>50M1D1I50M</code>. This string had a 1bp deletion and a 1bp insertion
back-to-back. This could be just a mismatch! There is ambiguity in sequence
alignment representations. Downstream programs must accomodate this.</p>
</li>
<li>
<p><em>Split records and soft-clipping</em>: A <code>CIGAR</code> string with soft-clipping
<code>500S50M</code> this means that 500 bases of the read were not aligned at this
position, but 50 bases were! Note that the alignment might have been a split
alignment (see section on split alignments below) so another record in the
<code>SAM</code> file, linked by the <code>SA</code> (supplmentary alignment) tag, might contain
info on where the other 500 bases aligned! (or, they might not map anywhere).
The linked split or supplementary alignments all have the same read name
(<code>QNAME</code>).</p>
</li>
</ul>
<p>See <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> for all the
CIGAR operators.</p>
<p>If you are working with <code>SAM</code> data, you will often write loops that directly
parse CIGAR strings. See Appendix B for handy functions for parsing <code>CIGAR</code>
strings. Don&#x27;t fear the <code>CIGAR</code>!</p>
<h2>Detecting SVs from long reads</h2>
<p>Long reads offer a wide array of methods for detecting SVs</p>
<ul>
<li><em>Small insertions/deletions</em>: Long reads can completely span moderate sized
insertions and deletions, indicated by <code>I</code> or <code>D</code> in a <code>CIGAR</code> string.</li>
<li><em>Large insertions/deletions</em>: If a long read does not completely span an
insertion or deletion, it may be split aligned on either side of the SV or
could be soft/hard clipped where it can&#x27;t align all the way through an
insertion.</li>
<li><em>Translocations</em>: A split long alignment can span long range or even
inter-chromosomal translocations, so part of the read maps to one chromosome
and one part maps to the other</li>
<li><em>Inversions</em>: A split alignment can span an inversion, the long read is split
into multiple parts, one part of it aligns in the reverse orientation, while
the other part aligns in the forward orientation</li>
</ul>
<p>Note that there are many different methods for detecting SVs from long reads,
e.g. not all use mapped reads from SAM files, some use <em>de novo</em> assembly, but
it is still useful to be familiar with mapped read methods.</p>
<h3>What are split alignments?</h3>
<p>Split alignments, or chimeric alignments, are alignments where part of the read
maps to one place, and another part to another. For example, part of a long
read may map to <code>chr1</code> and part of it maps to <code>chr4</code>. It is worth reading the
definition of &quot;Chimeric alignment&quot; from
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> when you get the
chance.</p>
<p>Split alignments are especially common with long reads, and it can indicate
large structural variants. There may be a structural variant where the two
chromosomes are fused together, and parts of the read align to multiple
chromosomes, or the split alignment may align to either side of a large
deletion, or they may be split to align through an inversion (part of it aligns
to the forward strand, part of it to the reverse strand, and again the forward
strand)</p>
<p>There is no limitation on how many splits might occur so the split can align to
3, 4, or more different places. Each part of the split puts a new line in the
SAM file, and note that all the records also have the same read name, or <code>QNAME</code> (first
column of <code>SAM</code>).</p>
<p>As <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> tells us, one
record is marked as &quot;representative&quot;, I call this the &quot;primary&quot; record, while
the other components of the split read are maked supplementary, given the 2048
flag. Only the &quot;primary&quot; record generally has a <code>SEQ</code> field. The split
alignments are generally also all given a <code>SA</code> tag that gives info on where all
the other parts of the split are. See
<a href="https://samtools.github.io/hts-specs/SAMtags.pdf">SAMtags.pdf</a> for more info
on the <code>SA</code> tag.</p>
<p>Note: split alignments are different from &quot;multi-mappers&quot; where the entire read
maps maps equally well to, say, <code>chr4</code> and <code>chr1</code>. Split reads maps part to
chr1, and part to <code>chr4</code>. See again the
<a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAMv1.pdf</a> for the definition
of multi-mapping</p>
<h3>What is the <code>SA</code> tag?</h3>
<p>The <code>SA</code> tag is outputted on each part of the split alignment, e.g. the primary
contains an <code>SA</code> tag that refers to all the locations, <code>CIGAR</code> strings, and
more for all the supplementary reads, and each of the supplementary reads also
contains an <code>SA</code> tag that refers to the primary alignment and each other
supplementary alignment.</p>
<p>Fun fact: The <code>SA</code> tag conceptually can result in a &#x27;quadratic explosion&#x27; of
data, because each part of the split contains references to every other part.
For example, if a read is split into 4 pieces, then each record would would
have an <code>SA</code> tag with 3 segments, so 3*4 segments will be documented in the
<code>SA</code> tag. In many cases, this is not a problem, but if you imagine a finished
chromosome aligned to a draft assembly, it may get split so many times
this could be a factor.</p>
<h3>Visualizing split reads across a breakend or translocation</h3>
<p>This is a specialized JBrowse 2 feature, but if there is an inter-chromosomal
translocation, you can load this into JBrowse and visualize support for this
event using our &quot;breakpoint split view&quot;. This view shows the evidence for the
reads that are split aligned across an SV, and can show connections between
paired-end reads across an SV too.</p>
<p>We also have a workflow called the &quot;SV inspector&quot; that helps you setup the
&quot;breakpoint split views&quot;
(<a href="https://jbrowse.org/jb2/docs/user_guide/#sv-inspector">https://jbrowse.org/jb2/docs/user_guide/#sv-inspector</a>.
The SV inspector and Breakpoint split view work best on Breakends (e.g. VCF 4.3
section 5.4) and <code>&lt;TRA&gt;</code> (translocation) events from <code>VCF</code>, or <code>BEDPE</code>
formatted SV calls, and you can launch the &quot;breakpoint split view&quot; from the &quot;SV
inspector&quot;</p>
<p><img src="/media/breakpoint_split_view.png" alt=""/></p>
<h3>Visualizing a &#x27;read vs reference&#x27; view given a split alignment</h3>
<p>If we are given the the primary alignment of an arbitrary split read, then we
can construct what that split looks like compared to the reference genome.</p>
<p>If we are not given the primary alignment (e.g. we are starting from a
supplementary alignment) then we can search the <code>SA</code> list for the one that is
primary, because at least one will be.</p>
<p>Now that we have the primary alignment, it will have the <code>SEQ</code> (of the entire
read, the supplementary alignments typically have a blank <code>SEQ</code>!) and the <code>SA</code>
tag containing the <code>CIGAR</code> of all the different parts of the split. We can then
construct how the entire read, not just a particular record of the split
alignment, compares to the genome. In JBrowse 2 we implemented this and it uses
a synteny-style rendering. [1]</p>
<p><img src="/media/linear_alignment.png" alt=""/></p>
<p>Figure showing JBrowse 2 piecing together a long read vs the reference genome
from a single read</p>
<p>In order to do this reconstruction, JBrowse 2 takes the <code>CIGAR</code> strings of the
primary alignment and each of the pieces of the <code>SA</code> tag (it is a semi-colon
separated list of chunks), sort them by the amount of softclipping (the
softclipping values will progressively trim off more of the <code>SEQ</code> telling you
it aligned further and further on in the long read), and then this tells me
where each piece of the split alignment came from in the original <code>SEQ</code>, so we
can plot the alignments of the read vs the reference genome using synteny style
display.</p>
<p>[1] Similar functionality also exists in GenomeRibbon
<a href="https://genomeribbon.org">https://genomeribbon.org</a></p>
<h3><code>SAM</code> vs <code>VCF</code> - Breakends vs split alignments</h3>
<p>An interesting outcome (to me) is that from a single record in a <code>SAM</code> file, I
can reconstruct the &quot;derived&quot; genome around a region of interest from a single
read.</p>
<p>If I was to try to do this with the <code>VCF</code> Breakend specification (section 5.4
of <a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">VCF4.3.pdf</a>), it may
actually be more challenging than from a <code>SAM</code> read. This is because a Breakend
in <code>VCF</code> format is only an edge in a graph (and the sequences are nodes).
Therefore, in order to properly reconstruct a structural variant from a <code>VCF</code>
with Breakends, I would have to construct a graph and decode paths through it.</p>
<p>I like the ability to reconstruct the derived genome from a single read, but
individual reads can be noisy (contain errors). That said, <em>de novo</em> assembled
contigs can also be stored in <code>SAM</code> format and is significantly less noisy
(being composed of the aggregate information of many reads).</p>
<p>The point though is that interpretation of the <code>VCF</code> breakend specification is
challenging due to imposing a sequence graph on the genome, while the <code>SA</code> tag
remains just a simple set of linear alignments that can easily be pieced
together, and you only need to refer to a single record in the <code>SAM</code> file to do
so.</p>
<p>I am not aware of a lot of tools that work on the <code>VCF</code> Breakend graph, and
expect more will need to be created to truly work with this standard. An
inversion for example may create 4 record in the <code>VCF</code> file (see section 5.4 in
the <a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">VCF4.3.pdf</a> for
example), and needs careful interpretation.</p>
<h3>Haplotype tagged reads</h3>
<p>A new trend has been to create <code>SAM</code>/<code>BAM</code>/<code>CRAM</code> files with tagged reads,
which tells us which haplotype a read was inferred to have come from. This is
commonly done with the <code>HP</code> tag, which might have <code>HP=0</code> and <code>HP=1</code> for a
diploid genome. Tools like <code>whatshap</code> can add these tags to a <code>SAM</code> file, and
IGV and JBrowse 2 can color and sort by these tags.</p>
<p><img src="/media/color_by_tag.png" alt=""/></p>
<p>Screenshot of JBrowse 2 with the &quot;Color by tag&quot; and &quot;Sort by tag&quot; setting
enabled (coloring and sorting by the <code>HP</code> tag) letting us see that only one
haplotype has a deletion. Tutorial for how to do this in JBrowse 2 here
<a href="https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag">https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag</a></p>
<h2>How do you detect SVs with paired-end reads?</h2>
<p>Paired-end reads are short reads, e.g. 150bp each. This makes them unable to
recover some large structural variants.</p>
<p>However, paired-end reads have a number of attributes that can be used to
detect paired end reads</p>
<h3>Distance between pairs being abnormally large or short</h3>
<p>The distance between pairs is encoded by the <code>TLEN</code> column in the <code>SAM</code> format.
The distance between pairs with good mapping is relatively constant and called
the &quot;insert length&quot;. This comes from how the sequencing is done: paired-end
sequencing performs sequencing on both ends of a fragment.</p>
<p>But, if you are mapping reads vs the reference genome, and you observe that
they are abnormally far apart, say 50kb apart instead of 1kb apart, this may
indicate there your sample contains a deletion relative to the reference.</p>
<p><img src="/media/aberrant_size.png" alt=""/></p>
<p>Screenshot of JBrowse 1 with &quot;View as pairs&quot; enabled, and large insert size
colored as red (from
<a href="https://jbrowse.org/docs/paired_reads.html">https://jbrowse.org/docs/paired_reads.html</a>).
Note that some of JBrowse 1&#x27;s View as pairs features are not yet available in
JBrowse 2</p>
<h3>An abundance of reads being &quot;clipped&quot; at a particular position</h3>
<p>This can indicate that part of the reads map well, but then there was an abrupt
stop to the mapping. This might mean that there is a sequence that was an
insertion at that position, or a deletion, or a translocation.</p>
<p>The clipping is indicated by the <code>CIGAR</code> string, either at the start or end of
it by an <code>S</code> or an <code>H</code>. The <code>S</code> indicates &quot;soft clipping&quot;, and indicates that
the sequence of the clipped portion can be found in the <code>SEQ</code> field of the
primary alignment. The <code>H</code> is hard clipped, and the sequence that is hard
clipped will not appear in the <code>SEQ</code>.</p>
<p><img src="/media/clipping_pileup.png" alt=""/></p>
<p>Screenshot of JBrowse 2 showing blue clipping indicator with a &quot;pileup&quot; of
soft-clipping at a particular position shown in blue. The clipping is an
&quot;interbase&quot; operation (it occurs between base pair coordinates) so it is
plotted separately from the normal coverage histogram.</p>
<p><img src="/media/show_soft_clipping.png" alt=""/></p>
<p>Screenshot of JBrowse 2 showing an insertion with Nanopore (top), PacBio
(middle) and Illumina short reads. The long reads may completely span the
insertion, so the <code>CIGAR</code> string on those have an <code>I</code> operator and are indicated
by the purple triangle above the reads. For the short reads, the reads near the
insertion will be clipped since they will not properly map to the reference
genome and cannot span the sinsertion. The &quot;Show soft clipping&quot; setting in
JBrowse 2 and IGV can be used to show visually the bases that extend into the
insertion (shown on the bottom track).</p>
<h3>Unexpected pair orientation</h3>
<p>With standard paired end sequencing, the pairs normally point at each other</p>
<pre><code>forward reverse
 ---&gt;    &lt;---
</code></pre>
<p>If the stranded-ness of the pair is off, then it could indicate a structural
variant. See Appendix A for a handy function for calculating pair orientation.</p>
<p>This guide from IGV is helpful for interpreting the pair directionality with
patterns of SVs using &quot;Color by pair orientation&quot;</p>
<p><a href="https://software.broadinstitute.org/software/igv/interpreting_pair_orientations">https://software.broadinstitute.org/software/igv/interpreting_pair_orientations</a></p>
<p><img src="/media/inverted_duplication.png" alt=""/></p>
<p>Figure: JBrowse 2 showing an inverted (tandem) duplication in 1000 genomes
data. It uses the same coloring as IGV for pair orientation. The tandem
duplication can produce green arrows which have reads pointing in opposite
directions e.g. <code>&lt;--</code> and <code>--&gt;</code>, while blue arrows which can indicate an
inversion point in the same direction e.g. <code>--&gt;</code> and <code>--&gt;</code></p>
<h3>Caveat about TLEN</h3>
<p>Note that <code>TLEN</code> is a field in the SAM format that is somewhat ill defined,
at least in the sense that different tools may use it differently
<a href="https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767">https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767</a></p>
<p>If needed, you can calculate <code>TLEN</code> yourself if you process the file yourself
(e.g. process all reads, get the actual records for the pairs, and calculate
distance) but I have not had trouble with relying on the <code>TLEN</code> from the data
files themselves.</p>
<h2>Calling copy number variants with your short or long reads</h2>
<p>Another type of SV that you can get from your <code>SAM</code> files are copy number
variants (CNVs). By looking at the depth-of-coverage for your data files, you
can look for abnormalities that may indicate copy number variants. By using a
tool like <code>mosdepth</code>, you can quickly get a file showing the coverage across
the genome.</p>
<p>Be aware that if you are comparing the coverage counts from different tools,
that they have different defaults that may affect comparison. Some discard
<code>QC_FAIL</code>, <code>DUP</code>, and <code>SECONDARY</code> flagged reads. This is probably appropriate,
and corresponds to what most genome browsers will display (see
<a href="https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af">https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af</a> for a short
summary of depth calculated from different tools)</p>
<p>Note that both long and short reads can be used for CNV detection. Long reads
may give more accurate measurements also, with their better ability to map
smoothly through difficult regions of the genome.</p>
<p><img src="/media/coverage_cnv.png" alt=""/></p>
<p>Screenshot showing coverage in <code>BigWig</code> format from nanopore reads on normal
and tumor tissue from a melanoma cancer cell line (COLO829) plotted using
JBrowse 2. This coverage data is calculated from nanopore sequencing from
<a href="https://www.biorxiv.org/content/10.1101/2020.10.15.340497v1.full">here</a> using
<a href="https://github.com/brentp/mosdepth"><code>mosdepth</code></a>, converted from <code>BedGraph</code> to
<code>BigWig</code>, and loaded into JBrowse 2. See
(<a href="https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json&amp;session=share-MZj3d18lzH&amp;password=3X7bS">demo</a>
and
<a href="https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv">tutorial</a>)</p>
<h2>The future, with graph genomes and <em>de novo</em> assemblies</h2>
<p>Currently, SV visualization is highly based on comparing data versus a
reference genome (and the <code>SAM</code> format is a signature of this: it stores data
in terms of reference genome coordinates). In the future, SV visualization may
look more similar to comparative genomics, where we compare an SV to a
population specific reference from a graph genomes or something like this.</p>
<p>It is known that <em>de novo</em> assembly has more power to detect SVs than some read
operations (<a href="https://twitter.com/lh3lh3/status/1362921612690010118/photo/1">https://twitter.com/lh3lh3/status/1362921612690010118/photo/1</a>)
as <em>de novo</em> assembled genomes improve and become more widespread, we may see a
shift in how SVs are called</p>
<p>I would also like to see improved ability to do fast or &#x27;on the fly&#x27; gene
prediction on the <em>de novo</em> assembled genomes, and we can see what SNPs or
modified splicing might look like in copies of genes (e.g. derived regions of
the CNV duplications).</p>
<p>Fun fact: the
<a href="https://github.com/lh3/gfatools/blob/master/doc/rGFA.md#the-graph-alignment-format-gaf"><code>GAF</code></a>
(graphical alignment format) is a strict superset of
<a href="https://github.com/lh3/miniasm/blob/master/PAF.md"><code>PAF</code></a> (pairwise alignment
format) by storing graph node labels in the <code>target name</code> slot of <code>PAF</code>, and
can refer to an <code>rGFA</code> (reference genome graph)! Looking forward to the graph
genome world.</p>
<h2>Conclusion</h2>
<p>Algorithms that actually call structural variants face many challenges, but
understanding how the reads are encoded in SAM format, and seeing what they
look like in the genome browser is a useful first step to gaining a better
understanding.</p>
<p>In summary, some of the signatures of SVs may include:</p>
<ul>
<li>Aberrant insert size (<code>TLEN</code>) detection (longer for deletion, shorter for
insertion)</li>
<li>Aberrant pair orientation (pairs are not pointing at each other)</li>
<li>Split-read detection (<code>SA</code> tag)</li>
<li><code>CIGAR</code> string processing (<code>D</code> operator for deletions, <code>I</code> operator for
insertions)</li>
<li>Over-abundance of clipping (<code>S</code> or <code>H</code> operators in <code>CIGAR</code>)</li>
<li>Depth of coverage changes for CNVs</li>
<li>Aligning <em>de novo</em> assembly vs a reference genome
(<a href="https://twitter.com/lh3lh3/status/1362921612690010118/photo/1">https://twitter.com/lh3lh3/status/1362921612690010118/photo/1</a>
which can output <code>SAM</code>, but it can also output
<a href="https://github.com/lh3/miniasm/blob/master/PAF.md"><code>PAF</code></a> format (which can
be loaded in JBrowse 2 in the synteny views). Techniques of detecting SVs on
PAF will be fundamentally pretty similar to the techniques listed above but
may look a bit different (see <code>cs</code> tag in <code>PAF</code> for example, it is a modified
<code>CIGAR</code>-like string)</li>
</ul>
<p>If you have any ideas I should include here, let me know!</p>
<h3>Appendix A: Parsing <code>CIGAR</code> strings</h3>
<p>This is code that can help determine the pair orientation from a single BAM
record. Might be too much detail but follow along</p>
<pre><code class="language-typescript">// @param flags - flags from a single read
// @param ref - the string of the reference sequence, just used to determine if it matches rnext
// @param rnext - the string of the RNEXT, just used to determine if it matches ref
// @param tlen - the TLEN field from SAM
// @return e.g. F1R2 normal paired end orientation
function getPairOrientation(
  flags: number,
  ref: string,
  rnext: string,
  tlen: number,
) {
  // this read is not unmapped &amp;&amp;
  // this read&#x27;s mate is also not unmapped &amp;&amp;
  // this read&#x27;s mate is on the same reference genome
  if (!flags &amp; 4 &amp;&amp; !flags &amp; 8 &amp;&amp; ref === rnext) {
    const s1 = flags &amp; 16 ? &#x27;R&#x27; : &#x27;F&#x27;
    const s2 = flags &amp; 32 ? &#x27;R&#x27; : &#x27;F&#x27;
    let o1 = &#x27; &#x27;
    let o2 = &#x27; &#x27;

    // if first in pair
    if (flags &amp; 64) {
      o1 = &#x27;1&#x27;
      o2 = &#x27;2&#x27;
    }

    // else if second in pair
    else if (flags &amp; 128) {
      o1 = &#x27;2&#x27;
      o2 = &#x27;1&#x27;
    }

    const tmp = []
    if (tlen &gt; 0) {
      tmp[0] = s1
      tmp[1] = o1
      tmp[2] = s2
      tmp[3] = o2
    } else {
      tmp[2] = s1
      tmp[3] = o1
      tmp[0] = s2
      tmp[1] = o2
    }
    return tmp.join(&#x27;&#x27;)
  }
  return null
}
</code></pre>
<p>Then this can be broken down further by orientation type</p>
<p>Paired end reads are &quot;fr&quot;
Mate pair reads are &quot;rf&quot;</p>
<p>So you can interpret e.g. F1R2 in relation to being a paired end read (fr) or mate pair (rf) below and with this link <a href="https://software.broadinstitute.org/software/igv/interpreting_pair_orientations">https://software.broadinstitute.org/software/igv/interpreting_pair_orientations</a></p>
<pre><code class="language-json">{
  &quot;fr&quot;: {
    &quot;F1R2&quot;: &quot;LR&quot;,
    &quot;F2R1&quot;: &quot;LR&quot;,

    &quot;F1F2&quot;: &quot;LL&quot;,
    &quot;F2F1&quot;: &quot;LL&quot;,

    &quot;R1R2&quot;: &quot;RR&quot;,
    &quot;R2R1&quot;: &quot;RR&quot;,

    &quot;R1F2&quot;: &quot;RL&quot;,
    &quot;R2F1&quot;: &quot;RL&quot;
  },

  &quot;rf&quot;: {
    &quot;R1F2&quot;: &quot;LR&quot;,
    &quot;R2F1&quot;: &quot;LR&quot;,

    &quot;R1R2&quot;: &quot;LL&quot;,
    &quot;R2R1&quot;: &quot;LL&quot;,

    &quot;F1F2&quot;: &quot;RR&quot;,
    &quot;F2F1&quot;: &quot;RR&quot;,

    &quot;F1R2&quot;: &quot;RL&quot;,
    &quot;F2R1&quot;: &quot;RL&quot;
  }
}
</code></pre>
<h3>Appendix B - <code>CIGAR</code> parsing</h3>
<pre><code class="language-typescript">// @param cigar: CIGAR string in text form
function parseCigar(cigar: string) {
  return cigar.split(/([MIDNSHPX=])/)
}
</code></pre>
<p>Then parse the returned array two at a time</p>
<pre><code class="language-typescript">// this function does nothing, but is informative for how to parse interpret a
// CIGAR string
// @param cigar:CIGAR string from record
// @param readSeq: the SEQ from record
// @param refSeq: the reference sequence underlying the read
function interpretCigar(cigar: string, readSeq: string, refSeq: string) {
  const opts = parseCigar(cigar)
  let qpos = 0 // query position, position on the read
  let tpos = 0 // target position, position on the reference sequence
  for (let i = 0; i &lt; ops.length; i += 2) {
    const length = +opts[i]
    const operator = opts[i + 1]
    // do things. refer to the CIGAR chart in SAMv1.pdf for which operators
    // &quot;consume reference&quot; to see whether to increment
    if (op === &#x27;M&#x27; || op === &#x27;=&#x27;) {
      // matches consume query and reference
      qpos += len
      tpos += len
    }
    if (op === &#x27;I&#x27;) {
      // insertions only consume query
      // sequence of the insertion from the read is
      const insSeq = readSeq.slice(qpos, qpos + len)
      qpos += len
    }
    if (op === &#x27;D&#x27;) {
      // deletions only consume reference
      // sequence of the deletion from the reference is
      const delSeq = refSeq.slice(tpos, tpos + len)
      tpad += len
    }
    if (op === &#x27;N&#x27;) {
      // skips only consume reference
      // skips are similar to deletions but are related to spliced alignments
      tpad += len
    }
    if (op === &#x27;X&#x27;) {
      // mismatch using the extended CIGAR format
      // could lookup the mismatch letter in a string containing the reference
      const mismatch = refSeq.slice(tpos, tpos + len)
      qpos += len
      tpos += len
    }
    if (op === &#x27;H&#x27;) {
      // does not consume query or reference
      // hardclip is just an indicator
    }
    if (op === &#x27;S&#x27;) {
      // softclip consumes query
      // below gets the entire soft clipped portion
      const softClipStr = readSeq.slice(qpos, qpos + len)
      qpos += len
    }
  }
}
</code></pre>
<p>Note for example, that to determine how long a record is on the reference
sequence, you have to combine the records start position with the CIGAR string,
basically parsing the CIGAR string to add up tpos and return tpos</p>
<h3>Appendix C - align <code>FASTQ</code> directly to <code>CRAM</code></h3>
<p>This example from the htslib documentation
(<a href="http://www.htslib.org/workflow/fastq.html">http://www.htslib.org/workflow/fastq.html</a>)
shows how you can stream directly from <code>FASTQ</code> to <code>CRAM</code> (and generate the
index file .crai too)</p>
<p>If you want, you can make this a little shell script, easy_align_shortreads.sh</p>
<p>easy_align_shortreads.sh</p>
<pre><code class="language-sh">#!/bin/bash
minimap2 -t 8 -a -x sr &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;  | \
samtools fixmate -u -m - - | \
samtools sort -u -@2 - | \
samtools markdup -@8 --reference &quot;$1&quot; - --write-index &quot;$4&quot;
</code></pre>
<p>Similar idea for longreads, except just a single fastq file is generally used for longreads</p>
<p>easy_align_longreads.sh</p>
<pre><code class="language-sh">#!/bin/bash
minimap2 -t 8 -a &quot;$1&quot; &quot;$2&quot;  | \
samtools fixmate -u -m - - | \
samtools sort -u -@2 - | \
samtools markdup -@8 --reference &quot;$1&quot; - --write-index &quot;$3&quot;
</code></pre>
<p>Then call</p>
<pre><code class="language-sh">bash easy_align_shortreads.sh ref.fa reads1.fq reads2.fq out.cram
bash easy_align_longreads.sh ref.fa reads.fq out.cram

## output BAM instead
bash easy_align_shortreads.sh ref.fa reads1.fq reads2.fq out.bam
bash easy_align_longreads.sh ref.fa reads.fq out.bam
</code></pre>
<p>This same concept works with other common aligners as well like bwa</p>
<p>Bonus: CRAM to bigwig, for looking at CNV/coverage</p>
<pre><code class="language-sh">#!/bin/bash
# quickalign.sh ref.fa 1.fq 2.fq out.cram
# produces out.cram and out.bw
samtools faidx $1
minimap2 -t 8 -a -x sr &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;  | \
samtools fixmate -u -m - - | \
samtools sort -u -@2 - | \
samtools markdup -@8 --reference &quot;$1&quot; - --write-index &quot;$4&quot;


mosdepth $4 -f $1 $4
gunzip $4.per-base.bed.gz
bedGraphToBigWig $4.per-base.bed $1.fa.fai $4.bw
</code></pre>
<p>Call as &quot;quickalign.sh ref.fa 1.fq 2.fq out.cram&quot; gives you out.cram, out.cram.crai, and out.cram.bw (coverage)</p>
<h3>Appendix D - the <code>MD</code> tag and finding SNPs in reads</h3>
<p>The <code>MD</code> tag helps tell you where the mismatches are without looking at the
reference genome. This is useful because as I mentioned, <code>CIGAR</code> can say <code>50M</code>
(50 matches) but some letters inside those 50 matches can be mismatches, it
only says there are no insertions/deletions in those 50 bases, but you have to
determine where in those 50 bases where the mismatches are. The <code>MD</code> tag can
help tell you where those are, but it is somewhat complicated to decode
(<a href="https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html">https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html</a>).
You have to combine it with the <code>CIGAR</code> to get the position of the mismatches
on the reference genome. If you have a reference genome to look at, you might
just compare all the bases within the 50M to the reference genome and look for
mismatches yourself and forget about the <code>MD</code> tag</p>
<p>The <code>MD</code> tag is also not required to exist, but the command <code>samtools calmd yourfile.bam --reference reference.fa</code> can add <code>MD</code> tags to your <code>BAM</code> file. It
is generally not useful for <code>CRAM</code> because <code>CRAM</code> actually does store
mismatches with the reference genome in it&#x27;s compression format. Note that
there are also some oddities about <code>MD</code> tag representation leading to
complaints (e.g.
<a href="https://github.com/samtools/hts-specs/issues/505">https://github.com/samtools/hts-specs/issues/505</a>)
leading more credence to &quot;doing it yourself&quot; e.g. finding your own mismatches
by comparing the read sequence with the reference, keeping track of where you
are on the read and ref position with the <code>CIGAR</code> string (a la Appendix B)</p><div style="margin-top:200px"></div></article></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <a href="/archive">Blog archive</a> <a href="https://github.com/cmdcolin/">Github</a> <a href="https://twitter.com/cmdcolin">Twitter</a> <a href="/projects">Projects</a> <a href="/photos">Photos</a> <a href="/rss.xml">RSS</a><a href="/about">About</a> </footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Structural variants and the SAM format - the long (reads) and short (reads) of it","date":"2022-02-06","slug":"2022-02-06-sv-sam","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    em: \"em\",\n    img: \"img\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" specification is pretty amazing\\n(\", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n        children: \"https://samtools.github.io/hts-specs/SAMv1.pdf\"\n      }), \")\\nbut it is also fairly terse and abstract. True understanding might come from\\nplaying with real world data. I will try to relay some things I have learned\\nover the years, with a bit of a focus on how \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file concepts can relate to\\nstructural variants.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Disclaimer: I'm a developer of JBrowse 2. This document has some screenshots\\nand links for it, feel free to try it at\\n\", _jsx(_components.a, {\n        href: \"https://jbrowse.org\",\n        children: \"https://jbrowse.org\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Basics\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"What is a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file and how does it relate to \", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \"?\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"A \", _jsx(_components.code, {\n            children: \"SAM\"\n          }), \" file \", _jsx(_components.strong, {\n            children: \"generally\"\n          }), \" contains \\\"reads\\\" from a sequencer, with information\\nabout how they are mapped to a reference genome [1][2].\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"A \", _jsx(_components.code, {\n            children: \"SAM\"\n          }), \" file is \", _jsx(_components.strong, {\n            children: \"generally\"\n          }), \" produced when an aligner takes in raw unaligned reads\\n(often stored in \", _jsx(_components.code, {\n            children: \"FASTQ\"\n          }), \" format files) and aligns them to a reference genome [3].\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"A \", _jsx(_components.code, {\n            children: \"SAM\"\n          }), \" file is a text format that you can read with your text editor. \", _jsx(_components.code, {\n            children: \"BAM\"\n          }), \" and\\n\", _jsx(_components.code, {\n            children: \"CRAM\"\n          }), \" are compressed representations of the \", _jsx(_components.code, {\n            children: \"SAM\"\n          }), \" format.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can convert \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \" with samtools\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"samtools view file.sam -o file.bam\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also convert a \", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \" back to \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" with samtools view\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"samtools view -h file.bam -o file.sam\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The -h just makes sure to preserve the header.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you are converting \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \", it may require the -T argument to\\nspecify your reference sequence (this is because the \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" is \\\"reference\\ncompressed\\\")\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"samtools view -T reference.fa file.sam -o file.cram\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Also see Appendix C: piping FASTQ from \", _jsx(_components.code, {\n        children: \"minimap2\"\n      }), \" directly to CRAM\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"[1] \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" can contain any type of sequence, not specifically reads. If you\\ncreated a \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembly, you could align the contigs of the \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembly\\nto a reference genome and store the results in \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"[2] Does not always have to have information about mapping to a reference\\ngenome. You can also store unaligned data in \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \"/\", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \"/\", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" (so-called\\n\", _jsx(_components.code, {\n        children: \"uBAM\"\n      }), \" for example) but most of the time, the reads in \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" format are aligned\\nto a reference genome.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"[3] Examples of programs that do alignment include \", _jsx(_components.code, {\n        children: \"bwa\"\n      }), \", \", _jsx(_components.code, {\n        children: \"bowtie\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"minimap2\"\n      }), \"\\n(there are many others). These programs all can produce \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" outputs\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"What is in a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file contains a header (\", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" files also have the \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \"\\nheader) and a series of records. A record is a single line in a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file, and\\nit generally corresponds to a single read, but as we will see, a split\\nalignment may produce multiple records that refer to the same source read.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note: if a read failed to align to the reference genome, it may still be in\\nyour \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file, marked as unmapped using the flag column. Sometimes, \\\"dumpster\\ndiving\\\" (looking at the unmapped records from a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file) can be used to aid\\nstructural variant searches (e.g. there may be novel sequence in there not from\\nthe reference genome that could be assembled)\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"What are tags in a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A SAM file has a core set of required fields, and then an arbitrary list of\\nextra columns called tags. The tags have a two character abbreviation like \", _jsx(_components.code, {\n        children: \"MQ\"\n      }), \"\\n(mapping quality) or many others. They can be upper or lower case. Upper case\\nare reserved for official usages (except those with X, Y, or Z prefixed). See\\n\", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMtags.pdf\",\n        children: \"SAMtags.pdf\"\n      }), \" for more\\ndetails\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"What is a \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" string\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" string is a \\\"compact idiosyncratic gapped alignment report\\\". It tells\\nyou about insertions, deletions, and clipping. It is a series of \\\"operators\\\"\\nwith lengths.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Insertion example:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"50M50I50M\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"That would be 50bp of matching bases (\", _jsx(_components.code, {\n        children: \"50M\"\n      }), \"), followed by a 50bp insertion\\n(\", _jsx(_components.code, {\n        children: \"50I\"\n      }), \"), followed by another 50bp of matches (\", _jsx(_components.code, {\n        children: \"50M\"\n      }), \"). The 50bp insertion means\\nthe read contains 50 bases in the middle which did not match the reference\\ngenome that you are comparing the read to.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Clipping example:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"50S50M50S\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This means that 50bp matched (\", _jsx(_components.code, {\n        children: \"50M\"\n      }), \" in the middle of the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" string) and\\nboth sides of the read are soft clipped. The clipping means the aligner was not\\nable to align the reads on either side. You could imagine clipping being like\\n\\\"an insertion on either side of the read\\\" if you like: basically those bases on\\neither side did not align.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Notes:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.em, {\n            children: \"Finding mismatches\"\n          }), \": A \", _jsx(_components.code, {\n            children: \"CIGAR\"\n          }), \" string match like \", _jsx(_components.code, {\n            children: \"50M\"\n          }), \" means 50 bases\\n\\\"matched\\\" the reference genome, but that only means that there are no\\ninsertions or deletions in those 50 bases. There could be underlying\\nmismatches in the read compared to the reference. Note: there is also\\nextended \", _jsx(_components.code, {\n            children: \"CIGAR\"\n          }), \" that replaces \", _jsx(_components.code, {\n            children: \"M\"\n          }), \" with \", _jsx(_components.code, {\n            children: \"=\"\n          }), \" (exact match) and \", _jsx(_components.code, {\n            children: \"X\"\n          }), \" (mismatch).\\nAlso see Appendix D on the \", _jsx(_components.code, {\n            children: \"MD\"\n          }), \" tag and finding where the mismatches are, but\\nnote that \", _jsx(_components.code, {\n            children: \"MD\"\n          }), \" tag is tricky\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.em, {\n            children: \"Ambiguity of representation\"\n          }), \": A \", _jsx(_components.code, {\n            children: \"CIGAR\"\n          }), \" string with insertions and deletions\\ncould be \", _jsx(_components.code, {\n            children: \"50M1D1I50M\"\n          }), \". This string had a 1bp deletion and a 1bp insertion\\nback-to-back. This could be just a mismatch! There is ambiguity in sequence\\nalignment representations. Downstream programs must accomodate this.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.em, {\n            children: \"Split records and soft-clipping\"\n          }), \": A \", _jsx(_components.code, {\n            children: \"CIGAR\"\n          }), \" string with soft-clipping\\n\", _jsx(_components.code, {\n            children: \"500S50M\"\n          }), \" this means that 500 bases of the read were not aligned at this\\nposition, but 50 bases were! Note that the alignment might have been a split\\nalignment (see section on split alignments below) so another record in the\\n\", _jsx(_components.code, {\n            children: \"SAM\"\n          }), \" file, linked by the \", _jsx(_components.code, {\n            children: \"SA\"\n          }), \" (supplmentary alignment) tag, might contain\\ninfo on where the other 500 bases aligned! (or, they might not map anywhere).\\nThe linked split or supplementary alignments all have the same read name\\n(\", _jsx(_components.code, {\n            children: \"QNAME\"\n          }), \").\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"See \", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n        children: \"SAMv1.pdf\"\n      }), \" for all the\\nCIGAR operators.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you are working with \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" data, you will often write loops that directly\\nparse CIGAR strings. See Appendix B for handy functions for parsing \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \"\\nstrings. Don't fear the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \"!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Detecting SVs from long reads\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Long reads offer a wide array of methods for detecting SVs\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Small insertions/deletions\"\n        }), \": Long reads can completely span moderate sized\\ninsertions and deletions, indicated by \", _jsx(_components.code, {\n          children: \"I\"\n        }), \" or \", _jsx(_components.code, {\n          children: \"D\"\n        }), \" in a \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" string.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Large insertions/deletions\"\n        }), \": If a long read does not completely span an\\ninsertion or deletion, it may be split aligned on either side of the SV or\\ncould be soft/hard clipped where it can't align all the way through an\\ninsertion.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Translocations\"\n        }), \": A split long alignment can span long range or even\\ninter-chromosomal translocations, so part of the read maps to one chromosome\\nand one part maps to the other\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.em, {\n          children: \"Inversions\"\n        }), \": A split alignment can span an inversion, the long read is split\\ninto multiple parts, one part of it aligns in the reverse orientation, while\\nthe other part aligns in the forward orientation\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note that there are many different methods for detecting SVs from long reads,\\ne.g. not all use mapped reads from SAM files, some use \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembly, but\\nit is still useful to be familiar with mapped read methods.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"What are split alignments?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Split alignments, or chimeric alignments, are alignments where part of the read\\nmaps to one place, and another part to another. For example, part of a long\\nread may map to \", _jsx(_components.code, {\n        children: \"chr1\"\n      }), \" and part of it maps to \", _jsx(_components.code, {\n        children: \"chr4\"\n      }), \". It is worth reading the\\ndefinition of \\\"Chimeric alignment\\\" from\\n\", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n        children: \"SAMv1.pdf\"\n      }), \" when you get the\\nchance.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Split alignments are especially common with long reads, and it can indicate\\nlarge structural variants. There may be a structural variant where the two\\nchromosomes are fused together, and parts of the read align to multiple\\nchromosomes, or the split alignment may align to either side of a large\\ndeletion, or they may be split to align through an inversion (part of it aligns\\nto the forward strand, part of it to the reverse strand, and again the forward\\nstrand)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There is no limitation on how many splits might occur so the split can align to\\n3, 4, or more different places. Each part of the split puts a new line in the\\nSAM file, and note that all the records also have the same read name, or \", _jsx(_components.code, {\n        children: \"QNAME\"\n      }), \" (first\\ncolumn of \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \").\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As \", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n        children: \"SAMv1.pdf\"\n      }), \" tells us, one\\nrecord is marked as \\\"representative\\\", I call this the \\\"primary\\\" record, while\\nthe other components of the split read are maked supplementary, given the 2048\\nflag. Only the \\\"primary\\\" record generally has a \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \" field. The split\\nalignments are generally also all given a \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag that gives info on where all\\nthe other parts of the split are. See\\n\", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMtags.pdf\",\n        children: \"SAMtags.pdf\"\n      }), \" for more info\\non the \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note: split alignments are different from \\\"multi-mappers\\\" where the entire read\\nmaps maps equally well to, say, \", _jsx(_components.code, {\n        children: \"chr4\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"chr1\"\n      }), \". Split reads maps part to\\nchr1, and part to \", _jsx(_components.code, {\n        children: \"chr4\"\n      }), \". See again the\\n\", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n        children: \"SAMv1.pdf\"\n      }), \" for the definition\\nof multi-mapping\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"What is the \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag is outputted on each part of the split alignment, e.g. the primary\\ncontains an \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag that refers to all the locations, \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" strings, and\\nmore for all the supplementary reads, and each of the supplementary reads also\\ncontains an \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag that refers to the primary alignment and each other\\nsupplementary alignment.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Fun fact: The \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag conceptually can result in a 'quadratic explosion' of\\ndata, because each part of the split contains references to every other part.\\nFor example, if a read is split into 4 pieces, then each record would would\\nhave an \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag with 3 segments, so 3*4 segments will be documented in the\\n\", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag. In many cases, this is not a problem, but if you imagine a finished\\nchromosome aligned to a draft assembly, it may get split so many times\\nthis could be a factor.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Visualizing split reads across a breakend or translocation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is a specialized JBrowse 2 feature, but if there is an inter-chromosomal\\ntranslocation, you can load this into JBrowse and visualize support for this\\nevent using our \\\"breakpoint split view\\\". This view shows the evidence for the\\nreads that are split aligned across an SV, and can show connections between\\npaired-end reads across an SV too.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We also have a workflow called the \\\"SV inspector\\\" that helps you setup the\\n\\\"breakpoint split views\\\"\\n(\", _jsx(_components.a, {\n        href: \"https://jbrowse.org/jb2/docs/user_guide/#sv-inspector\",\n        children: \"https://jbrowse.org/jb2/docs/user_guide/#sv-inspector\"\n      }), \".\\nThe SV inspector and Breakpoint split view work best on Breakends (e.g. VCF 4.3\\nsection 5.4) and \", _jsx(_components.code, {\n        children: \"\u003cTRA\u003e\"\n      }), \" (translocation) events from \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \", or \", _jsx(_components.code, {\n        children: \"BEDPE\"\n      }), \"\\nformatted SV calls, and you can launch the \\\"breakpoint split view\\\" from the \\\"SV\\ninspector\\\"\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/breakpoint_split_view.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Visualizing a 'read vs reference' view given a split alignment\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If we are given the the primary alignment of an arbitrary split read, then we\\ncan construct what that split looks like compared to the reference genome.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we are not given the primary alignment (e.g. we are starting from a\\nsupplementary alignment) then we can search the \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" list for the one that is\\nprimary, because at least one will be.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now that we have the primary alignment, it will have the \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \" (of the entire\\nread, the supplementary alignments typically have a blank \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \"!) and the \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \"\\ntag containing the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" of all the different parts of the split. We can then\\nconstruct how the entire read, not just a particular record of the split\\nalignment, compares to the genome. In JBrowse 2 we implemented this and it uses\\na synteny-style rendering. [1]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/linear_alignment.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Figure showing JBrowse 2 piecing together a long read vs the reference genome\\nfrom a single read\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to do this reconstruction, JBrowse 2 takes the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" strings of the\\nprimary alignment and each of the pieces of the \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag (it is a semi-colon\\nseparated list of chunks), sort them by the amount of softclipping (the\\nsoftclipping values will progressively trim off more of the \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \" telling you\\nit aligned further and further on in the long read), and then this tells me\\nwhere each piece of the split alignment came from in the original \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \", so we\\ncan plot the alignments of the read vs the reference genome using synteny style\\ndisplay.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"[1] Similar functionality also exists in GenomeRibbon\\n\", _jsx(_components.a, {\n        href: \"https://genomeribbon.org\",\n        children: \"https://genomeribbon.org\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [_jsx(_components.code, {\n        children: \"SAM\"\n      }), \" vs \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \" - Breakends vs split alignments\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An interesting outcome (to me) is that from a single record in a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file, I\\ncan reconstruct the \\\"derived\\\" genome around a region of interest from a single\\nread.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If I was to try to do this with the \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \" Breakend specification (section 5.4\\nof \", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/VCFv4.3.pdf\",\n        children: \"VCF4.3.pdf\"\n      }), \"), it may\\nactually be more challenging than from a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" read. This is because a Breakend\\nin \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \" format is only an edge in a graph (and the sequences are nodes).\\nTherefore, in order to properly reconstruct a structural variant from a \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \"\\nwith Breakends, I would have to construct a graph and decode paths through it.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I like the ability to reconstruct the derived genome from a single read, but\\nindividual reads can be noisy (contain errors). That said, \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembled\\ncontigs can also be stored in \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" format and is significantly less noisy\\n(being composed of the aggregate information of many reads).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The point though is that interpretation of the \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \" breakend specification is\\nchallenging due to imposing a sequence graph on the genome, while the \", _jsx(_components.code, {\n        children: \"SA\"\n      }), \" tag\\nremains just a simple set of linear alignments that can easily be pieced\\ntogether, and you only need to refer to a single record in the \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file to do\\nso.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I am not aware of a lot of tools that work on the \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \" Breakend graph, and\\nexpect more will need to be created to truly work with this standard. An\\ninversion for example may create 4 record in the \", _jsx(_components.code, {\n        children: \"VCF\"\n      }), \" file (see section 5.4 in\\nthe \", _jsx(_components.a, {\n        href: \"https://samtools.github.io/hts-specs/VCFv4.3.pdf\",\n        children: \"VCF4.3.pdf\"\n      }), \" for\\nexample), and needs careful interpretation.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Haplotype tagged reads\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A new trend has been to create \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \"/\", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \"/\", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" files with tagged reads,\\nwhich tells us which haplotype a read was inferred to have come from. This is\\ncommonly done with the \", _jsx(_components.code, {\n        children: \"HP\"\n      }), \" tag, which might have \", _jsx(_components.code, {\n        children: \"HP=0\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"HP=1\"\n      }), \" for a\\ndiploid genome. Tools like \", _jsx(_components.code, {\n        children: \"whatshap\"\n      }), \" can add these tags to a \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" file, and\\nIGV and JBrowse 2 can color and sort by these tags.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/color_by_tag.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Screenshot of JBrowse 2 with the \\\"Color by tag\\\" and \\\"Sort by tag\\\" setting\\nenabled (coloring and sorting by the \", _jsx(_components.code, {\n        children: \"HP\"\n      }), \" tag) letting us see that only one\\nhaplotype has a deletion. Tutorial for how to do this in JBrowse 2 here\\n\", _jsx(_components.a, {\n        href: \"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\",\n        children: \"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How do you detect SVs with paired-end reads?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Paired-end reads are short reads, e.g. 150bp each. This makes them unable to\\nrecover some large structural variants.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"However, paired-end reads have a number of attributes that can be used to\\ndetect paired end reads\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Distance between pairs being abnormally large or short\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The distance between pairs is encoded by the \", _jsx(_components.code, {\n        children: \"TLEN\"\n      }), \" column in the \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" format.\\nThe distance between pairs with good mapping is relatively constant and called\\nthe \\\"insert length\\\". This comes from how the sequencing is done: paired-end\\nsequencing performs sequencing on both ends of a fragment.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But, if you are mapping reads vs the reference genome, and you observe that\\nthey are abnormally far apart, say 50kb apart instead of 1kb apart, this may\\nindicate there your sample contains a deletion relative to the reference.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/aberrant_size.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Screenshot of JBrowse 1 with \\\"View as pairs\\\" enabled, and large insert size\\ncolored as red (from\\n\", _jsx(_components.a, {\n        href: \"https://jbrowse.org/docs/paired_reads.html\",\n        children: \"https://jbrowse.org/docs/paired_reads.html\"\n      }), \").\\nNote that some of JBrowse 1's View as pairs features are not yet available in\\nJBrowse 2\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"An abundance of reads being \\\"clipped\\\" at a particular position\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This can indicate that part of the reads map well, but then there was an abrupt\\nstop to the mapping. This might mean that there is a sequence that was an\\ninsertion at that position, or a deletion, or a translocation.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The clipping is indicated by the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" string, either at the start or end of\\nit by an \", _jsx(_components.code, {\n        children: \"S\"\n      }), \" or an \", _jsx(_components.code, {\n        children: \"H\"\n      }), \". The \", _jsx(_components.code, {\n        children: \"S\"\n      }), \" indicates \\\"soft clipping\\\", and indicates that\\nthe sequence of the clipped portion can be found in the \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \" field of the\\nprimary alignment. The \", _jsx(_components.code, {\n        children: \"H\"\n      }), \" is hard clipped, and the sequence that is hard\\nclipped will not appear in the \", _jsx(_components.code, {\n        children: \"SEQ\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/clipping_pileup.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Screenshot of JBrowse 2 showing blue clipping indicator with a \\\"pileup\\\" of\\nsoft-clipping at a particular position shown in blue. The clipping is an\\n\\\"interbase\\\" operation (it occurs between base pair coordinates) so it is\\nplotted separately from the normal coverage histogram.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/show_soft_clipping.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Screenshot of JBrowse 2 showing an insertion with Nanopore (top), PacBio\\n(middle) and Illumina short reads. The long reads may completely span the\\ninsertion, so the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" string on those have an \", _jsx(_components.code, {\n        children: \"I\"\n      }), \" operator and are indicated\\nby the purple triangle above the reads. For the short reads, the reads near the\\ninsertion will be clipped since they will not properly map to the reference\\ngenome and cannot span the sinsertion. The \\\"Show soft clipping\\\" setting in\\nJBrowse 2 and IGV can be used to show visually the bases that extend into the\\ninsertion (shown on the bottom track).\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Unexpected pair orientation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With standard paired end sequencing, the pairs normally point at each other\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forward reverse\\n ---\u003e    \u003c---\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If the stranded-ness of the pair is off, then it could indicate a structural\\nvariant. See Appendix A for a handy function for calculating pair orientation.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This guide from IGV is helpful for interpreting the pair directionality with\\npatterns of SVs using \\\"Color by pair orientation\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\",\n        children: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/inverted_duplication.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Figure: JBrowse 2 showing an inverted (tandem) duplication in 1000 genomes\\ndata. It uses the same coloring as IGV for pair orientation. The tandem\\nduplication can produce green arrows which have reads pointing in opposite\\ndirections e.g. \", _jsx(_components.code, {\n        children: \"\u003c--\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"--\u003e\"\n      }), \", while blue arrows which can indicate an\\ninversion point in the same direction e.g. \", _jsx(_components.code, {\n        children: \"--\u003e\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"--\u003e\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Caveat about TLEN\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note that \", _jsx(_components.code, {\n        children: \"TLEN\"\n      }), \" is a field in the SAM format that is somewhat ill defined,\\nat least in the sense that different tools may use it differently\\n\", _jsx(_components.a, {\n        href: \"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\",\n        children: \"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If needed, you can calculate \", _jsx(_components.code, {\n        children: \"TLEN\"\n      }), \" yourself if you process the file yourself\\n(e.g. process all reads, get the actual records for the pairs, and calculate\\ndistance) but I have not had trouble with relying on the \", _jsx(_components.code, {\n        children: \"TLEN\"\n      }), \" from the data\\nfiles themselves.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Calling copy number variants with your short or long reads\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Another type of SV that you can get from your \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" files are copy number\\nvariants (CNVs). By looking at the depth-of-coverage for your data files, you\\ncan look for abnormalities that may indicate copy number variants. By using a\\ntool like \", _jsx(_components.code, {\n        children: \"mosdepth\"\n      }), \", you can quickly get a file showing the coverage across\\nthe genome.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Be aware that if you are comparing the coverage counts from different tools,\\nthat they have different defaults that may affect comparison. Some discard\\n\", _jsx(_components.code, {\n        children: \"QC_FAIL\"\n      }), \", \", _jsx(_components.code, {\n        children: \"DUP\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"SECONDARY\"\n      }), \" flagged reads. This is probably appropriate,\\nand corresponds to what most genome browsers will display (see\\n\", _jsx(_components.a, {\n        href: \"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\",\n        children: \"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\"\n      }), \" for a short\\nsummary of depth calculated from different tools)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note that both long and short reads can be used for CNV detection. Long reads\\nmay give more accurate measurements also, with their better ability to map\\nsmoothly through difficult regions of the genome.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/coverage_cnv.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Screenshot showing coverage in \", _jsx(_components.code, {\n        children: \"BigWig\"\n      }), \" format from nanopore reads on normal\\nand tumor tissue from a melanoma cancer cell line (COLO829) plotted using\\nJBrowse 2. This coverage data is calculated from nanopore sequencing from\\n\", _jsx(_components.a, {\n        href: \"https://www.biorxiv.org/content/10.1101/2020.10.15.340497v1.full\",\n        children: \"here\"\n      }), \" using\\n\", _jsx(_components.a, {\n        href: \"https://github.com/brentp/mosdepth\",\n        children: _jsx(_components.code, {\n          children: \"mosdepth\"\n        })\n      }), \", converted from \", _jsx(_components.code, {\n        children: \"BedGraph\"\n      }), \" to\\n\", _jsx(_components.code, {\n        children: \"BigWig\"\n      }), \", and loaded into JBrowse 2. See\\n(\", _jsx(_components.a, {\n        href: \"https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json\u0026session=share-MZj3d18lzH\u0026password=3X7bS\",\n        children: \"demo\"\n      }), \"\\nand\\n\", _jsx(_components.a, {\n        href: \"https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv\",\n        children: \"tutorial\"\n      }), \")\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"The future, with graph genomes and \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assemblies\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Currently, SV visualization is highly based on comparing data versus a\\nreference genome (and the \", _jsx(_components.code, {\n        children: \"SAM\"\n      }), \" format is a signature of this: it stores data\\nin terms of reference genome coordinates). In the future, SV visualization may\\nlook more similar to comparative genomics, where we compare an SV to a\\npopulation specific reference from a graph genomes or something like this.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It is known that \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembly has more power to detect SVs than some read\\noperations (\", _jsx(_components.a, {\n        href: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\",\n        children: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"\n      }), \")\\nas \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembled genomes improve and become more widespread, we may see a\\nshift in how SVs are called\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I would also like to see improved ability to do fast or 'on the fly' gene\\nprediction on the \", _jsx(_components.em, {\n        children: \"de novo\"\n      }), \" assembled genomes, and we can see what SNPs or\\nmodified splicing might look like in copies of genes (e.g. derived regions of\\nthe CNV duplications).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Fun fact: the\\n\", _jsx(_components.a, {\n        href: \"https://github.com/lh3/gfatools/blob/master/doc/rGFA.md#the-graph-alignment-format-gaf\",\n        children: _jsx(_components.code, {\n          children: \"GAF\"\n        })\n      }), \"\\n(graphical alignment format) is a strict superset of\\n\", _jsx(_components.a, {\n        href: \"https://github.com/lh3/miniasm/blob/master/PAF.md\",\n        children: _jsx(_components.code, {\n          children: \"PAF\"\n        })\n      }), \" (pairwise alignment\\nformat) by storing graph node labels in the \", _jsx(_components.code, {\n        children: \"target name\"\n      }), \" slot of \", _jsx(_components.code, {\n        children: \"PAF\"\n      }), \", and\\ncan refer to an \", _jsx(_components.code, {\n        children: \"rGFA\"\n      }), \" (reference genome graph)! Looking forward to the graph\\ngenome world.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Algorithms that actually call structural variants face many challenges, but\\nunderstanding how the reads are encoded in SAM format, and seeing what they\\nlook like in the genome browser is a useful first step to gaining a better\\nunderstanding.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In summary, some of the signatures of SVs may include:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Aberrant insert size (\", _jsx(_components.code, {\n          children: \"TLEN\"\n        }), \") detection (longer for deletion, shorter for\\ninsertion)\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Aberrant pair orientation (pairs are not pointing at each other)\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Split-read detection (\", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" string processing (\", _jsx(_components.code, {\n          children: \"D\"\n        }), \" operator for deletions, \", _jsx(_components.code, {\n          children: \"I\"\n        }), \" operator for\\ninsertions)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Over-abundance of clipping (\", _jsx(_components.code, {\n          children: \"S\"\n        }), \" or \", _jsx(_components.code, {\n          children: \"H\"\n        }), \" operators in \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \")\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Depth of coverage changes for CNVs\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Aligning \", _jsx(_components.em, {\n          children: \"de novo\"\n        }), \" assembly vs a reference genome\\n(\", _jsx(_components.a, {\n          href: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\",\n          children: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"\n        }), \"\\nwhich can output \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \", but it can also output\\n\", _jsx(_components.a, {\n          href: \"https://github.com/lh3/miniasm/blob/master/PAF.md\",\n          children: _jsx(_components.code, {\n            children: \"PAF\"\n          })\n        }), \" format (which can\\nbe loaded in JBrowse 2 in the synteny views). Techniques of detecting SVs on\\nPAF will be fundamentally pretty similar to the techniques listed above but\\nmay look a bit different (see \", _jsx(_components.code, {\n          children: \"cs\"\n        }), \" tag in \", _jsx(_components.code, {\n          children: \"PAF\"\n        }), \" for example, it is a modified\\n\", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \"-like string)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you have any ideas I should include here, let me know!\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Appendix A: Parsing \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" strings\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is code that can help determine the pair orientation from a single BAM\\nrecord. Might be too much detail but follow along\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"// @param flags - flags from a single read\\n// @param ref - the string of the reference sequence, just used to determine if it matches rnext\\n// @param rnext - the string of the RNEXT, just used to determine if it matches ref\\n// @param tlen - the TLEN field from SAM\\n// @return e.g. F1R2 normal paired end orientation\\nfunction getPairOrientation(\\n  flags: number,\\n  ref: string,\\n  rnext: string,\\n  tlen: number,\\n) {\\n  // this read is not unmapped \u0026\u0026\\n  // this read's mate is also not unmapped \u0026\u0026\\n  // this read's mate is on the same reference genome\\n  if (!flags \u0026 4 \u0026\u0026 !flags \u0026 8 \u0026\u0026 ref === rnext) {\\n    const s1 = flags \u0026 16 ? 'R' : 'F'\\n    const s2 = flags \u0026 32 ? 'R' : 'F'\\n    let o1 = ' '\\n    let o2 = ' '\\n\\n    // if first in pair\\n    if (flags \u0026 64) {\\n      o1 = '1'\\n      o2 = '2'\\n    }\\n\\n    // else if second in pair\\n    else if (flags \u0026 128) {\\n      o1 = '2'\\n      o2 = '1'\\n    }\\n\\n    const tmp = []\\n    if (tlen \u003e 0) {\\n      tmp[0] = s1\\n      tmp[1] = o1\\n      tmp[2] = s2\\n      tmp[3] = o2\\n    } else {\\n      tmp[2] = s1\\n      tmp[3] = o1\\n      tmp[0] = s2\\n      tmp[1] = o2\\n    }\\n    return tmp.join('')\\n  }\\n  return null\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then this can be broken down further by orientation type\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Paired end reads are \\\"fr\\\"\\nMate pair reads are \\\"rf\\\"\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So you can interpret e.g. F1R2 in relation to being a paired end read (fr) or mate pair (rf) below and with this link \", _jsx(_components.a, {\n        href: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\",\n        children: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"fr\\\": {\\n    \\\"F1R2\\\": \\\"LR\\\",\\n    \\\"F2R1\\\": \\\"LR\\\",\\n\\n    \\\"F1F2\\\": \\\"LL\\\",\\n    \\\"F2F1\\\": \\\"LL\\\",\\n\\n    \\\"R1R2\\\": \\\"RR\\\",\\n    \\\"R2R1\\\": \\\"RR\\\",\\n\\n    \\\"R1F2\\\": \\\"RL\\\",\\n    \\\"R2F1\\\": \\\"RL\\\"\\n  },\\n\\n  \\\"rf\\\": {\\n    \\\"R1F2\\\": \\\"LR\\\",\\n    \\\"R2F1\\\": \\\"LR\\\",\\n\\n    \\\"R1R2\\\": \\\"LL\\\",\\n    \\\"R2R1\\\": \\\"LL\\\",\\n\\n    \\\"F1F2\\\": \\\"RR\\\",\\n    \\\"F2F1\\\": \\\"RR\\\",\\n\\n    \\\"F1R2\\\": \\\"RL\\\",\\n    \\\"F2R1\\\": \\\"RL\\\"\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Appendix B - \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" parsing\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"// @param cigar: CIGAR string in text form\\nfunction parseCigar(cigar: string) {\\n  return cigar.split(/([MIDNSHPX=])/)\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then parse the returned array two at a time\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-typescript\",\n        children: \"// this function does nothing, but is informative for how to parse interpret a\\n// CIGAR string\\n// @param cigar:CIGAR string from record\\n// @param readSeq: the SEQ from record\\n// @param refSeq: the reference sequence underlying the read\\nfunction interpretCigar(cigar: string, readSeq: string, refSeq: string) {\\n  const opts = parseCigar(cigar)\\n  let qpos = 0 // query position, position on the read\\n  let tpos = 0 // target position, position on the reference sequence\\n  for (let i = 0; i \u003c ops.length; i += 2) {\\n    const length = +opts[i]\\n    const operator = opts[i + 1]\\n    // do things. refer to the CIGAR chart in SAMv1.pdf for which operators\\n    // \\\"consume reference\\\" to see whether to increment\\n    if (op === 'M' || op === '=') {\\n      // matches consume query and reference\\n      qpos += len\\n      tpos += len\\n    }\\n    if (op === 'I') {\\n      // insertions only consume query\\n      // sequence of the insertion from the read is\\n      const insSeq = readSeq.slice(qpos, qpos + len)\\n      qpos += len\\n    }\\n    if (op === 'D') {\\n      // deletions only consume reference\\n      // sequence of the deletion from the reference is\\n      const delSeq = refSeq.slice(tpos, tpos + len)\\n      tpad += len\\n    }\\n    if (op === 'N') {\\n      // skips only consume reference\\n      // skips are similar to deletions but are related to spliced alignments\\n      tpad += len\\n    }\\n    if (op === 'X') {\\n      // mismatch using the extended CIGAR format\\n      // could lookup the mismatch letter in a string containing the reference\\n      const mismatch = refSeq.slice(tpos, tpos + len)\\n      qpos += len\\n      tpos += len\\n    }\\n    if (op === 'H') {\\n      // does not consume query or reference\\n      // hardclip is just an indicator\\n    }\\n    if (op === 'S') {\\n      // softclip consumes query\\n      // below gets the entire soft clipped portion\\n      const softClipStr = readSeq.slice(qpos, qpos + len)\\n      qpos += len\\n    }\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note for example, that to determine how long a record is on the reference\\nsequence, you have to combine the records start position with the CIGAR string,\\nbasically parsing the CIGAR string to add up tpos and return tpos\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Appendix C - align \", _jsx(_components.code, {\n        children: \"FASTQ\"\n      }), \" directly to \", _jsx(_components.code, {\n        children: \"CRAM\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This example from the htslib documentation\\n(\", _jsx(_components.a, {\n        href: \"http://www.htslib.org/workflow/fastq.html\",\n        children: \"http://www.htslib.org/workflow/fastq.html\"\n      }), \")\\nshows how you can stream directly from \", _jsx(_components.code, {\n        children: \"FASTQ\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" (and generate the\\nindex file .crai too)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you want, you can make this a little shell script, easy_align_shortreads.sh\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"easy_align_shortreads.sh\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"#!/bin/bash\\nminimap2 -t 8 -a -x sr \\\"$1\\\" \\\"$2\\\" \\\"$3\\\"  | \\\\\\nsamtools fixmate -u -m - - | \\\\\\nsamtools sort -u -@2 - | \\\\\\nsamtools markdup -@8 --reference \\\"$1\\\" - --write-index \\\"$4\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Similar idea for longreads, except just a single fastq file is generally used for longreads\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"easy_align_longreads.sh\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"#!/bin/bash\\nminimap2 -t 8 -a \\\"$1\\\" \\\"$2\\\"  | \\\\\\nsamtools fixmate -u -m - - | \\\\\\nsamtools sort -u -@2 - | \\\\\\nsamtools markdup -@8 --reference \\\"$1\\\" - --write-index \\\"$3\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then call\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"bash easy_align_shortreads.sh ref.fa reads1.fq reads2.fq out.cram\\nbash easy_align_longreads.sh ref.fa reads.fq out.cram\\n\\n## output BAM instead\\nbash easy_align_shortreads.sh ref.fa reads1.fq reads2.fq out.bam\\nbash easy_align_longreads.sh ref.fa reads.fq out.bam\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This same concept works with other common aligners as well like bwa\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bonus: CRAM to bigwig, for looking at CNV/coverage\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"#!/bin/bash\\n# quickalign.sh ref.fa 1.fq 2.fq out.cram\\n# produces out.cram and out.bw\\nsamtools faidx $1\\nminimap2 -t 8 -a -x sr \\\"$1\\\" \\\"$2\\\" \\\"$3\\\"  | \\\\\\nsamtools fixmate -u -m - - | \\\\\\nsamtools sort -u -@2 - | \\\\\\nsamtools markdup -@8 --reference \\\"$1\\\" - --write-index \\\"$4\\\"\\n\\n\\nmosdepth $4 -f $1 $4\\ngunzip $4.per-base.bed.gz\\nbedGraphToBigWig $4.per-base.bed $1.fa.fai $4.bw\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Call as \\\"quickalign.sh ref.fa 1.fq 2.fq out.cram\\\" gives you out.cram, out.cram.crai, and out.cram.bw (coverage)\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Appendix D - the \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tag and finding SNPs in reads\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tag helps tell you where the mismatches are without looking at the\\nreference genome. This is useful because as I mentioned, \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" can say \", _jsx(_components.code, {\n        children: \"50M\"\n      }), \"\\n(50 matches) but some letters inside those 50 matches can be mismatches, it\\nonly says there are no insertions/deletions in those 50 bases, but you have to\\ndetermine where in those 50 bases where the mismatches are. The \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tag can\\nhelp tell you where those are, but it is somewhat complicated to decode\\n(\", _jsx(_components.a, {\n        href: \"https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html\",\n        children: \"https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html\"\n      }), \").\\nYou have to combine it with the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" to get the position of the mismatches\\non the reference genome. If you have a reference genome to look at, you might\\njust compare all the bases within the 50M to the reference genome and look for\\nmismatches yourself and forget about the \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tag\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tag is also not required to exist, but the command \", _jsx(_components.code, {\n        children: \"samtools calmd yourfile.bam --reference reference.fa\"\n      }), \" can add \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tags to your \", _jsx(_components.code, {\n        children: \"BAM\"\n      }), \" file. It\\nis generally not useful for \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" because \", _jsx(_components.code, {\n        children: \"CRAM\"\n      }), \" actually does store\\nmismatches with the reference genome in it's compression format. Note that\\nthere are also some oddities about \", _jsx(_components.code, {\n        children: \"MD\"\n      }), \" tag representation leading to\\ncomplaints (e.g.\\n\", _jsx(_components.a, {\n        href: \"https://github.com/samtools/hts-specs/issues/505\",\n        children: \"https://github.com/samtools/hts-specs/issues/505\"\n      }), \")\\nleading more credence to \\\"doing it yourself\\\" e.g. finding your own mismatches\\nby comparing the read sequence with the reference, keeping track of where you\\nare on the read and ref position with the \", _jsx(_components.code, {\n        children: \"CIGAR\"\n      }), \" string (a la Appendix B)\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2022-02-06-sv-sam"},"buildId":"gSZKpEwUHnQkfXhED-jJR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>