(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4210],{3905:function(e,t,n){"use strict";n.d(t,{kt:function(){return c}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),h=function(e){var t=a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):s(s({},t),e)),n},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=h(n),f=o,p=c["".concat(l,".").concat(f)]||c[f]||u[f]||r;return n?a.createElement(p,s(s({ref:t},d),{},{components:n})):a.createElement(p,s({ref:t},d))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"===typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"===typeof e?e:o,s[1]=i;for(var h=2;h<r;h++)s[h]=n[h];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4995:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return o}});var a=n(5893);function o(e){var t=e.children;return(0,a.jsxs)("div",{children:[(0,a.jsx)("a",{href:"/",children:"Return home"}),(0,a.jsx)("div",{style:{margin:"0 auto",width:"75%"},children:t})]})}},4870:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return u}});var a=n(159),o=n(219),r=(n(7294),n(3905)),s=n(4995),i=["components"],l={},h=function(e){var t=e.children;return(0,r.kt)(s.default,null,t)};function u(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)(h,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",null,"Behind the release: the story of the bugs and features in a standard maintenance release of jbrowse"),(0,r.kt)("p",null,"Every once in awhile, you might see that your favorite program,\nJBrowse,\xa0 has a new release. There are a ton of little snippets in the\nrelease notes, you might as well just go ahead and upgrade, but what\nwent into all those little fixes? Going to the blog post has links to\nthe github\nissues,\xa0",(0,r.kt)("a",{parentName:"p",href:"http://jbrowse.org/blog/2018/12/13/jbrowse-1-16-0.html"},"http://jbrowse.org/blog/2018/12/13/jbrowse-1-16-0.html"),"\xa0but I\nfelt like maybe I'd add a little more context for some of them:"),(0,r.kt)("p",null,"PS This is sort of motivated by @zcbenz blog on Electron\n(",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/zcbenz"},"https://twitter.com/zcbenz"),"\xa0",(0,r.kt)("a",{parentName:"p",href:"http://cheng.guru/"},"http://cheng.guru/"),") which tells the\nsoftware in terms of actual commit messages and such."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The webpack build doing a production build by default. This seems\npretty straightforward, but was also difficult because I use WSL and the\nUglifyJs plugin had trouble on WSL using the parallel: 4 option to use\nmultiple processors. This was really annoying and resulted in the\nwebpack build just hanging for no reason and only careful google-fu\nreally uncovered other people having this issue. I removed the\nparallelism as the speed gain wasn't even really\njustifiable\xa0",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gmod/jbrowse/pull/1223"},"https://github.com/gmod/jbrowse/pull/1223"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The incorporation of the \\@gmod/bam module. This was an almost 2\nmonths process after my first module, @gmod/indexedfasta. It required\nreally getting down to the binary level for BAM and was pretty tough.\nThe module has already itself had 12 releases\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GMOD/bam-js/blob/master/CHANGELOG.md"},"https://github.com/GMOD/bam-js/blob/master/CHANGELOG.md")))),(0,r.kt)("p",null,"-\xa0Added support for indexing arbitrary fields from GFF3Tabix files. This\nwas fairly straightforward but required making design decisions about\nthis. Previously flatfile-to-json.pl files would have a command line\nflag to index arbitrary fields. Since gff3tabix files are specified via\nconfig, I allowed specifying arbitrary fields via config."),(0,r.kt)("p",null,'-\xa0Added ability to render non-coding transcript types to the default\nGene glyph. This one was a nice feature and enables you to see\nnon-coding types, but required some weird design decisions because I\ncould not override the\xa0"box->style-',">",'color" from a higher level type\nsimply using the _defaultConfig function, so I needed to override the\ngetStyle callback that was passed down to the lower levels, so that it\nwas able to use the default lower level style and also our non-coding\ntranscript style. See this part of the code for\ndetails\xa0',(0,r.kt)("a",{parentName:"p",href:"https://github.com/GMOD/jbrowse/commit/ec638ea1cc62c8727#diff-a14e88322d8f4e8e940f995417277878R22"},"https://github.com/GMOD/jbrowse/commit/ec638ea1cc62c8727#diff-a14e88322d8f4e8e940f995417277878R22")),(0,r.kt)("p",null,'-\xa0Added hideImproperPairs filter. This was fairly straightforward but it\nis one of these bugs that went unnoticed for years...the\nhideMissingMatepairs flag would hide things didn\'t have the sam 0x02\nflag for "read mapped in proper pair", but reads with this flag could\nstill be paired. Doing the 1.16 release that focused on paired reads\nhelped focus on this issue and now hideMissingMatepairs filters on "mate\nunmapped" and hideImproperPairs is the\xa0"read mapped in proper pair"'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Added useTS flag. This one is fairly straightforward, it is similar\nto useXS which colors reads based on their alignment in canonical splice\nsite orientations. I figured I could just copy the useXS to the useTS\nsince I figured they are the same, but I went ahead and manually\ngenerated RNA-seq alignments with minimap2 and found that the useTS is\nactually flipped the opposite of useXS, so it was valuable to get actual\ntest data here.")),(0,r.kt)("p",null,"-\xa0Fixed issue where some generate-names setups would fail to index\nfeatures. This was a bad bug that was brought to light by a user. I was\nkind of mind boggled when I saw it. In JBrowse 1.13-JBrowse 1.15 a\nchange was introduced to name indexing with a memory leak. In JBrowse\n1.15 that was removed. But, there was another change where refseqs could\nreturn empty name records, because they were handled separately. But if\nthe initial fill up of the name buffer of 50000 was exceeded by the\nreference sequence, then there would be empty name records after this\npoint and cause the name indexing to stop. Therefore this bug would only\nhappen when the reference sequence indexing buffer exceeded 50000 items\nwhich could happen even when there are less than 50000 refseqs due to\nautocompletions"),(0,r.kt)("p",null,'-\xa0 Fixed issue with getting feature density from BAM files via the index\nstats estimation. This involved parsing the\xa0"dummy bin" from index\nfiles, and I found it was failing on certain 1000 genomes files. I\nactually don\'t really know what the story behind this was, but our tabix\ncode was better at parsing the dummy bins than my bam code, and it was\nthe same concept, so I took a note from their codebase to use it in\nbam-js code. Commit\nhere\xa0',(0,r.kt)("a",{parentName:"p",href:"https://github.com/GMOD/bam-js/commit/d5796dfc8750378ac8b875615ae0a7e81371af76"},"https://github.com/GMOD/bam-js/commit/d5796dfc8750378ac8b875615ae0a7e81371af76")),(0,r.kt)("p",null,"-\xa0 Fixed issue with some GFF3Tabix tracks having some inconsistent\nlayout of features. This is a persistently annoying fact in tabix files\nwhere we cannot really get a unique ID of a feature based on it's file\noffset. Therefore this takes the full crc32 of a line as it's unique ID."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Fixed CRAM store not renaming reference sequences in the same way as\nother stores. This one was interesting because rbuels made a fix but it\ncaused features from one chromosome to show up on the wrong ones, so\nchr1 reads where showing up on chrMT. This happened because it was\nfalling back to the refseq index if it chrMT wasn\'t in the embedded "sam\nheader" in the CRAM file, but it should only fallback to refseq index if\nthere is not any embedded\xa0"sam header" in the CRAM file.')),(0,r.kt)("p",null,"-\xa0 Fixed bug where older browsers e.g. IE11 were not being properly\nsupported via babel. This was a absolutely terrible bug that I found\nover thanksgiving break. It was a regression from 1.15 branch of\nJBrowse. Previous versions from 1.13 when webpack was up until 1.15 used\n@babel/env. It was changed to babel-preset-2015 but it was not being\nrun correctly. Then I found that even if I did get it running correctly,\nit was unable to properly babel-ify the lru-cache module because it used\nsomething called Object.defineProperty('length', ...) to change how the\nlength property was intepreted which was illegal in IE11. The\n'util.promisify' NPM module also did this in some contexts. I found that\nI could use the quick-lru module and the es6-promisify module instead of\nlru-cache and util.promisify as a workaround. Then I had to update all\n@gmod/tabix, \\@gmod/vcf, \\@gmod/bgzf-filehandle, \\@gmod/indexedfasta,\n@gmod/tribble-index, \\@gmod/bam, and JBrowse proper to use these\nmodules instead, and make the bable chain, which typically does not\nparse node_modules, to build these modules specifically (I didn't want\nto setup babel toolchains for every single one of these modules, just\none in the jbrowse main codebase...). This was really a lot of work to\nsupport IE11 but now that works so *shrug","*"),(0,r.kt)("p",null,'-\xa0 Fixed bug where some files were not being fetched properly when\nchanging refseqs. This was actually fixed when I changed out lru-cache\nfor quick-lru and fixed a bug where the cache size was set to 0 due to a\nerroneous comment that said\xa0"50',(0,r.kt)("em",{parentName:"p"},'1024 // 50MB"...of course it should\nhave said\xa0"50'),"1024","*",'1024 //\n50MB"\xa0',(0,r.kt)("a",{parentName:"p",href:"https://github.com/GMOD/jbrowse/commit/2025dc0aa0091b70"},"https://github.com/GMOD/jbrowse/commit/2025dc0aa0091b70")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Fixed issue where JBrowse would load the wrong area of the refseq on\nstartup resulting in bad layouts and excessive data fetches. This was\nactually a heinous bug where jbrowse upon loading would just navigateTo\nthe start of the reference sequence automatically and then to wherever\nwas specified by the user. This resulted in track data to start\ndownloading immediately from the start of the chromosome and resulted in\nfor example 350 kilobases of reference sequence from all tracks to start\ndownloading, which when I was implementing view as pairs, was causing me\nto download over 100MB routinely. This was terrible, and after fixing I\nonly download about 10MB over even large regions for most BAM files.\nAdditionally, this bug was causing the track heights to be calculated\nincorrectly because the track heights would actually be calculated based\non distorted canvas\nbitmaps.\xa0",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gmod/jbrowse/issues/1187"},"https://github.com/gmod/jbrowse/issues/1187"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"JBrowse Desktop was not fetching remote files. This was a weird issue\nwhere remote file requests were considered a CORS requests to any\nexternal remote. This was solved by changing the usage of the fetch API\nin JBrowse for node-fetch which does not obey CORS. Note that\nelectron-fetch was also considered, which uses Chromiums network stack\ninstead of node's, but that had specific assumptions about the context\nin which it was called.\xa0"))),(0,r.kt)("p",null,"-\xa0 Fixed issue where some parts of a CRAM file would not be displayed in\nJBrowse due to a CRAM index parsing issue. This was based on a sort of\nbinary search that was implemented in JBrowse where the elements of the\nlists were non-overlapping regions, and the query was a region, and the\noutput should be a list of the non-overlapping regions that overlap the\nquery. Most algorithms for binary search don't really tell you how to do\nsearches on ranges so needed to roll up my sleeves and write a little\ncustom code. An interval tree could have been used but this is too\nheavy-weight for non-overlapping regions from the\nindex\xa0",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GMOD/cram-js/pull/10"},"https://github.com/GMOD/cram-js/pull/10")),(0,r.kt)("p",null,"-\xa0 Fixed an issue where BAM features were not lazily evaluating their\ntags. When a function feature.get('blahblahblah') is called on a BAM\nfeature, it checks to see if it's part of a default list of things that\nare parsed like feature start, end, id, but if not, it has to parse all\nthe BAM tags to see if it is a tag. Since they are called\xa0\"lazy\nfeatures\" the tag processing is deferred until it is absolutely needed.\nAs it turned out, the incorporation of CRAM in 1.15 was calling a\nfunction to try to get the CRAM's version of CIGAR/MD on the BAM\nfeatures unnecessarily invoking the tag parsing on every feature up\nfront and therefore making the feature not really lazy anymore. This\nrestored the\xa0\"lazyness\" aspect of BAM."),(0,r.kt)("p",null,'-\xa0 Fixed issue where CRAM layout and mouseover would be glitchy due to\nID collisions on features. In the 1.15 releases, CRAM was introduced,\nand we thought that the concept of taking CRC32 of the entire feature\ndata days were over because there is the concept of a\xa0"unique ID" on the\nfeatures. However, this ID was only unique within the slices, so around\nthe slice boundaries there were a lot of bad feature layouts and\nmouseovers would fail because they would map to multiple features, etc.\nI found a way to unique-ify this by giving it the sliceHeader file\noffset.\xa0',(0,r.kt)("a",{parentName:"p",href:"https://github.com/GMOD/cram-js/pull/10"},"https://github.com/GMOD/cram-js/pull/10")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We also had behind the scenes work by igv.js team member jrobinso who\nhelped on the CRAM codebase to incorporate a feature where for lossy\nread names, so that a read and it's mate pair would consistently be\nassigned the same read name based on the unique ID mentioned above.\nThere was also a rare issue where sometimes the mate pair's orientation\nwas incorrectly reported based on the CRAM flags, but the embedded BAM\nflags correctly reported it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'Finally the paired reads feature. This was a feature that I really\nwanted to get right. It started when garrett and rbuels were going to\nsan diego for the CIVIC hackathon, and we talked about doing something\nthat matched a\xa0"variant review system" that they had done for the IGV\ncodebase, which involved detailed inspection of reads. I thought it\nwould probably be feasible for jbrowse to do this, but I thought\nessentially at some point that enhancing jbrowse\'s read visualizations\nwith paired reads would be a big win. I had thought about this at the\nJBrowse hackathon also and my discussions then were that this was very\nhard. Overall, I invented a compromise that I thought was reasonable\nwhich was that there can be a\xa0"maxInsertSize" for the pileup view beyond\nwhich the pairing wouldn\'t be resolved. This allowed (a) a significant\nreduction in data fetches because I implemented a\xa0"read redispatcher"\nthat would actually literally resolve the read pairs in the separate\nchunks and (b) a cleaner view because the layout wouldn\'t be polluted by\nvery long read inserts all the time and also, for example, if you\nscrolled to the right, and suddenly a read was paired to the left side\nof your view, it would result in a bad layout (but with max insert size,\nthe window of all reads within maxinsertsize are always resolved so this\ndoes not happen) and finally ( c) the paired arc view was incorporated\nwhich does not use read redispatching and which can do very long reads.\nAll of these things took time to think through and resolve, but it is\nnow I think a pretty solid system and I look forward to user feedback!'))),(0,r.kt)("p",null,"::: {#footer}\n","[ December 17th, 2018 4:16pm ]","{#timestamp} ","[code]","{.tag}\n","[javascript]","{.tag}\n:::"))}u.isMDXComponent=!0},8398:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/2018-12-17",function(){return n(4870)}])},159:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,{Z:function(){return a}})},219:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}n.d(t,{Z:function(){return a}})}},function(e){e.O(0,[9774,2888,179],(function(){return t=8398,e(e.s=t);var t}));var t=e.O();_N_E=t}]);