(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4103],{3905:function(e,t,n){"use strict";n.d(t,{kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):i(i({},t),e)),n},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,m=u["".concat(l,".").concat(d)]||u[d]||c[d]||o;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"===typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4995:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return r}});var a=n(5893);function r(e){var t=e.children;return(0,a.jsxs)("div",{children:[(0,a.jsx)("a",{href:"/",children:"Return home"}),(0,a.jsx)("div",{className:"blog",children:t})]})}},7554:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var a=n(159),r=n(219),o=(n(7294),n(3905)),i=n(4995),s=["components"],l={},p=function(e){var t=e.children;return(0,o.kt)(i.default,null,t)};function c(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)(p,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",null,"Adding a custom normalization to MACS"),(0,o.kt)("p",null,"One of the issues with ChIP-seq is that each dataset has it's own\nspecial characteristics. What works well on one might perform poorly on\nanother! There are variations in the sequencing depth as well as in the\nenrichment of the protocol, and the protocols for ChIP can vary widely\nthemselves specialized for using small numbers of cells or other\nscenarios."),(0,o.kt)("p",null,'In the paper "Normalization of ChIP-seq with control" (Liang and Keles,\n2012), they make a convincing case for how to estimate the normalization\nfactor to scale the background distribution of reads. They analyzed a\ncouple different openly available ChIP-seq datasets, and I found these\nfigures to be very illustrative for the unique shapes that each dataset\nhas.'),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://64.media.tumblr.com/0320609f2578b7b1c1e1fbf374aeaf52/f0d5ac36bf6ed6c6-a2/s540x810/ba8bfea74ab5a40d516d766ddfe6f52bfcaa3458.png",alt:null})),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://64.media.tumblr.com/f5715129b10d81cbc17508c3963028b7/f0d5ac36bf6ed6c6-a8/s540x810/cd53cfd832cdc808dfc076e9c9a4bc0dbeaa2ed4.png",alt:null})),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://64.media.tumblr.com/5dc3ded50aaf36b426afd573f7908ae0/f0d5ac36bf6ed6c6-6e/s540x810/bdc88947dedfbc82eb9ff24f699aaa25e154776f.png",alt:null})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Supp Figures 1-3, from Liang et al. (2012) -")," These figures show the\nbinned read counts of various ChIP-seq experiments versus their\ncontrols. Each experiment has a unique shape that depends on the\nsequencing depth and the enrichment of the protocols."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"How to estimate the normalization the NCIS way?")),(0,o.kt)("p",null,'In applications like MACS, the ChIP-seq and control is normalized by the\nsequencing depth. However, we might not want to scale down the peaks\nfrom the ChIP-seq data: we might only want to normalize the\n"background", the non-specific and noisey DNA-protein interactions.'),(0,o.kt)("p",null,'We know that the binding sites are basically peaks in the data, so a\n"reasonable" way to estimate the background is to use all binned read\ncounts that have less than "',(0,o.kt)("em",{parentName:"p"},'t" reads'),". This corresponds to the set\n",(0,o.kt)("em",{parentName:"p"},"Bw(t)")," ofall bins ",(0,o.kt)("em",{parentName:"p"},"B")," of width\xa0",(0,o.kt)("em",{parentName:"p"},"w")," that have less than\xa0",(0,o.kt)("em",{parentName:"p"},"t")," reads. With\nthat in mind, we can see the first figure of the NCIS paper and actually\nmake sense of it."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://64.media.tumblr.com/430f7e98dde0a2e97d47a23035f0260d/f0d5ac36bf6ed6c6-9f/s540x810/9125d7fa9a91fc74c010c430ca58ee0f1698c048.png",alt:null})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Figure 1. from Liang et al (2012)")," - Shows the estimated ratio of the\nbackground reads in the ChIP-seq/control for a given threshold ",(0,o.kt)("em",{parentName:"p"},"t"),". The\noptimal ",(0,o.kt)("em",{parentName:"p"},"t"),' is called when at least \xbe of the genome are included in the\nbackground distribution and thereafter when the estimated ratio starts\n"going up" (r(t)',">","r(t-1)), indicating that we 'grabbing' the chip-seq\nsignal and stopping there."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"How can we apply this technique to MACS?")),(0,o.kt)("p",null,"Originally, I found NCIS on the MACS mailing list and I wanted to figure\nout how I can answer this question for myself. As it turns out, MACS can\nperform pitifully on some datasets. This includes datasets like Zheng et\nal which I have looked at in my previous posts. One particular\nexperiment with SEG1 produces some very troublesome results when MACS is\nused to find peaks. Therefore, I wanted to see if we can use the NCIS\nratio estimates for MACS. Unfortunately, for MACS 1.4.2, there no way to\nspecify a custom normalization factor, so I made a quick hack that\nignores the affect of the default --to-small=BOOL flag if a new flag\nthat I specified, called --ratio=FLOAT, is set. The --ratio is a scaling\nfactor affects the control dataset, but i could have designed it to\naffect the chip-seq dataset as well."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Calculation of the of NCIS ratio for the SEG1 dataset")),(0,o.kt)("p",null,"As in the NCIS paper, I also tried to analyze the SEG1 dataset using\nMACS. So first I tried to reproduce some of the results of NCIS in their\nSEG1 application, but to do this, i had to do some guesswork about NCIS\nmethods. First, i deduced that they had pooled all the SEG1 replicates\ntogether, which gives me a very close ratio estimate to their published\nresults.\\\n\\\n",(0,o.kt)("em",{parentName:"p"},"SEG1 ratio given in NCIS paper\\\n"),"NCIS estimated ratio:",(0,o.kt)("em",{parentName:"p"},"1.265\\\n"),"estimated background proportion:",(0,o.kt)("em",{parentName:"p"},"0.763"),"\\\n\\\n",(0,o.kt)("em",{parentName:"p"},"SEG1rep1,2,3 pooled ratio based on my calculation using NCIS"),"\\\nNCIS estimated ratio: ",(0,o.kt)("em",{parentName:"p"},"1.2627640"),"\\\nestimated background proportion: ",(0,o.kt)("em",{parentName:"p"},"0.7672308")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Sidenote:")," The NCIS package is very easy to use in R, which is great,\nbut i also ran into some memory problems. I would try using the MCS or\nBED format instead of AlignedRead format. Personally, I used MACS script\nelandresult2bed to convert the the eland","_","result files to BED instead of\nusing readAligned to get the eland","_","result files into memory directly\\\n\\\n",(0,o.kt)("strong",{parentName:"p"},"Peak calling using the modified MACS")),(0,o.kt)("p",null,"After calculating the normalization, i did the peak calling with and\nwithout the ratio parameters to see how this performed.\xa0 Again, I had to\nguess the peak calling parameters because they aren't given in NCIS, so\nI kind of guessed. Unfortuantely, my numbers didn't match their numbers,\nbut the effects of using the --ratio flag are clear. First, I called\npeaks without the --ratio flag"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"macs14 -g 1.2e7 -m 4,30 -t SEGChIP","_","rep123u","_","eland","_","result.txt -c\nSEG1inputu","_","eland","_","result.txt -n SEG1rep123")),(0,o.kt)("p",null,"This command resulted in only ",(0,o.kt)("em",{parentName:"p"},"703 called peaks")," and ",(0,o.kt)("em",{parentName:"p"},"971 negative\npeaks")," (yikes! bad fdr). I also tried adding the parameter --to-small,\nwhich downscales the ChIP-seq data (6M reads) instead of upscaling the\ncontrol data (4M reads), but it didn't improve much: ",(0,o.kt)("em",{parentName:"p"},"366 peaks")," called\nand ",(0,o.kt)("em",{parentName:"p"},"713 negative peaks")," (yikes again!)"),(0,o.kt)("p",null,"So, then using the --ratio flag that i added to MACS, I ran MACS using\nthe NCIS ratio estimate which is ",(0,o.kt)("em",{parentName:"p"},"r=1.2627640"),". This is in comparison\nwith the raw sequencing depth ratio that MACS applies which is ",(0,o.kt)("em",{parentName:"p"},"r=1.64"),"."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"macs14 -t SEG1ChIP","_","rep123u","_","eland","_","result.txt -c\nSEG1inputu","_","eland","_","result.txt -m 4,30 -g 1.2e7 --ratio 1.26 -n\nSEG1rep123-ncismod")),(0,o.kt)("p",null,"This resulted in ",(0,o.kt)("em",{parentName:"p"},"991 peaks")," and only ",(0,o.kt)("em",{parentName:"p"},"19 negative peaks"),". Arguably,\nthis result is a lot better! Changing only the --ratio from ","~","1.6 to\n","~","1.2 creates a much better control of the FDR."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Why is it so much of a better result?")),(0,o.kt)("p",null,"We can visually see how the different ratios compare based on figures\nfrom Liang et al. again, and here the sequencing depth ratio (black)\ngreatly exceeds the the NCIS ratio (blue) which follows the background\ndistribution. If the sequencing depth ratio is used as a scaling factor,\nthen the control data will be amplified into the region where true peaks\ncan occur, so many negative peaks will be called, and many positive\npeaks will be obscured!"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://64.media.tumblr.com/40192ff1491a0b90777a0e4efb3128ca/f0d5ac36bf6ed6c6-92/s540x810/70bf1f948b3c018b5e1737345fb4df3d82169faf.png",alt:null})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Figure 4. from Liang et al (2012)")," - The black line represents the\ndifference in sequencing depth, the blue line is the NCIS estimate"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Conclusion")),(0,o.kt)("p",null,"These are positive results for using the NCIS estimator with MACS, and\nit only involved a very simple patch to the MACS source code to achieve.\nOverall, I found that the new --ratio parameter combined with the NCIS\nratio\xa0 estimate was very effective at fixing the problems with the high\nFDR and weak peak calling observed in SEG1."),(0,o.kt)("p",null,"I'm surprised I had not heard of this technique earlier, since it\nappears to also be implemented to some degree by cisgenome and others. I\nguess I like surprises though! There are additional results from the\nNCIS paper regarding the control of the FDR that I would like to figure\nout still. I also should probably try it on different datasets and see\nhow it compares."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Download")),(0,o.kt)("p",null,'If you want to try out MACS 1.4.2 using the --ratio flag, I made a\ngithub fork of the code and added a tag "add-ratio-branch" which let\'s\nyou download the package as a zip here\n',(0,o.kt)("a",{parentName:"p",href:"https://github.com/tonto/MACS/tags"},"https://github.com/tonto/MACS/tags")),(0,o.kt)("p",null,"You can also see the exact changes that I made to MACS using this commit\nlog here\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tonto/MACS/commit/d1c9f9931871ee8706e0aca1041f647857b2f8e5"},"https://github.com/tonto/MACS/commit/d1c9f9931871ee8706e0aca1041f647857b2f8e5")),(0,o.kt)("p",null,"::: {#footer}\n","[ June 9th, 2013 10:08pm ]","{#timestamp} ","[python]","{.tag} ","[chip-seq]","{.tag}\n","[bioinformatics]","{.tag} ","[genomics]","{.tag} ","[statistics]","{.tag}\n:::"))}c.isMDXComponent=!0},593:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/2013-06-09",function(){return n(7554)}])},159:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,{Z:function(){return a}})},219:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})}},function(e){e.O(0,[9774,2888,179],(function(){return t=593,e(e.s=t);var t}));var t=e.O();_N_E=t}]);