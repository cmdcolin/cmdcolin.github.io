{"pageProps":{"post":{"title":"You may not need a bundler for your NPM library","date":"2022-05-27","slug":"2022-05-27-youmaynotneedabundler","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\",\n      code: \"code\",\n      h2: \"h2\",\n      em: \"em\",\n      h3: \"h3\",\n      pre: \"pre\",\n      h4: \"h4\",\n      strong: \"strong\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"I have seen a couple threads on twitter where people complain about the\\ndifficulty with publishing NPM libraries or ask what starter kit they should\\nuse (or, people recommended starter packs anyways)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Example threads\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/cramforce/status/1513903035197526017\",\n            children: \"https://twitter.com/cramforce/status/1513903035197526017\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/oleg008/status/1510006191296061441\",\n            children: \"https://twitter.com/oleg008/status/1510006191296061441\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/iansu/status/1524860613943382017\",\n            children: \"https://twitter.com/iansu/status/1524860613943382017\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/mpocock1/status/1525075901905522691\",\n            children: \"https://twitter.com/mpocock1/status/1525075901905522691\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"One thing that is notable to me in these threads is that people often recommend\\nthat you use a bundler (a program that combines multiple src files into a\\nsingle or fewer output files) when developing a library\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Examples of starter packs suggested in these threads that use bundlers\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"microbundle\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/developit/microbundle\",\n            children: \"https://github.com/developit/microbundle\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"esno\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://www.npmjs.com/package/esno\",\n            children: \"https://www.npmjs.com/package/esno\"\n          }), \" - uses esbuild\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"unbuild\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/unjs/unbuild\",\n            children: \"https://github.com/unjs/unbuild\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"preconstruct\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/preconstruct/preconstruct\",\n            children: \"https://github.com/preconstruct/preconstruct\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"tsup\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/egoist/tsup\",\n            children: \"https://github.com/egoist/tsup\"\n          }), \" - uses esbuild\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"tsdx\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/jaredpalmer/tsdx\",\n            children: \"https://github.com/jaredpalmer/tsdx\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"vite library mode\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://vitejs.dev/guide/build.html#library-mode\",\n            children: \"https://vitejs.dev/guide/build.html#library-mode\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"packemon\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/milesj/packemon\",\n            children: \"https://github.com/milesj/packemon\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"ts-library-template\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/shortercode/ts-library-template\",\n            children: \"https://github.com/shortercode/ts-library-template\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"parcel\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://twitter.com/devongovett/status/1524944991402999810\",\n            children: \"https://twitter.com/devongovett/status/1524944991402999810\"\n          }), \" - uses parcel\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"dts\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://weiran-zsd.github.io/dts-cli/\",\n            children: \"https://weiran-zsd.github.io/dts-cli/\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"pkgroll\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/privatenumber/pkgroll\",\n            children: \"https://github.com/privatenumber/pkgroll\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"mkdist\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/unjs/mkdist\",\n            children: \"https://github.com/unjs/mkdist\"\n          }), \" - referenced by \", _jsx(_components.code, {\n            children: \"unbuild\"\n          }), \", uses esbuild\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Not using bundlers\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"gts\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/google/gts\",\n            children: \"https://github.com/google/gts\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"ts-react-toolbox\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/zzarcon/ts-react-toolbox/\",\n            children: \"https://github.com/zzarcon/ts-react-toolbox/\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In summary 2/15 do not use a bundler, 13/15 do use a bundler. Sidenote: webpack notably absent\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"Why would you \", _jsx(_components.em, {\n          children: \"NOT\"\n        }), \" want a bundler for your library?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"My main argument is that the consumer of your library is the one that should\\nuse a bundler if it is relevant to them. If the library uses a bundler:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"in the best case, it has no impact on the consumer\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"in the worst case, it affects the complexity of your library and makes\\npossible limitations for your consumers also.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"An example where it can actually create limitations, you might consider code\\nsplitting with async \", _jsx(_components.code, {\n          children: \"import()\"\n        }), \". If you create a single file bundle, then the\\nconsumer of your library may not be able to do code splitting properly via\\nasync \", _jsx(_components.code, {\n          children: \"import()\"\n        })]\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"Why would you \", _jsx(_components.em, {\n          children: \"MAYBE\"\n        }), \" want a bundler for your library\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you really care about producing a \", _jsx(_components.code, {\n          children: \"UMD\"\n        }), \" bundle that can be used in a script\\ntag, maybe you want a bundler, but the future does not seem to be in \", _jsx(_components.code, {\n          children: \"UMD\"\n        }), \".\\nOne other possible bundle type is maybe you like the idea of a single file\\n\", _jsx(_components.code, {\n          children: \"ESM\"\n        }), \" module. It is similar where you could maybe reference this from a script\\ntag with type module, but this seems like a niche usage. For example, you\\nwould still have to consider:\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"If you are not bundling dependencies, then what is the benefit of using a\\nbundler?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"If you are bundling dependencies, you are not allowing people to get updates\\nto your sub-dependencies with semver!\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"My suggestion: no bundler, no starter pack, just \", _jsx(_components.code, {\n          children: \"tsc\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I'd recommend just compiling your code with \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \", no bundler involved. This\\nway, you can develop with typescript, it will output \", _jsx(_components.code, {\n          children: \"js\"\n        }), \" files, and you can\\ndirectly deploy a \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" folder of \", _jsx(_components.code, {\n          children: \"js\"\n        }), \" files to NPM.\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"Example \", _jsx(_components.code, {\n          children: \"package.json\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"name\\\": \\\"yourlib\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"main\\\": \\\"dist/index.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"clean\\\": \\\"rimraf dist\\\",\\n    \\\"prebuild\\\": \\\"npm run clean\\\",\\n    \\\"build\\\": \\\"tsc\\\",\\n    \\\"preversion\\\": \\\"npm run build\\\",\\n    \\\"postversion\\\": \\\"git push --follow-tags\\\"\\n  },\\n  \\\"files\\\": [\\\"dist\\\", \\\"src\\\"],\\n  \\\"devDependencies\\\": {\\n    \\\"rimraf\\\": \\\"^3.0.2\\\",\\n    \\\"typescript\\\": \\\"^4.6.2\\\"\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h4, {\n        children: [\"Features of the above \", _jsx(_components.code, {\n          children: \"package.json\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"We can use a single command, \", _jsx(_components.code, {\n            children: \"yarn publish\"\n          }), \" to publish to npm\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The single \", _jsx(_components.code, {\n            children: \"yarn publish\"\n          }), \" automatically runs \", _jsx(_components.code, {\n            children: \"clean\"\n          }), \" and \", _jsx(_components.code, {\n            children: \"build\"\n          }), \" via\\n\", _jsx(_components.code, {\n            children: \"preversion\"\n          }), \", then \", _jsx(_components.code, {\n            children: \"postversion\"\n          }), \", which pushes the tag to the remote repo\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.code, {\n            children: \"\\\"files\\\": [\\\"dist\\\", \\\"src\\\"]\"\n          }), \" refers to published the \", _jsx(_components.code, {\n            children: \"dist\"\n          }), \" and \", _jsx(_components.code, {\n            children: \"src\"\n          }), \" directories,\\nand src is used for the \", _jsx(_components.code, {\n            children: \"sourceMap\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"Example\", _jsx(_components.code, {\n          children: \" tsconfig.json\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"include\\\": [\\\"src\\\"],\\n  \\\"compilerOptions\\\": {\\n    \\\"target\\\": \\\"es2018\\\",\\n    \\\"outDir\\\": \\\"dist\\\",\\n    \\\"lib\\\": [\\\"dom\\\", \\\"esnext\\\"],\\n    \\\"declaration\\\": true,\\n    \\\"moduleResolution\\\": \\\"node\\\",\\n    \\\"strict\\\": true,\\n    \\\"esModuleInterop\\\": true\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h4, {\n        children: [\"Features of the above \", _jsx(_components.code, {\n          children: \"tsconfig.json\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Uses \", _jsx(_components.code, {\n            children: \"\\\"moduleResoltuon\\\": \\\"node\\\"\"\n          }), \" - this is not pure-ESM because pure-ESM\\nexpects you to import with the filenames, while node module resolution can\\nimport extensionless paths, but it works well with consumers that use\\nbundlers themselves\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Uses \", _jsx(_components.code, {\n            children: \"\\\"target\\\": \\\"es2018\\\"\"\n          }), \" - This is does a small amount of transpilation of\\nsuper modern features, but would generally not require your users to\\nbabel-ify their \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" if they consume your library\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"What about testing?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Adding testing is not immediately solved by the above, but bundling doesn't\\nreally help testing anyways. It's just a starter pack feature we can add on.\\nSome options you have include\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"ts-jest\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"jest\"\n          }), \" on it's own, plus a \", _jsx(_components.code, {\n            children: \"babel\"\n          }), \" config with \", _jsx(_components.code, {\n            children: \"@babel/preset-typescript\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"jest\"\n          }), \" on it's own, run over the compiled output without a \", _jsx(_components.code, {\n            children: \"babel\"\n          }), \" config\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"vitest\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Possibly something else? Node now has a built-in test runner. It will be a\\nslow road to adoption but might become more popular over time\\n\", _jsx(_components.a, {\n            href: \"https://fusebit.io/blog/node-testing-comes-to-core/\",\n            children: \"https://fusebit.io/blog/node-testing-comes-to-core/\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Conclusion\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"It is tempting to have a nice zero-config solutions and starter kits, but to\\nme, it is not really beneficial to use the bundler aspect of many of these for\\npublishing to NPM. Am I wrong? Let me know if I am.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Also, these starter kits may not be maintained for perpetuity. Our team used\\n\", _jsx(_components.code, {\n          children: \"tsdx\"\n        }), \" for some time, but it was not maintained well, and used old typescript\\nversion 3.x, and it ended up being hard to remove from our codebase. Learning\\nthe basic tools like \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" will help\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 1: Shipping pure-ESM\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Do you want to make a pure-ESM package? Then you do not want to use\\n\", _jsx(_components.code, {\n          children: \"\\\"moduleResolution\\\": \\\"node\\\"\"\n        }), \" in \", _jsx(_components.code, {\n          children: \"tsconfig.json\"\n        }), \", and you will want to set\\n\", _jsx(_components.code, {\n          children: \"\\\"type\\\": \\\"module\\\"\"\n        }), \" in \", _jsx(_components.code, {\n          children: \"package.json\"\n        }), \". You may also need to explicitly import\\nwith \", _jsx(_components.code, {\n          children: \".js\"\n        }), \" extensions in your source code, even if you write \", _jsx(_components.code, {\n          children: \".ts\"\n        }), \". This is\\nawkward, and something the community is still grappling with.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you have ever stumbled on this topic, you will probably want to see this\\nlink\\n\", _jsx(_components.a, {\n          href: \"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\",\n          children: \"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\"\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 2: Learning your tools\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Several people on the\\n\", _jsx(_components.a, {\n          href: \"https://cmdcolin.github.io/posts/2022-05-04-findseddangerous\",\n          children: \"my recent post\"\n        }), \"\\npost suggested that I did not understand my tools, and that I should just learn\\nthe tools correctly and I wouldn't have the problem I had.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Indeed, what I am now telling people to do in this post is similar: I am saying\\n\\\"just use \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" by itself! Understand you tools! You may have to do more\\nresearch and create more boilerplate, but it's \", _jsx(_components.strong, {\n          children: \"better\"\n        }), \"\\\".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Ultimately though, it's up to you to choose your tools and starter packs and\\nwhatnot.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 3: What does it look like when you compile with tsc?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When I refer to compiling with tsc above, I compile a \", _jsx(_components.code, {\n          children: \"src\"\n        }), \" directory into a\\n\", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" directory\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So if I have:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"src/index.ts\\nsrc/util.ts\\nsrc/components/Button.ts\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Running \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" will output:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"dist/index.js\\ndist/index.d.ts\\ndist/index.js.map\\ndist/util.js\\ndist/util.d.ts\\ndist/util.js.map\\ndist/components/Button.js\\ndist/components/Button.d.ts\\ndist/components/Button.js.map\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Then, the \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"src\"\n        }), \" directories are published to npm which enables the\\n\", _jsx(_components.code, {\n          children: \"sourceMaps\"\n        }), \" to work.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: We do not need to explicitly say where the typescript types are with\\n\\\"types\\\" in \", _jsx(_components.code, {\n          children: \"package.json\"\n        }), \", many starter packs do this but it is unneeded for\\nthis package as the d.ts files are automatically found.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"See\\n\", _jsx(_components.a, {\n          href: \"https://cmdcolin.github.io/posts/2021-12-31-npm-package\",\n          children: \"https://cmdcolin.github.io/posts/2021-12-31-npm-package\"\n        }), \"\\nfor my article on creating a typescript package for npm\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 4: Other things people recommend\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Other things people recommend in the starter pack threads\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"deno\"\n          }), \" - not clear to me how this helps when deploying to npm, but I still gotta try deno\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"ts-node \"\n          }), \" - not clear to me how this helps when deploying to npm\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"nx\"\n          }), \" - heavy monorepo-based solution\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"elm\"\n          }), \" - that's just a different thing\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"Typescript-Node-Starter\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/microsoft/TypeScript-Node-Starter\",\n            children: \"https://github.com/microsoft/TypeScript-Node-Starter\"\n          }), \" - not a library, full stack framework\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"joystick\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/CheatCode/joystick\",\n            children: \"https://github.com/CheatCode/joystick\"\n          }), \" - not a library, full stack framework\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 5:\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Similar things happen if you take on dependencies of starter kits like\\n\", _jsx(_components.code, {\n          children: \"create-react-app\"\n        }), \". You become very committed to their particular way of doing\\nthings, and can only modify their config with things like \", _jsx(_components.code, {\n          children: \"rescripts\"\n        }), \", \", _jsx(_components.code, {\n          children: \"craco\"\n        }), \"\\nor \", _jsx(_components.code, {\n          children: \"rewired\"\n        }), \". If you crafted your setup with just \", _jsx(_components.code, {\n          children: \"webpack\"\n        }), \", you may not be so\\ntied down. But, I still use things like \", _jsx(_components.code, {\n          children: \"create-react-app\"\n        }), \" because they do seem\\nto help me significantly. Now though, the tide seems to be turning other\\ndirections like next.js which can do static site generation at a basic level\\nand extend to multiple pages more easily.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}