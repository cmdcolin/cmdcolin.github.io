{"pageProps":{"post":{"title":"Caching or memoizing promises","date":"2022-02-26","slug":"2022-02-26-caching-promise","mdxSource":{"compiledSource":"var l=Object.defineProperty,u=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(e,t,o)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,n=(e,t)=>{for(var o in t||(t={}))s.call(t,o)&&c(e,o,t[o]);if(r)for(var o of r(t))i.call(t,o)&&c(e,o,t[o]);return e},h=(e,t)=>u(e,m(t));var p=(e,t)=>{var o={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(o[a]=e[a]);if(e!=null&&r)for(var a of r(e))t.indexOf(a)<0&&i.call(e,a)&&(o[a]=e[a]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var a=o,{components:e}=a,t=p(a,[\"components\"]);return mdx(MDXLayout,h(n(n({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Caching promises in javascript can be somewhat confusing. I think searching for\ninfo about it online is often misguided and results are often very specific to\nsomeones application Here is a method I have used to cache promises, or to\nmemoize an async function. It may not handle all cases, but it helps with some\nscenarios I have seen`),mdx(\"p\",null,\"Example async function: fetch from the pokemon API\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getPokemon() {\n  const id = Math.floor(Math.random() * 150)\n  const url = 'https://pokeapi.co/api/v2/pokemon/' + id\n  const ret = await fetch(url)\n  if (!ret.ok) {\n    throw new Error(\n      \\`Failed to fetch \\${url} HTTP \\${ret.status} \\${ret.statusText}\\`,\n    )\n  }\n  return ret.json()\n}\n`)),mdx(\"p\",null,\"How can we cache this function so that we only get one result\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getCachedPokemon() {\n  if (!this.res) {\n    this.res = getPokemon().catch(e => {\n      this.res = undefined\n      throw e\n    })\n  }\n  return this.res\n}\n`)),mdx(\"p\",null,`The important part of this function is that when I get an error, I clear the\nresource. The caller of the function, on error, will receive the error message,\nbut caching will not take place, allowing retries to take place later on.`),mdx(\"p\",null,\"See \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cmdcolin.github.io/pokemon.html\"}),\"https://cmdcolin.github.io/pokemon.html\"),\" for demo\"),mdx(\"h2\",null,\"Footnote 1: Error handling\"),mdx(\"p\",null,`This demo also demonstrates some basic fetch error handling, and uses\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"statusText\"),\" \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText\"}),`which happens to not exist in\nHTTP/2`),`.\nIf you want a semblence of status message text in HTTP/2 you can try to use\nawait ret.json() or await ret.text() inside the catch clause, but note that it\ncould cause yet another error to be thrown`),mdx(\"h1\",null,\"Footnote 2: Cache types\"),mdx(\"p\",null,`You could also keep a cache in a global variable, or as a property on a class,\nor other methods. For globals, I have found it is useful to have a specific\nfunction for clearing the cache, so you can get a clean slate each time a test\nruns in unit testing or similar`),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`let res\nasync function getCachedPokemon() {\n  if (!res) {\n    res = getPokemon().catch(e => {\n      res = undefined\n    })\n  }\n  return res\n}\nfunction clearCache() {\n  res = undefined\n}\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true}