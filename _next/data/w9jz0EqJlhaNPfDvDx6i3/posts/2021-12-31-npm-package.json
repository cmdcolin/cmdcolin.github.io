{"pageProps":{"post":{"title":"How to make your own npm package with typescript","date":"2021-12-31","slug":"2021-12-31-npm-package","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      strong: \"strong\",\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\",\n      pre: \"pre\",\n      ol: \"ol\",\n      em: \"em\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"There is a lot of mystery around making your own \", _jsx(_components.code, {\n          children: \"npm\"\n        }), \" package. Every package\\nlikely does it a bit differently, and it can be tricky to get a setup you like.\\nShould you use a \\\"starter kit\\\" or a boilerplate example? Or just roll your own?\\nShould you use a bundler? How do you use typescript?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"*Record scratch **\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Why don't we try starting from scratch and seeing where we can get?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"TLDR: here is a github repo with a template package\\nhttps://github.com/cmdcolin/npm-package-tutorial/\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Introduction\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"An \", _jsx(_components.code, {\n          children: \"npm\"\n        }), \" package can be very bare bones. In some sense, npmjs.com is just an\\narbitrary file host, and you can upload pretty much anything you want to it.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The magic is in the package.json file, which tells npm:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"what files are part of your package\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"what to use as the \\\"entry point\\\" (e.g. the file that should be referenced\\nwhen you say \", _jsx(_components.code, {\n            children: \"const lib = require('mypackage')\"\n          }), \")\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"what pre- and post- processing steps should be done when the package is being\\npublished\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"and more!\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Let's try an experiment...\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Initializing a package\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Open up a terminal, and run\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"mkdir mypackage\\ncd mypackage\\ngit init # make mypackage version controlled\\nnpm init\\n# or\\nyarn init\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This init command outputs something like this, and we accept the defaults\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"This utility will walk you through creating a package.json file.\\nIt only covers the most common items, and tries to guess sensible defaults.\\n\\nSee `npm help init` for definitive documentation on these fields\\nand exactly what they do.\\n\\nUse `npm install <pkg>` afterwards to install a package and\\nsave it as a dependency in the package.json file.\\n\\nPress ^C at any time to quit.\\npackage name: (mypackage)\\nversion: (1.0.0)\\ndescription:\\nentry point: (index.js)\\ntest command:\\ngit repository:\\nkeywords:\\nlicense: (ISC)\\nAbout to write to /home/cdiesh/mypackage/package.json:\\n\\n{\\n  \\\"name\\\": \\\"mypackage\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"main\\\": \\\"index.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\n  },\\n  \\\"author\\\": \\\"Colin\\\",\\n  \\\"license\\\": \\\"ISC\\\"\\n}\\n\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Then, you can create a file named \", _jsx(_components.code, {\n          children: \"index.js\"\n        }), \" (in your package.json it says\\n\", _jsx(_components.code, {\n          children: \"\\\"main\\\": \\\"index.js\\\"\"\n        }), \" to refer to this file, the entrypoint)\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In your \", _jsx(_components.code, {\n          children: \"index.js\"\n        }), \" file, generally, you would do things like export a function\\nor functions. I will use commonjs exports here for maximum compatibility:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"module.exports = {\\n  hello: () => {\\n    console.log('hello world')\\n  },\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Publishing a package\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This npm package, \", _jsx(_components.code, {\n          children: \"mypackage\"\n        }), \" can now be published to \", _jsx(_components.code, {\n          children: \"npm\"\n        }), \" with a simple\\ncommand.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm publish\\n# or\\nyarn publish\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This will prompt you for your npmjs.com username, password, email, and if\\nneeded, 2FA token (highly recommended)\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Using your package after it is published\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Once it is published, you can use it in your create-react-app app or other npm\\npackage.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm install mypackage\\n# or\\nyarn add mypackage\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then you can use\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"import { hello } from 'mypackage'\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"in any of your other codebases\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Summary of the simplest NPM package\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This all seems pretty boring thus far but it tells us a couple things\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"packages can be very very bare bones\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"no transpiler or bundler is needed for publishing an npm package\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"our package can consist of a single file and it is uploaded to npm, and the\\n\\\"main\\\" field in package.json provides an entry point\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"the filename index.js is not special, probably it is a hangover from the\\nname index.html. you can use whatever name you want\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Adding typescript\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Let's try adding typescript\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"To do this, we will use the typescript compiler to compile a directory of files\\nin our \\\"src\\\" directory and output the compiled files to a directory named\\n\\\"dist\\\"\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"To start, let's add typescript\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm install --save-dev typescript\\n# or\\nyarn add -D typescript\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Our package.json now will have \", _jsx(_components.code, {\n          children: \"typescript\"\n        }), \" in it's \", _jsx(_components.code, {\n          children: \"devDependencies\"\n        }), \" (this\\nmeans that when someone installs your package, it they don't get typescript as\\na dependency, it is just a dependency for while you are developing the library\\nlocally).\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then we need to create a tsconfig.json for typescript to use\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"yarn tsc --init\\n# or\\nnpx tsc --init\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This will generate a \", _jsx(_components.code, {\n          children: \"tsconfig.json\"\n        }), \" file (needed by \", _jsx(_components.code, {\n          children: \"typescript\"\n        }), \") with a bunch of\\noptions, but I have stripped it down in my projects to look like this\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"include\\\": [\\\"src\\\"],\\n  \\\"compilerOptions\\\": {\\n    \\\"target\\\": \\\"es2018\\\",\\n    \\\"moduleResolution\\\": \\\"node\\\",\\n    \\\"declaration\\\": true, // generate .d.ts files\\n    \\\"sourceMap\\\": true, // generate source map\\n    \\\"outDir\\\": \\\"dist\\\", // output compiled js, d.ts, and source map to dist folder\\n    \\\"strict\\\": true,\\n    \\\"esModuleInterop\\\": true\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Now, we want to change our \", _jsx(_components.code, {\n          children: \"js\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"ts\"\n        }), \" files to use \", _jsx(_components.code, {\n          children: \"typescript\"\n        }), \", let's change them\\nto use normal ESM import/exports\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"util.ts\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"export function getMessage() {\\n  return 'hello'\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"index.ts\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"import { getMessage } from './util'\\nexport function sayMessage() {\\n  console.log(getMessage())\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"And then we will add a \", _jsx(_components.code, {\n          children: \"\\\"build\\\"\"\n        }), \" script to \", _jsx(_components.code, {\n          children: \"package.json\"\n        }), \" to compile the\\nlibrary, and refer to the \", _jsx(_components.code, {\n          children: \"\\\"dist\\\"\"\n        }), \" directory for the \", _jsx(_components.code, {\n          children: \"\\\"files\\\"\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"\\\"main\\\"\"\n        }), \"\\nfields in \", _jsx(_components.code, {\n          children: \"package.json\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"name\\\": \\\"mypackage\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"main\\\": \\\"src/index.js\\\",\\n  \\\"files\\\": [\\\"dist\\\"],\\n  \\\"scripts\\\": {\\n    \\\"build\\\": \\\"tsc\\\"\\n  },\\n  \\\"author\\\": \\\"Colin\\\",\\n  \\\"license\\\": \\\"ISC\\\",\\n  \\\"devDependencies\\\": {\\n    \\\"typescript\\\": \\\"^4.5.4\\\"\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We can now run\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm run build\\n# or\\nyarn build\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"And this will run the \", _jsx(_components.code, {\n          children: \"\\\"build\\\"\"\n        }), \" script we created, which in turn, just runs\\n\", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" with no arguments.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You can also add a \", _jsx(_components.code, {\n          children: \"\\\"prebuild\\\"\"\n        }), \" script that clears out the old contents. In fact,\\nnpm scripts generalizes the naming system -- you can make scripts with whatever name you want, e.g.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"scripts\\\": {\\n    \\\"preparty\\\": \\\"echo preparty\\\",\\n    \\\"party\\\": \\\"echo party\\\",\\n    \\\"postparty\\\": \\\"echo postparty\\\"\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then running\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"$ yarn party\\npreparty\\nparty\\npostparty\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"To make this useful, we will use \", _jsx(_components.code, {\n          children: \"rimraf\"\n        }), \" (a node package) to make a\\ncross-platform removal of the \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" directory\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm install --save-dev rimraf\\n# or\\nyarn add -D rimraf\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"and then update your package.json\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  ...\\n  \\\"scripts\\\": {\\n    \\\"clean\\\": \\\"rimraf dist\\\",\\n    \\\"prebuild\\\": \\\"npm run clean\\\",\\n    \\\"build\\\": \\\"tsc\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"rimraf\\\": \\\"^3.0.2\\\",\\n    \\\"typescript\\\": \\\"^4.5.4\\\"\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We could make it say \\\"rm -rf dist\\\" instead of \\\"rimraf dist\\\" (e.g. run arbitrary\\nshell commands), but rimraf allows it to be cross-platform\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Making sure you create a fresh build before you publish\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Without extra instructions, your \", _jsx(_components.code, {\n          children: \"yarn publish\"\n        }), \" command would not create a\\nfresh build and you could publish an older version that was lingering in the\\n\", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" folder.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We can use a \", _jsx(_components.code, {\n          children: \"preversion\"\n        }), \" script that will automatically get invoked when you\\nrun \", _jsx(_components.code, {\n          children: \"yarn publish\"\n        }), \" to make sure you get a fresh build in the \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" folder\\nbefore you publish\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  ...\\n  \\\"scripts\\\": {\\n    ...\\n    \\\"preversion\\\": \\\"npm run build\\\",\\n  },\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Making sure you push your tag to github after publish\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When you run \", _jsx(_components.code, {\n          children: \"yarn publish\"\n        }), \", npm will automatically create a commit with the\\nversion name and a git tag, it \", _jsx(_components.em, {\n          children: \"will not\"\n        }), \" automatically push tag to your\\nrepository.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Add a \", _jsx(_components.code, {\n          children: \"postversion\"\n        }), \" script that pushes the tag to your repo after your publish\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  ...\\n  \\\"scripts\\\": {\\n    ...\\n    \\\"postversion\\\": \\\"git push --follow-tags\\\",\\n  },\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Incremental builds\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We can use this to do incremental/watch builds\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"npm run build --watch\\n# or\\nyarn build --watch\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Adding testing with ts-jest\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You can use ts-jest to test your code. This involves installing jest, typescript, ts-jest, @types/jest, and then initializing a jest.config.json\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm i -D jest typescript\\n# or\\nyarn add --dev jest typescript\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npm i -D ts-jest @types/jest\\n# or\\nyarn add --dev ts-jest @types/jest\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"npx ts-jest config:init\\n# or\\nyarn ts-jest config:init\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We can then create a test\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"test/util.spec.ts\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"import { getMessage } from '../src/util'\\ntest('expected message returned', () => {\\n  expect(getMessage()).toBe('hello')\\n})\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Then we can then create a script in the package.json that says \", _jsx(_components.code, {\n          children: \"\\\"test\\\": \\\"jest\\\"\"\n        }), \", and then we can say\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"npm run test\\n# or\\nyarn test\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You can also create an alternative system where you use \", _jsx(_components.code, {\n          children: \"babel-eslint\"\n        }), \" and\\nvarious babel strategies to test your code, but if you are using typescript,\\nts-jest+typescript works great.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Add a .gitignore\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Create a .gitignore with just a line that references this \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" folder and \", _jsx(_components.code, {\n          children: \"node_modules\"\n        }), \" folder\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"dist\\nnode_modules\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"The future of ESM modules\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There is a shift happening where modules are changing to be pure ESM rather\\nthan keeping commonjs equivalents\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are many challenges here, and will not be discussed, but it may be a\\nuseful further reading page\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Conclusion\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This tutorial shows you how you can create a basic package that you can publish\\nto \", _jsx(_components.code, {\n          children: \"npm\"\n        }), \". This little boilerplate includes these features:\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Makes clean build when running \", _jsx(_components.code, {\n            children: \"yarn build\"\n          }), \" or \", _jsx(_components.code, {\n            children: \"yarn publish\"\n          })]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Pushes to github after publish\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Uses ts-jest for testing\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Uses esm modules\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You also have full control, and understand the decisions we took to get to this\\npoint. This package does not use any bundling (rollup or webpack or otherwise).\\nIt just uses \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" is used to compile the files to the \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" folder, and the\\ndist folder is published to \", _jsx(_components.code, {\n          children: \"npm\"\n        }), \"! If you need your package to be usable by\\nconsumers that don't themselves use bundlers, consider looking into \", _jsx(_components.code, {\n          children: \"<script type=\\\"module\\\">\"\n        }), \" for importing ESM modules in the browser, or you can bundle\\nyour library using rollup or webpack and output e.g. a UMD bundle\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Final product\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"See https://github.com/cmdcolin/npm-package-tutorial/\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}