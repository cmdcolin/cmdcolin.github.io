{"pageProps":{"post":{"title":"How to make your own npm package with typescript","date":"2021-12-31","slug":"2021-12-31-npm-package","html":"<p>There is a lot of mystery around making your own <code>npm</code> package. Every package\nlikely does it a bit differently, and it can be tricky to get a setup you like.\nShould you use a \"starter kit\" or a boilerplate example? Or just roll your own?\nShould you use a bundler? How do you use typescript?</p>\n<p><strong>*Record scratch **</strong></p>\n<p>Why don't we try starting from scratch and seeing where we can get?</p>\n<p>TLDR: here is a github repo with a template package\n<a href=\"https://github.com/cmdcolin/npm-package-tutorial/\">https://github.com/cmdcolin/npm-package-tutorial/</a></p>\n<h2 id=\"introduction\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#introduction\"><a href=\"#introduction\" style=\"margin-right: 10px\">#</a></a>Introduction</h2>\n<p>An <code>npm</code> package can be very bare bones. In some sense, npmjs.com is just an\narbitrary file host, and you can upload pretty much anything you want to it.</p>\n<p>The magic is in the package.json file, which tells npm:</p>\n<ul>\n<li>what files are part of your package</li>\n<li>what to use as the \"entry point\" (e.g. the file that should be referenced\nwhen you say <code>const lib = require('mypackage')</code>)</li>\n<li>what pre- and post- processing steps should be done when the package is being\npublished</li>\n<li>and more!</li>\n</ul>\n<p>Let's try an experiment...</p>\n<h2 id=\"initializing-a-package\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#initializing-a-package\"><a href=\"#initializing-a-package\" style=\"margin-right: 10px\">#</a></a>Initializing a package</h2>\n<p>Open up a terminal, and run</p>\n<div class=\"highlight highlight-shell\"><pre>mkdir mypackage\n<span class=\"pl-c1\">cd</span> mypackage\ngit init <span class=\"pl-c\"># make mypackage version controlled</span>\nnpm init\n<span class=\"pl-c\"># or</span>\nyarn init\n</pre></div>\n<p>This init command outputs something like this, and we accept the defaults</p>\n<div class=\"highlight highlight-shell\"><pre>This utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee <span class=\"pl-s\"><span class=\"pl-pds\">`</span>npm <span class=\"pl-c1\">help</span> init<span class=\"pl-pds\">`</span></span> <span class=\"pl-k\">for</span> definitive documentation on these fields\nand exactly what they do.\n\nUse <span class=\"pl-s\"><span class=\"pl-pds\">`</span>npm install <span class=\"pl-k\">&#x3C;</span>pkg<span class=\"pl-k\">></span><span class=\"pl-pds\">`</span></span> afterwards to install a package and\nsave it as a dependency <span class=\"pl-k\">in</span> the package.json file.\n\nPress ^C at any <span class=\"pl-k\">time</span> to quit.\npackage name: (mypackage)\nversion: (1.0.0)\ndescription:\nentry point: (index.js)\n<span class=\"pl-c1\">test</span> command:\ngit repository:\nkeywords:\nlicense: (ISC)\nAbout to write to /home/cdiesh/mypackage/package.json:\n\n{\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>name<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mypackage<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>version<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>1.0.0<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>description<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"\"</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>main<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>index.js<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>scripts<span class=\"pl-pds\">\"</span></span>: {\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>echo <span class=\"pl-cce\">\\\"</span>Error: no test specified<span class=\"pl-cce\">\\\"</span> &#x26;&#x26; exit 1<span class=\"pl-pds\">\"</span></span>\n  },\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>author<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Colin<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>license<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ISC<span class=\"pl-pds\">\"</span></span>\n}\n\n</pre></div>\n<p>Then, you can create a file named <code>index.js</code> (in your package.json it says\n<code>\"main\": \"index.js\"</code> to refer to this file, the entrypoint)</p>\n<p>In your <code>index.js</code> file, generally, you would do things like export a function\nor functions. I will use commonjs exports here for maximum compatibility:</p>\n<div class=\"highlight highlight-js\"><pre><span class=\"pl-c1\">module</span>.<span class=\"pl-smi\">exports</span> <span class=\"pl-k\">=</span> {\n  <span class=\"pl-en\">hello</span><span class=\"pl-k\">:</span> () <span class=\"pl-k\">=></span> {\n    <span class=\"pl-en\">console</span>.<span class=\"pl-c1\">log</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>hello world<span class=\"pl-pds\">'</span></span>)\n  },\n}\n</pre></div>\n<h2 id=\"publishing-a-package\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#publishing-a-package\"><a href=\"#publishing-a-package\" style=\"margin-right: 10px\">#</a></a>Publishing a package</h2>\n<p>This npm package, <code>mypackage</code> can now be published to <code>npm</code> with a simple\ncommand.</p>\n<div class=\"highlight highlight-shell\"><pre>npm publish\n<span class=\"pl-c\"># or</span>\nyarn publish\n</pre></div>\n<p>This will prompt you for your npmjs.com username, password, email, and if\nneeded, 2FA token (highly recommended)</p>\n<h2 id=\"using-your-package-after-it-is-published\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#using-your-package-after-it-is-published\"><a href=\"#using-your-package-after-it-is-published\" style=\"margin-right: 10px\">#</a></a>Using your package after it is published</h2>\n<p>Once it is published, you can use it in your create-react-app app or other npm\npackage.</p>\n<div class=\"highlight highlight-shell\"><pre>npm install mypackage\n<span class=\"pl-c\"># or</span>\nyarn add mypackage\n</pre></div>\n<p>Then you can use</p>\n<div class=\"highlight highlight-js\"><pre><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">hello</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>mypackage<span class=\"pl-pds\">'</span></span>\n</pre></div>\n<p>in any of your other codebases</p>\n<h2 id=\"summary-of-the-simplest-npm-package\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#summary-of-the-simplest-npm-package\"><a href=\"#summary-of-the-simplest-npm-package\" style=\"margin-right: 10px\">#</a></a>Summary of the simplest NPM package</h2>\n<p>This all seems pretty boring thus far but it tells us a couple things</p>\n<ol>\n<li>packages can be very very bare bones</li>\n<li>no transpiler or bundler is needed for publishing an npm package</li>\n<li>our package can consist of a single file and it is uploaded to npm, and the\n\"main\" field in package.json provides an entry point</li>\n<li>the filename index.js is not special, probably it is a hangover from the\nname index.html. you can use whatever name you want</li>\n</ol>\n<h2 id=\"adding-typescript\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#adding-typescript\"><a href=\"#adding-typescript\" style=\"margin-right: 10px\">#</a></a>Adding typescript</h2>\n<p>Let's try adding typescript</p>\n<p>To do this, we will use the typescript compiler to compile a directory of files\nin our \"src\" directory and output the compiled files to a directory named\n\"dist\"</p>\n<p>To start, let's add typescript</p>\n<div class=\"highlight highlight-shell\"><pre>npm install --save-dev typescript\n<span class=\"pl-c\"># or</span>\nyarn add -D typescript\n</pre></div>\n<p>Our package.json now will have <code>typescript</code> in it's <code>devDependencies</code> (this\nmeans that when someone installs your package, it they don't get typescript as\na dependency, it is just a dependency for while you are developing the library\nlocally).</p>\n<p>Then we need to create a tsconfig.json for typescript to use</p>\n<div class=\"highlight highlight-shell\"><pre>yarn tsc --init\n<span class=\"pl-c\"># or</span>\nnpx tsc --init\n</pre></div>\n<p>This will generate a <code>tsconfig.json</code> file (needed by <code>typescript</code>) with a bunch of\noptions, but I have stripped it down in my projects to look like this</p>\n<div class=\"highlight highlight-json\"><pre>{\n  <span class=\"pl-ent\">\"include\"</span>: [<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>src<span class=\"pl-pds\">\"</span></span>],\n  <span class=\"pl-ent\">\"compilerOptions\"</span>: {\n    <span class=\"pl-ent\">\"target\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>es2018<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"moduleResolution\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>node<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"declaration\"</span>: <span class=\"pl-c1\">true</span>, <span class=\"pl-ii\">// generate .d.ts files</span>\n    <span class=\"pl-ent\">\"sourceMap\"</span>: <span class=\"pl-c1\">true</span>, <span class=\"pl-ii\">// generate source map</span>\n    <span class=\"pl-ent\">\"outDir\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>dist<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-ii\">// output compiled js, d.ts, and source map to dist folder</span>\n    <span class=\"pl-ent\">\"strict\"</span>: <span class=\"pl-c1\">true</span>,\n    <span class=\"pl-ent\">\"esModuleInterop\"</span>: <span class=\"pl-c1\">true</span>\n  }\n}\n</pre></div>\n<p>Now, we want to change our <code>js</code> to <code>ts</code> files to use <code>typescript</code>, let's change them\nto use normal ESM import/exports</p>\n<p>util.ts</p>\n<div class=\"highlight highlight-ts\"><pre><span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">getMessage</span>() {\n  <span class=\"pl-k\">return</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>hello<span class=\"pl-pds\">'</span></span>\n}\n</pre></div>\n<p>index.ts</p>\n<div class=\"highlight highlight-ts\"><pre><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">getMessage</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>./util<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">sayMessage</span>() {\n  <span class=\"pl-c1\">console</span>.<span class=\"pl-c1\">log</span>(<span class=\"pl-en\">getMessage</span>())\n}\n</pre></div>\n<p>And then we will add a <code>\"build\"</code> script to <code>package.json</code> to compile the\nlibrary, and refer to the <code>\"dist\"</code> directory for the <code>\"files\"</code> and <code>\"main\"</code>\nfields in <code>package.json</code></p>\n<div class=\"highlight highlight-json\"><pre>{\n  <span class=\"pl-ent\">\"name\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mypackage<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-ent\">\"version\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>1.0.0<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-ent\">\"description\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"\"</span></span>,\n  <span class=\"pl-ent\">\"main\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>src/index.js<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-ent\">\"files\"</span>: [<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>dist<span class=\"pl-pds\">\"</span></span>],\n  <span class=\"pl-ent\">\"scripts\"</span>: {\n    <span class=\"pl-ent\">\"build\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tsc<span class=\"pl-pds\">\"</span></span>\n  },\n  <span class=\"pl-ent\">\"author\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Colin<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-ent\">\"license\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ISC<span class=\"pl-pds\">\"</span></span>,\n  <span class=\"pl-ent\">\"devDependencies\"</span>: {\n    <span class=\"pl-ent\">\"typescript\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>^4.5.4<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</pre></div>\n<p>We can now run</p>\n<div class=\"highlight highlight-shell\"><pre>npm run build\n<span class=\"pl-c\"># or</span>\nyarn build\n</pre></div>\n<p>And this will run the <code>\"build\"</code> script we created, which in turn, just runs\n<code>tsc</code> with no arguments.</p>\n<p>You can also add a <code>\"prebuild\"</code> script that clears out the old contents. In fact,\nnpm scripts generalizes the naming system -- you can make scripts with whatever name you want, e.g.</p>\n<div class=\"highlight highlight-json\"><pre>{\n  <span class=\"pl-ent\">\"scripts\"</span>: {\n    <span class=\"pl-ent\">\"preparty\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>echo preparty<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"party\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>echo party<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"postparty\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>echo postparty<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</pre></div>\n<p>Then running</p>\n<div class=\"highlight highlight-shell\"><pre>$ yarn party\npreparty\nparty\npostparty\n</pre></div>\n<p>To make this useful, we will use <code>rimraf</code> (a node package) to make a\ncross-platform removal of the <code>dist</code> directory</p>\n<div class=\"highlight highlight-shell\"><pre>npm install --save-dev rimraf\n<span class=\"pl-c\"># or</span>\nyarn add -D rimraf\n</pre></div>\n<p>and then update your package.json</p>\n<div class=\"highlight highlight-json\"><pre>{\n  <span class=\"pl-ii\">...</span>\n  <span class=\"pl-ent\">\"scripts\"</span>: {\n    <span class=\"pl-ent\">\"clean\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>rimraf dist<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"prebuild\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>npm run clean<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"build\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tsc<span class=\"pl-pds\">\"</span></span>\n  },\n  <span class=\"pl-ent\">\"devDependencies\"</span>: {\n    <span class=\"pl-ent\">\"rimraf\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>^3.0.2<span class=\"pl-pds\">\"</span></span>,\n    <span class=\"pl-ent\">\"typescript\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>^4.5.4<span class=\"pl-pds\">\"</span></span>\n  }\n}\n</pre></div>\n<p>We could make it say \"rm -rf dist\" instead of \"rimraf dist\" (e.g. run arbitrary\nshell commands), but rimraf allows it to be cross-platform</p>\n<h2 id=\"making-sure-you-create-a-fresh-build-before-you-publish\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#making-sure-you-create-a-fresh-build-before-you-publish\"><a href=\"#making-sure-you-create-a-fresh-build-before-you-publish\" style=\"margin-right: 10px\">#</a></a>Making sure you create a fresh build before you publish</h2>\n<p>Without extra instructions, your <code>yarn publish</code> command would not create a\nfresh build and you could publish an older version that was lingering in the\n<code>dist</code> folder.</p>\n<p>We can use a <code>preversion</code> script that will automatically get invoked when you\nrun <code>yarn publish</code> to make sure you get a fresh build in the <code>dist</code> folder\nbefore you publish</p>\n<div class=\"highlight highlight-json\"><pre>{\n  <span class=\"pl-ii\">...</span>\n  <span class=\"pl-ent\">\"scripts\"</span>: {\n    <span class=\"pl-ii\">...</span>\n    <span class=\"pl-ent\">\"preversion\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>npm run build<span class=\"pl-pds\">\"</span></span>,\n  },\n}\n</pre></div>\n<h2 id=\"making-sure-you-push-your-tag-to-github-after-publish\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#making-sure-you-push-your-tag-to-github-after-publish\"><a href=\"#making-sure-you-push-your-tag-to-github-after-publish\" style=\"margin-right: 10px\">#</a></a>Making sure you push your tag to github after publish</h2>\n<p>When you run <code>yarn publish</code>, npm will automatically create a commit with the\nversion name and a git tag, it <em>will not</em> automatically push tag to your\nrepository.</p>\n<p>Add a <code>postversion</code> script that pushes the tag to your repo after your publish</p>\n<div class=\"highlight highlight-json\"><pre>{\n  <span class=\"pl-ii\">...</span>\n  <span class=\"pl-ent\">\"scripts\"</span>: {\n    <span class=\"pl-ii\">...</span>\n    <span class=\"pl-ent\">\"postversion\"</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>git push --follow-tags<span class=\"pl-pds\">\"</span></span>,\n  },\n}\n</pre></div>\n<h2 id=\"incremental-builds\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#incremental-builds\"><a href=\"#incremental-builds\" style=\"margin-right: 10px\">#</a></a>Incremental builds</h2>\n<p>We can use this to do incremental/watch builds</p>\n<pre><code>npm run build --watch\n# or\nyarn build --watch\n</code></pre>\n<h2 id=\"adding-testing-with-ts-jest\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#adding-testing-with-ts-jest\"><a href=\"#adding-testing-with-ts-jest\" style=\"margin-right: 10px\">#</a></a>Adding testing with ts-jest</h2>\n<p>You can use ts-jest to test your code. This involves installing jest, typescript, ts-jest, @types/jest, and then initializing a jest.config.json</p>\n<div class=\"highlight highlight-shell\"><pre>npm i -D jest typescript\n<span class=\"pl-c\"># or</span>\nyarn add --dev jest typescript\n</pre></div>\n<div class=\"highlight highlight-shell\"><pre>npm i -D ts-jest @types/jest\n<span class=\"pl-c\"># or</span>\nyarn add --dev ts-jest @types/jest\n</pre></div>\n<div class=\"highlight highlight-shell\"><pre>npx ts-jest config:init\n<span class=\"pl-c\"># or</span>\nyarn ts-jest config:init\n</pre></div>\n<p>We can then create a test</p>\n<p><code>test/util.spec.ts</code></p>\n<div class=\"highlight highlight-ts\"><pre><span class=\"pl-k\">import</span> { <span class=\"pl-smi\">getMessage</span> } <span class=\"pl-k\">from</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>../src/util<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-en\">test</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>expected message returned<span class=\"pl-pds\">'</span></span>, () <span class=\"pl-k\">=></span> {\n  <span class=\"pl-en\">expect</span>(<span class=\"pl-en\">getMessage</span>()).<span class=\"pl-en\">toBe</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>hello<span class=\"pl-pds\">'</span></span>)\n})\n</pre></div>\n<p>Then we can then create a script in the package.json that says <code>\"test\": \"jest\"</code>, and then we can say</p>\n<pre><code>npm run test\n# or\nyarn test\n</code></pre>\n<p>You can also create an alternative system where you use <code>babel-eslint</code> and\nvarious babel strategies to test your code, but if you are using typescript,\nts-jest+typescript works great.</p>\n<h2 id=\"add-a-gitignore\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#add-a-gitignore\"><a href=\"#add-a-gitignore\" style=\"margin-right: 10px\">#</a></a>Add a .gitignore</h2>\n<p>Create a .gitignore with just a line that references this <code>dist</code> folder and <code>node_modules</code> folder</p>\n<pre><code>dist\nnode_modules\n</code></pre>\n<h2 id=\"the-future-of-esm-modules\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#the-future-of-esm-modules\"><a href=\"#the-future-of-esm-modules\" style=\"margin-right: 10px\">#</a></a>The future of ESM modules</h2>\n<p>There is a shift happening where modules are changing to be pure ESM rather\nthan keeping commonjs equivalents</p>\n<p><a href=\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></p>\n<p>There are many challenges here, and will not be discussed, but it may be a\nuseful further reading page</p>\n<h2 id=\"conclusion\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#conclusion\"><a href=\"#conclusion\" style=\"margin-right: 10px\">#</a></a>Conclusion</h2>\n<p>This tutorial shows you how you can create a basic package that you can publish\nto <code>npm</code>. This little boilerplate includes these features:</p>\n<ul>\n<li>Makes clean build when running <code>yarn build</code> or <code>yarn publish</code></li>\n<li>Pushes to github after publish</li>\n<li>Uses ts-jest for testing</li>\n<li>Uses esm modules</li>\n</ul>\n<p>You also have full control, and understand the decisions we took to get to this\npoint. This package does not use any bundling (rollup or webpack or otherwise).\nIt just uses <code>tsc</code> is used to compile the files to the <code>dist</code> folder, and the\ndist folder is published to <code>npm</code>! If you need your package to be usable by\nconsumers that don't themselves use bundlers, consider looking into <code>&#x3C;script type=\"module\"></code> for importing ESM modules in the browser, or you can bundle\nyour library using rollup or webpack and output e.g. a UMD bundle</p>\n<h2 id=\"final-product\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#final-product\"><a href=\"#final-product\" style=\"margin-right: 10px\">#</a></a>Final product</h2>\n<p>See <a href=\"https://github.com/cmdcolin/npm-package-tutorial/\">https://github.com/cmdcolin/npm-package-tutorial/</a></p>"}},"__N_SSG":true}