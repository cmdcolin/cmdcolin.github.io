{"pageProps":{"post":{"title":"Detecting structural variants and the SAM format - the long (reads) and short (reads) of it","date":"2022-02-06","slug":"2022-02-06-sv-sam","mdxSource":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var s=(e,n,i)=>n in e?h(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i,a=(e,n)=>{for(var i in n||(n={}))r.call(n,i)&&s(e,i,n[i]);if(o)for(var i of o(n))p.call(n,i)&&s(e,i,n[i]);return e},l=(e,n)=>m(e,c(n));var d=(e,n)=>{var i={};for(var t in e)r.call(e,t)&&n.indexOf(t)<0&&(i[t]=e[t]);if(e!=null&&o)for(var t of o(e))n.indexOf(t)<0&&p.call(e,t)&&(i[t]=e[t]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var t=i,{components:e}=t,n=d(t,[\"components\"]);return mdx(MDXLayout,l(a(a({},layoutProps),n),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` specification is pretty amazing\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"https://samtools.github.io/hts-specs/SAMv1.pdf\"),` but it is also fairly terse and\nabstract, and true understanding comes from playing with real world data but I\nwill try to explain some stuff I have learned about reads, especially as they\nrelate to structural variants.`),mdx(\"p\",null,`Disclaimer: I'm a developer of JBrowse 2. This document has some screenshots\nand links for it, feel free to try it at `,mdx(\"a\",a({parentName:\"p\"},{href:\"https://jbrowse.org\"}),\"https://jbrowse.org\")),mdx(\"p\",null,\"Also note: When I refer to a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record in this document, it could come from\na `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\", or \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" file as \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` are just alternative\nencodings of `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\")),mdx(\"h2\",null,\"Basics\"),mdx(\"h3\",null,\"What is a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SAM\"),\" file and how does it relate to \",mdx(\"inlineCode\",{parentName:\"h3\"},\"BAM\"),\" and \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CRAM\"),\"?\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file contains \"reads\" from a sequencer. The \"reads\" often originally\nare from `,mdx(\"inlineCode\",{parentName:\"p\"},\"FASTQ\"),\" format files. The reads from \",mdx(\"inlineCode\",{parentName:\"p\"},\"FASTQ\"),` format are inputted into\nan aligner such as `,mdx(\"inlineCode\",{parentName:\"p\"},\"bwa\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"bowtie\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"minimap2\"),` (there are many others) which\nmap the reads to a reference genome, and output `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" format.\"),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" is a text format that you can read with your text editor. \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),` and\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),\" are compressed representations of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format, and you can use\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"samtools view yourfile.bam\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"samtools view yourfile.cram\"),` to convert them\nback to SAM (or pipe to `,mdx(\"inlineCode\",{parentName:\"p\"},\"less\"),` to just read snippets of it without a full\nconversion)`),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" record is a single line in the file. A \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` record generally\ncorresponds to a single read, but as we will see, a split alignment may produce\nmultiple `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\" records that refer to the same source read.\"),mdx(\"p\",null,\"Note: you can also store unaligned data in \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` but most of the\ntime, the reads in these formats is aligned to a reference genome`),mdx(\"h3\",null,\"What is a \",mdx(\"inlineCode\",{parentName:\"h3\"},\"CIGAR\"),\" string\"),mdx(\"p\",null,\"A \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` string is a \"compact idiosyncratic gapped alignment report\". Yes,\nthat's an acronym. It can tell you where insertions and deletions are in an\nalignment. Some `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings tell you where mismatches are (so-called\nextended CIGAR, with the `,mdx(\"inlineCode\",{parentName:\"p\"},\"X\"),\" letter), but I don't often see this.\"),mdx(\"h3\",null,\"What is an \",mdx(\"inlineCode\",{parentName:\"h3\"},\"MD\"),\" string\"),mdx(\"p\",null,\"An \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),\" string is a tag in \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file that helps tell you where the mismatches\nare, and can be combined with a `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` to get the position of the mismatches\nwithout looking at a reference genome.`),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),\" string is commonly seen in \",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\" files (not generally \",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` because\nit already uses reference compression and requires a reference sequence to\ndecode).`),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"MD\"),` tag contains information about deletions (including the bases of the\nreference genome, which would otherwise not be indicated) and mismatches (same,\nindicating the base of the reference genome at a SNPs position), but not\ninsertions.`),mdx(\"h2\",null,\"Detecting SVs from long reads\"),mdx(\"h3\",null,\"What are split alignments?\"),mdx(\"p\",null,`Split alignments, or chimeric-alignments are alignments where part of the read\naligns to perhaps chr1, and part of it maps to perhaps chr4. It is worth\nreading the definition of \"Chimeric alignment\" from SAMv1.pdf (not reproduced\nhere)`),mdx(\"p\",null,mdx(\"a\",a({parentName:\"p\"},{href:\"https://samtools.github.io/hts-specs/SAMv1.pdf\"}),\"https://samtools.github.io/hts-specs/SAMv1.pdf\")),mdx(\"p\",null,`There is no limitation on how many splits might occur so the split can align to\n3, 4, or more different places. Each part of the split puts a new line in the\nSAM file. As SAMv1.pdf tells us, one read is marked as \"representative\", I call\nthis the \"primary\" read, while the other components of the split read are maked\nsupplementary, given the 2048 flag (0x80). Only the \"primary\" read generally\nhas a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\" field (column 10)\"),mdx(\"p\",null,`Split alignments are especially common with long reads, and it can indicate\nthat there may be a structural variant where the two chromosomes are fused\ntogether (which may create gene fusions, or other types of phenomena).`),mdx(\"p\",null,`note: split alignments are different from \"multi-mappers\" where the entire read\nmaps maps equally well to, say, chr4 and chr1. Split reads maps part to chr1,\nand part to chr4`),mdx(\"p\",null,\"See again the SAMv1.pdf for the definition of multi-mapping\"),mdx(\"h3\",null,\"What is the \",mdx(\"inlineCode\",{parentName:\"h3\"},\"SA\"),\" tag?\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag is outputted on each part of the split alignment, e.g. the primary\ncontains an `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),\" tag that refers to all the locations, \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings, and\nmore for all the supplementary reads, and each of the supplementary reads also\ncontains an `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag that refers to the primary alignment and each other\nsupplementary alignment.`),mdx(\"p\",null,\"Fun fact: The \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag conceptually can result in a 'quadratic explosion' of\ndata, because each part of the split contains references to every other part.\nFor example, if a read is split into 4 pieces, then each read would would have\nan SA tag with 3 segments, so 3`,\"*\",\"4 segments will be documented in the\",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),\" tag.\"),mdx(\"h3\",null,\"Reconstructing a split alignment given the primary alignment\"),mdx(\"p\",null,`If we are given the the primary alignment of an arbitrary split read, then we\ncan construct what that split looks like compared to the reference genome.`),mdx(\"p\",null,`If we are not given the primary alignment (e.g. we are starting from a\nsupplementary alignment) then we can search the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` list for the one that is\nprimary, because at least one will be.`),mdx(\"p\",null,\"Now that we have the primary alignment, it will have the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\" and the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag\ncontaining the `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` of all the different parts of the split. Therefore, we\ncan piece together the complete picture of the entire split alignment.`),mdx(\"p\",null,mdx(\"img\",a({parentName:\"p\"},{src:\"/media/linear-alignment.png\",alt:null})),`\nFigure showing JBrowse 2 piecing together a long read vs the reference genome from a single read`),mdx(\"p\",null,`In order to reconstruct the full picture of the alignment from the single read\nas JBrowse 2 does, take the `,mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` strings of the primary alignment and each\nof the segments of the SA tag, sort them by the amount of softclipping in them,\nand then this tells me where each piece of the split alignment came from in the\noriginal `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\".\"),mdx(\"h3\",null,\"SAM vs VCF - Breakends vs split alignments\"),mdx(\"p\",null,\"An interesting outcome (to me) is that from a single record in a \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, I\ncan reconstruct the \"derived\" genome around a region of interest from a single\nread.`),mdx(\"p\",null,\"If I was to try to do this with the \",mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` Breakend specification (section 5.4\nof VCF4.3.pdf), it may actually be more challenging than from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` read.\nThis is because a Breakend in `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` format is only an edge in a graph (and the\nsequences are nodes). Therefore, in order to properly reconstruct a structural\nvariant from a `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),\" with Breakends, I would have to construct the graph,\"),mdx(\"p\",null,`Now, this has caveats: a single read is noisy and does not contain as aggregate\nevidence as looking at all the reads in a region. But still, interpretation of\nthe `,mdx(\"inlineCode\",{parentName:\"p\"},\"VCF\"),` breakend specification is challenging due to imposing a sequence graph\non the genome, while the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SA\"),` tag remains just a simple set of linear alignments\nthat can easily be pieces together`),mdx(\"h3\",null,\"Haplotype tagged reads\"),mdx(\"p\",null,\"A new trend has been to create \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"BAM\"),\"/\",mdx(\"inlineCode\",{parentName:\"p\"},\"CRAM\"),` files with tagged reads,\nwhich tells us which haplotype a read was inferred to have come from. This is\ncommonly done with the `,mdx(\"inlineCode\",{parentName:\"p\"},\"HP\"),\" tag, which might have \",mdx(\"inlineCode\",{parentName:\"p\"},\"HP=0\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"HP=1\"),` for a\ndiploid genome. Tools like whatshap can add these tags to a `,mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` file, and IGV\nand JBrowse 2 can color and sort by these tags`),mdx(\"p\",null,mdx(\"a\",a({parentName:\"p\"},{href:\"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\"}),\"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\")),mdx(\"p\",null,mdx(\"img\",a({parentName:\"p\"},{src:\"/media/color_by_tag.png\",alt:null}))),mdx(\"h2\",null,\"How do you detect SVs with paired-end reads?\"),mdx(\"p\",null,`Paired-end reads are short reads, e.g. 150bp each. This makes them unable to\nrecover some large structural variants.`),mdx(\"p\",null,`However, paired-end reads have a number of attributes that can be used to\ndetect paired end reads`),mdx(\"h3\",null,\"Distance between pairs being abnormally large or short\"),mdx(\"p\",null,\"The distance between pairs is encoded by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),\" column in the \",mdx(\"inlineCode\",{parentName:\"p\"},\"SAM\"),` format.\nThe distance between pairs with good mapping is relatively constant and called\nthe \"insert length\". This comes from how the sequencing is done: paired-end\nsequencing performs sequencing on both ends of a fragment.`),mdx(\"p\",null,`But, if you are mapping reads vs the reference genome, and you observe that\nthey are abnormally far apart, say 50kb apart instead of 1kb apart, this may\nindicate there your sample contains a deletion relative to the reference.`),mdx(\"h3\",null,'An abundance of reads being \"clipped\" at a particular position'),mdx(\"p\",null,`This can indicate that part of the reads map well, but then there was an abrupt\nstop to the mapping. This might mean that there is a sequence that was an\ninsertion at that position, or a deletion, or a translocation.`),mdx(\"p\",null,\"The clipping is indicated by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"CIGAR\"),` string, either at the start or end of\nit by an `,mdx(\"inlineCode\",{parentName:\"p\"},\"S\"),\" or an \",mdx(\"inlineCode\",{parentName:\"p\"},\"H\"),\". The \",mdx(\"inlineCode\",{parentName:\"p\"},\"S\"),` indicates \"soft clipping\", and indicates that\nthe sequence of the clipped portion can be found in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),` field of the\nprimary alignment. The `,mdx(\"inlineCode\",{parentName:\"p\"},\"H\"),` is hard clipped, and the sequence that is hard\nclipped will not appear in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"SEQ\"),\".\"),mdx(\"h3\",null,\"Unexpected pair orientation\"),mdx(\"p\",null,\"With standard paired end sequencing, the pairs normally point at each other\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`forward reverse\n --->    <---\n`)),mdx(\"p\",null,\"If the stranded-ness of the pair is off, then it could indicate a structural variant\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-typescript\"}),`// rnext: rnext column in sam\n// ref: refname column in sam\n// flags: flag integer in sam\n// tlen: tlen column in sam\n// code adapted from IGV\nfunction getPairOrientation(\n  flags: number,\n  ref: string,\n  rnext: string,\n  tlen: number,\n) {\n  // this read is not unmapped &&\n  // this read's mate is also not unmapped &&\n  // this read's mate is on the same reference genome\n  if (!flags & 4 && !flags & 8 && ref === rnext) {\n    const s1 = flags & 16 ? 'R' : 'F'\n    const s2 = flags & 32 ? 'R' : 'F'\n    let o1 = ' '\n    let o2 = ' '\n\n    // if first in pair\n    if (flags & 64) {\n      o1 = '1'\n      o2 = '2'\n    }\n\n    // else if second in pair\n    else if (flags & 128) {\n      o1 = '2'\n      o2 = '1'\n    }\n\n    const tmp = []\n    if (tlen > 0) {\n      tmp[0] = s1\n      tmp[1] = o1\n      tmp[2] = s2\n      tmp[3] = o2\n    } else {\n      tmp[2] = s1\n      tmp[3] = o1\n      tmp[0] = s2\n      tmp[1] = o2\n    }\n    return tmp.join('')\n  }\n  return null\n}\n`)),mdx(\"p\",null,\"If you have standard paired end reads, it will return \",mdx(\"inlineCode\",{parentName:\"p\"},\"FR\"),\" forward-reverse, similar to the text diagram\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`forward reverse\n --->    <---\n`)),mdx(\"p\",null,`This guide from IGV is helpful for interpreting the pair directionality with\npatterns of SVs using \"Color by pair orientation\"`),mdx(\"p\",null,mdx(\"a\",a({parentName:\"p\"},{href:\"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"}),\"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\")),mdx(\"p\",null,\"Example of an inverted duplication using JBrowse 2's \",mdx(\"inlineCode\",{parentName:\"p\"},\"Color by pair orientation\"),\" setting (very similar to IGV)\"),mdx(\"p\",null,mdx(\"img\",a({parentName:\"p\"},{src:\"/media/inverted_duplication.png\",alt:null}))),mdx(\"p\",null,`Figure: This shows an inverted (tandem) duplication in 1000 genomes data. The\ntandem duplication can produce green arrows which have reads pointing in\nopposite directions e.g. `,mdx(\"inlineCode\",{parentName:\"p\"},\"<--\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"-->\"),`, while blue arrows which can indicate\nan inversion point in the same direction e.g. `,mdx(\"inlineCode\",{parentName:\"p\"},\"-->\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"-->\")),mdx(\"h3\",null,\"Caveat about TLEN\"),mdx(\"p\",null,\"Note that \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` is a field in the SAM format that is somewhat ill defined,\nat least in the sense that different tools may use it differently\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\"}),\"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\")),mdx(\"p\",null,\"If needed, you can calculate \",mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),` yourself if process the file yourself\n(process all reads, get the actual records for the pairs, and calculate\ndistance) but I have not had trouble with basic usage of tools that rely on the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"TLEN\"),\" from the data files themselves\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true}