{"pageProps":{"post":{"title":"Misconceptions your team might have during The Big Rewrite","date":"2020-06-03","slug":"2020-06-03","html":"<p>Disclaimer: I enjoy the project I am working on and this is still a work\nin progress. I just had to rant about the stuff I go through in my job\nhere, but it does not reflect the opinions of my emplorer, and my\npersonal opinion is despite these troubles we are coming along nicely</p>\n<p>I joined a team that was doing the big rewrite in 2018. I was involved\nin the project before then and knew it's ins and outs, and frankly think\nit's still a great system. In order to break it's \"limitations\" a grand\nv2 gets started. I think my team has been good. My tech lead is really\ngood at architecture. Where I really resist kind of \"writing new\narchitecture that is not already there\", he can pull up entirely new\nconcepts and abstractions that are all pretty good. Myself, I don't much\nenjoy writing \"new architecture\" if there is something already there\nthat I can use, and I'll try to refer to the existence of an existing\nthing instead of creating new exotic stuff.</p>\n<p>Now, what happened during the big rewrite so far. 4 people on the team,\n2 years in</p>\n<p>Persistent confusion about sources of slowness in our app</p>\n<ul>\n<li>it's only slow because devtools is open (maybe it is! but this is\ndefinitely a red herring. the code should work with devtools open.\nreason that's been stated: devtools adds a \"bunch of instrumentation to\nthe promises that slows it down\"...stated without any evidence during a\n3 hour long planning call...)\n - it's only slow because we're using a development build of react, try\na production build (the production build makes some stuff faster, but it\nis NOT going to save your butt if you are constantly rerending all your\ncomponents unnecessarily every millisecond during user scroll, which is\nsomething we suffered from, and it creeps back in if you are not careful\nbecause you can't write tests against this so often one day I'll be\nlooking at my devtools and suddenly things are rendering twice per frame\n(signature of calling an unnecessary setState), tons of unnecessary\ncomponents rendering in every frame (signature of\ncomponentShouldUpdate/bad functional react memoizing, etc))\n - it's slow because we are hogging the main thread all the time, our\nkiller new feature in v2 is an intense webworker framework. now main\nthread contention is a concern, but really our app needs to just be\nperformant all around, webworkers just offloads that cpu spinning to\nanother core. what we have done in v2 is we went whole hog and made our\ncode rely on OffscreenCanvas which 0 browsers support. also, our\nwebworker bundles (worker-loader webpack build) are huge webpack things\nthat pretty much contain all the code that is on the main thread so it's\njust massive. that makes it slow at loading time, and makes it harder to\nthink about our worker threads in a lighter-weight way, and the worker\nconcept is now very deeply entrenched in a lot of the code (all code has\nto think of things in terms of rpc calls)\n - it's slow because there are processes that haven't been aborted\nspinning in the background, so we must build out an intensive\nAbortController thing that touches the entirety of all our code\nincluding sending abort signals across the RPC boundary in hopes that a\nlocked up webworker will respond to this (note: our first version of the\nsoftware had zero aborting, did not from my perspective suffer.\narguments with the team have gotten accusatory where I just claim that\nthere is no evidence that the aborting is helping us, pointing to the\nfact that our old code works fine, and that if our new code suffers\nwithout aborting, that means something else is wrong. I have not really\nbeen given a proper response for this, and so the curse of passing\nAbortSignals onto every function via an extra function parameter drags\non\n - it's slow because we are not multithreading..., so we put two views\nof the same data into different webworkers (but now each webworker\nseparately downloads the same data, which leads to more resource spent,\nmore network IO, more slowness)</li>\n</ul>\n<p>confusion about what our old users needs are</p>\n<ul>\n<li>\n<p>tracks not having per-track scroll (problem: leads to many scrolls\nwithin-scrolls, still unresolved problem)\n - the name indexing was always a big problem (yes it is slow but is it\nreally THE critical problem we face? likely not: bioinformatics people\nrun a data pipeline, it takes a couple days, so what). use elasticsearch\nif it sucks so bad\n - our users are \"stupid\" so they need to have every single thing GUI\neditable (interesting endeavor, but our design for this has been\ndifficult, and has not yet delivered on simplifying the system for\nusers)\n - our users \"do not like modal popups\" so we design everything into a\ntiny sidedrawer that barely can contain the relevant data that they want\nto see</p>\n</li>\n<li>\n<p>having interest in catering to obscure or not very clear \"user\nstories\" like displaying the same exact region twice on the screen at\nonce saying \"someone will want to do this\", but causing a ton of extra\nlogical weirdness from this</p>\n</li>\n<li>\n<p>not catering to emerging areas of user needs such as breaking our\nlarge app into components that can be re-used, and instead just going\nfull hog on a large monolith project and treating our monolith as a\ngiant hammer that will solve everyones problems, when in reality, our\nusers are also programmers that could benefit from using smaller\ncomponentized versions of our code</p>\n</li>\n<li>\n<p>confusion about \"what our competitors have\". sometimes my team one day\nwas like \"alright we just do that and then we have everything product X\nhas?\" and I just had to be clear and be like, no! the competitor has a\nreall pretty intricate complex system that we could never hope to\nreplicate. but does that matter? probably not, but even still, we likely\ndon't have even 20% of the full set of functions of a competitor.\nluckily we have our own strengths that make us compelling besides that\n20%</p>\n</li>\n<li>\n<p>making it so our product requires a server side component to run,\nwhere our first version was much more amenable to running as a static\nsite</p>\n</li>\n<li>\n<p>etc...</p>\n</li>\n</ul>\n<p>but what does all this imply?</p>\n<p>there are persistent confusion about what the challenges we face are,\nwhat the architectural needs are, what our user stores are, what our new\nv2 design goals are, and more. It's really crazy</p>"}},"__N_SSG":true}