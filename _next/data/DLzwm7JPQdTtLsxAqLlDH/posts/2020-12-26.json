{"pageProps":{"post":{"title":"Making a serverless website for photo and video upload pt. 2","date":"2020-12-26","slug":"2020-12-26","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"This post follows\\non https://cmdcolin.github.io/2020-12-24.html\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is possible I zoomed ahead too fast to make this a continuous tutorial, but\\noverall I just wanted to post an update\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In pt. 1 I learned how to use the \", _jsx(_components.code, {\n        children: \"aws-sam\"\n      }), \" CLI tool. This was a great insight\\nfor me about automating deployments. I can now simply run \", _jsx(_components.code, {\n        children: \"sam deploy\"\n      }), \" and it\\nwill create new dynamodb tables, lambda functions, etc.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After writing pt 1. I converted the existing vue-js app that was in the aws\\ntutorial and converted it to react. Then I extended the app to allow\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Posting comments on photos\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Uploading multiple files\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Uploading videos etc.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It will be hard to summarize all the changes since now the app has taken off a\\nlittle bit but it looks like this:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Repo structure\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \" ./frontend # created using npx create-react-app frontend --template\\n typescript\\n ./frontend/src/App.tsx # main frontend app code in react\\n ./lambdas/\\n ./lambdas/postFile # post a file to the lambda, this uploads a row to\\n dynamodb and returns a pre-signed URL for uploading (note that if the\\n client failed it's upload, that row in the lambda DB might be in a bad\\n state...)\\n ./lambdas/getFiles # get all files that were ever posted\\n ./lambdas/postComment # post a comment on a picture with POST\\n request\\n ./lambdas/getComments?file=filename.jpg # get comments on a\\n picture/video with GET request\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is a detailed code for uploading the file. We upload one file at a\\ntime, but the client code post to the lambda endpoint individually for\\neach file\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This generates a pre-signed URL to allow the client-side JS (not the\\nlambda itself) to directly upload to S3, and also posts a row in the S3\\nto the filename that will. It is very similar code in\\nto https://cmdcolin.github.io/2020-12-24.html\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"./lambdas/postFile/app.js\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"'use strict'\\n\\nconst AWS = require('aws-sdk')\\nconst multipart = require('./multipart')\\nAWS.config.update({ region: process.env.AWS_REGION })\\nconst s3 = new AWS.S3()\\n\\n// Change this value to adjust the signed URL's expiration\\nconst URL_EXPIRATION_SECONDS = 300\\n\\n// Main Lambda entry point\\nexports.handler = async event => {\\n  return await getUploadURL(event)\\n}\\n\\nconst { AWS_REGION: region } = process.env\\n\\nconst dynamodb = new AWS.DynamoDB({ apiVersion: '2012-08-10', region })\\n\\nasync function uploadPic({\\n  timestamp,\\n  filename,\\n  message,\\n  user,\\n  date,\\n  contentType,\\n}) {\\n  const params = {\\n    Item: {\\n      timestamp: {\\n        N: `${timestamp}`,\\n      },\\n      filename: {\\n        S: filename,\\n      },\\n      message: {\\n        S: message,\\n      },\\n      user: {\\n        S: user,\\n      },\\n      date: {\\n        S: date,\\n      },\\n      contentType: {\\n        S: contentType,\\n      },\\n    },\\n    TableName: 'files',\\n  }\\n  return dynamodb.putItem(params).promise()\\n}\\n\\nconst getUploadURL = async function (event) {\\n  try {\\n    const data = multipart.parse(event)\\n    const { filename, contentType, user, message, date } = data\\n    const timestamp = +Date.now()\\n    const Key = `${timestamp}-${filename}` // Get signed URL from S3\\n\\n    const s3Params = {\\n      Bucket: process.env.UploadBucket,\\n      Key,\\n      Expires: URL_EXPIRATION_SECONDS,\\n      ContentType: contentType, // This ACL makes the uploaded object publicly readable. You must also uncomment // the extra permission for the Lambda function in the SAM template.\\n\\n      ACL: 'public-read',\\n    }\\n\\n    const uploadURL = await s3.getSignedUrlPromise('putObject', s3Params)\\n\\n    await uploadPic({\\n      timestamp,\\n      filename: Key,\\n      message,\\n      user,\\n      date,\\n      contentType,\\n    })\\n\\n    return JSON.stringify({\\n      uploadURL,\\n      Key,\\n    })\\n  } catch (e) {\\n    const response = {\\n      statusCode: 500,\\n      body: JSON.stringify({ message: `${e}` }),\\n    }\\n    return response\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"./lambdas/getFiles/app.js\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"// eslint-disable-next-line import/no-unresolved\\nconst AWS = require('aws-sdk')\\n\\nconst { AWS_REGION: region } = process.env\\n\\nconst docClient = new AWS.DynamoDB.DocumentClient()\\n\\nconst getItems = function () {\\n  const params = {\\n    TableName: 'files',\\n  }\\n\\n  return docClient.scan(params).promise()\\n}\\n\\nexports.handler = async event => {\\n  try {\\n    const result = await getItems()\\n    return {\\n      statusCode: 200,\\n      body: JSON.stringify(result),\\n    }\\n  } catch (e) {\\n    return {\\n      statusCode: 400,\\n      body: JSON.stringify({ message: `${e}` }),\\n    }\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"./frontend/src/App.tsx (excerpt)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"async function myfetch(params: string, opts?: any) {\\n  const response = await fetch(params, opts)\\n  if (!response.ok) {\\n    throw new Error(`HTTP ${response.status}\\n ${response.statusText}`)\\n  }\\n  return response.json()\\n}\\n\\nfunction UploadDialog({\\n  open,\\n  onClose,\\n}: {\\n  open: boolean\\n  onClose: () => void\\n}) {\\n  const [images, setImages] = useState<FileList>()\\n  const [error, setError] = useState<Error>()\\n  const [loading, setLoading] = useState(false)\\n  const [total, setTotal] = useState(0)\\n  const [completed, setCompleted] = useState(0)\\n  const [user, setUser] = useState('')\\n  const [message, setMessage] = useState('')\\n  const classes = useStyles()\\n\\n  const handleClose = () => {\\n    setError(undefined)\\n    setLoading(false)\\n    setImages(undefined)\\n    setCompleted(0)\\n    setTotal(0)\\n    setMessage('')\\n    onClose()\\n  }\\n\\n  return (\\n    <Dialog onClose={handleClose} open={open}>\\n           <DialogTitle>upload a file (supports picture or video)</DialogTitle> \\n         \\n      <DialogContent>\\n               <label htmlFor=\\\"user\\\">name (optional) </label>\\n               <input\\n          type=\\\"text\\\"\\n          value={user}\\n          onChange={event => setUser(event.target.value)}\\n          id=\\\"user\\\"\\n        />\\n               <br />       <label htmlFor=\\\"user\\\">message (optional) </label>\\n               \\n        <input\\n          type=\\\"text\\\"\\n          value={message}\\n          onChange={event => setMessage(event.target.value)}\\n          id=\\\"message\\\"\\n        />\\n               <br />\\n               \\n        <input\\n          multiple\\n          type=\\\"file\\\"\\n          onChange={e => {\\n            let files = e.target.files\\n            if (files && files.length) {\\n              setImages(files)\\n            }\\n          }}\\n        />       {error ? (\\n          <div className={classes.error}>{`${error}`}</div>\\n        ) : loading ? (\\n          `Uploading...${completed}/${total}`\\n        ) : completed ? (\\n          <h2>Uploaded </h2>\\n        ) : null}       <DialogActions>\\n                   \\n          <Button\\n            style={{ textTransform: 'none' }}\\n            onClick={async () => {\\n              try {\\n                if (images) {\\n                  setLoading(true)\\n                  setError(undefined)\\n                  setCompleted(0)\\n                  setTotal(images.length)\\n                  await Promise.all(\\n                    Array.from(images).map(async image => {\\n                      const data = new FormData()\\n                      data.append('message', message)\\n                      data.append('user', user)\\n                      data.append('date', new Date().toLocaleString())\\n                      data.append('filename', image.name)\\n                      data.append('contentType', image.type)\\n                      const res = await myfetch(API_ENDPOINT + '/postFile', {\\n                        method: 'POST',\\n                        body: data,\\n                      })\\n\\n                      await myfetch(res.uploadURL, {\\n                        method: 'PUT',\\n                        body: image,\\n                      })\\n\\n                      setCompleted(completed => completed + 1)\\n                    }),\\n                  )\\n                  setTimeout(() => {\\n                    handleClose()\\n                  }, 500)\\n                }\\n              } catch (e) {\\n                setError(e)\\n              }\\n            }}\\n            color=\\\"primary\\\"\\n          >\\n                       upload          \\n          </Button>\\n                   <Button\\n            onClick={handleClose}\\n            color=\\\"primary\\\"\\n            style={{ textTransform: 'none' }}\\n          >\\n                       cancel          \\n          </Button>       \\n        </DialogActions>     \\n      </DialogContent>\\n         \\n    </Dialog>\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"template.yaml for AWS\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-yaml\",\n        children: \" AWSTemplateFormatVersion: 2010-09-09\\n Transform: AWS::Serverless-2016-10-31\\n Description: S3 Uploader\\n\\n Resources:\\n  filesDynamoDBTable:\\n    Type: AWS::DynamoDB::Table\\n    Properties:\\n      AttributeDefinitions:\\n        - AttributeName: \\\"timestamp\\\"\\n          AttributeType: \\\"N\\\"\\n      KeySchema:\\n        - AttributeName: \\\"timestamp\\\"\\n          KeyType: \\\"HASH\\\"\\n      ProvisionedThroughput:\\n        ReadCapacityUnits: \\\"5\\\"\\n        WriteCapacityUnits: \\\"5\\\"\\n      TableName: \\\"files\\\"\\n\\n  # HTTP API\\n  MyApi:\\n    Type: AWS::Serverless::HttpApi\\n    Properties:\\n      # CORS configuration - this is open for development only and\\n should be restricted in prod.\\n      # See\\n <https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-httpapicorsconfiguration.html>\\n      CorsConfiguration:\\n        AllowMethods:\\n          - GET\\n          - POST\\n          - DELETE\\n          - OPTIONS\\n        AllowHeaders:\\n          - \\\"*\\\"\\n        AllowOrigins:\\n          - \\\"*\\\"\\n\\n  UploadRequestFunction:\\n    Type: AWS::Serverless::Function\\n    Properties:\\n      CodeUri: lambdas/postFile/\\n      Handler: app.handler\\n      Runtime: nodejs12.x\\n      Timeout: 3\\n      MemorySize: 128\\n      Environment:\\n        Variables:\\n          UploadBucket: !Ref S3UploadBucket\\n      Policies:\\n        - AmazonDynamoDBFullAccess\\n        - S3WritePolicy:\\n            BucketName: !Ref S3UploadBucket\\n        - Statement:\\n            - Effect: Allow\\n              Resource: !Sub \\\"arn:aws:s3:::${S3UploadBucket}/\\\"\\n              Action:\\n                - s3:putObjectAcl\\n      Events:\\n        UploadAssetAPI:\\n          Type: HttpApi\\n          Properties:\\n            Path: /postFile\\n            Method: post\\n            ApiId: !Ref MyApi\\n\\n\\n  FileReadFunction:\\n    Type: AWS::Serverless::Function\\n    Properties:\\n      CodeUri: lambdas/getFiles/\\n      Handler: app.handler\\n      Runtime: nodejs12.x\\n      Timeout: 3\\n      MemorySize: 128\\n      Policies:\\n        - AmazonDynamoDBFullAccess\\n      Events:\\n        UploadAssetAPI:\\n          Type: HttpApi\\n          Properties:\\n            Path: /getFiles\\n            Method: get\\n            ApiId: !Ref MyApi\\n\\n  ## S3 bucket\\n  S3UploadBucket:\\n    Type: AWS::S3::Bucket\\n    Properties:\\n      CorsConfiguration:\\n        CorsRules:\\n          - AllowedHeaders:\\n              - \\\"*\\\"\\n            AllowedMethods:\\n              - GET\\n              - PUT\\n              - HEAD\\n            AllowedOrigins:\\n              - \\\"*\\\"\\n\\n\\n ## Take a note of the outputs for deploying the workflow templates\\n in this sample application\\n Outputs:\\n  APIendpoint:\\n    Description: \\\"HTTP API endpoint URL\\\"\\n    Value: !Sub\\n \\\"https://${MyApi}.execute-api.${AWS::Region}.amazonaws.com\\\"\\n  S3UploadBucketName:\\n    Description: \\\"S3 bucket for application uploads\\\"\\n    Value: !Ref \\\"S3UploadBucket\\\"\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To display all the pictures I use a switch from video or img tag based\\non contentType.startsWith('video'). I also use the \\\"figcaption\\\" HTML tag\\nto have a little caption on the pics/videos\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"./frontend/src/App.tsx\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function Media({\\n  file,\\n  style,\\n  onClick,\\n  children,\\n}: {\\n  file: File\\n  onClick?: Function\\n  style?: React.CSSProperties\\n  children?: React.ReactNode\\n}) {\\n  const { filename, contentType } = file\\n  const src = `${BUCKET}/${filename}`\\n  return (\\n    <figure style={{ display: 'inline-block' }}>\\n           \\n      <picture>\\n               \\n        {contentType.startsWith('video') ? (\\n          <video style={style} src={src} controls onClick={onClick as any} />\\n        ) : (\\n          <img style={style} src={src} onClick={onClick as any} />\\n        )}\\n             \\n      </picture>\\n           <figcaption>{children}</figcaption>   \\n    </figure>\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now the really fun part: if you get an image of a picture frame\\nlike https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can make it a border for any image or video using border-image CSS\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"style = {\\n  border: '30px solid',\\n  borderImage: `url(borders/${border}) 30 round`,\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/638602799897329664_0.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Summary\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The template.yaml automatically deploys the lambdas for postFile/getFile\\nand the files table in dynamoDB\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The React app uses postFile for each file in an \", _jsx(_components.code, {\n        children: \"<input type=\\\"file\\\"/>\"\n      }), \",\\nthe code uses React hooks and functional components but is hopefully not\\ntoo complex\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I also added commenting on photos. The code is not shown here but you\\ncan look in the source code for details\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/638602799897329664_1.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Overall this has been a good experience learning to develop this app and\\nlearning to automate the cloud deployment is really good for ensuring\\nreliability and fast iteration.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Also quick note on serverless CLI vs aws-sam. I had tried a serverless\\nCLI tutorial from another user but it didn't click with me, while the\\naws-sam tutorial from\\nhttps://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1 was\\na great kick start for me. I am sure the serverless CLI is great too and\\nit ensures a bit less vendor lock in, but then is also a little bit\\nremoved from the native aws config schemas. Probably fine though\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Source code https://github.com/cmdcolin/aws_photo_gallery/\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}