{"pageProps":{"post":{"title":"Making a serverless website for photo and video upload pt. 2","date":"2020-12-26","slug":"2020-12-26","content":"<p>This post follows\non <a href=\"https://cmdcolin.github.io/2020-12-24.html\">https://cmdcolin.github.io/2020-12-24.html</a></p>\n<p>It is possible I zoomed ahead too fast to make this a continuous\ntutorial, but overall I just wanted to post an update</p>\n<p>In pt. 1 I learned how to use the <code>aws-sam</code> CLI tool. This was a great\ninsight for me about automating deployments. I can now simply run <code>sam deploy</code> and it will create new dynamodb tables, lambda functions, etc.</p>\n<p>After writing pt 1. I converted the existing vue-js app that was in the\naws tutorial and converted it to react. Then I extended the app to allow</p>\n<ul>\n<li>Posting comments on photos</li>\n<li>Uploading multiple files</li>\n<li>Uploading videos\netc.</li>\n</ul>\n<p>It will be hard to summarize all the changes since now the app has taken\noff a little bit but it looks like this:</p>\n<p>Repo structure</p>\n<pre><code> ./frontend # created using npx create-react-app frontend --template\n typescript\n ./frontend/src/App.tsx # main frontend app code in react\n ./lambdas/\n ./lambdas/postFile # post a file to the lambda, this uploads a row to\n dynamodb and returns a pre-signed URL for uploading (note that if the\n client failed it's upload, that row in the lambda DB might be in a bad\n state...)\n ./lambdas/getFiles # get all files that were ever posted\n ./lambdas/postComment # post a comment on a picture with POST\n request\n ./lambdas/getComments?file=filename.jpg # get comments on a\n picture/video with GET request\n</code></pre>\n<p>Here is a detailed code for uploading the file. We upload one file at a\ntime, but the client code post to the lambda endpoint individually for\neach file</p>\n<p>This generates a pre-signed URL to allow the client-side JS (not the\nlambda itself) to directly upload to S3, and also posts a row in the S3\nto the filename that will. It is very similar code in\nto <a href=\"https://cmdcolin.github.io/2020-12-24.html\">https://cmdcolin.github.io/2020-12-24.html</a></p>\n<p>./lambdas/postFile/app.js</p>\n<pre><code>'use strict'\n\nconst AWS = require('aws-sdk')\nconst multipart = require('./multipart')\nAWS.config.update({ region: process.env.AWS_REGION })\nconst s3 = new AWS.S3()\n\n// Change this value to adjust the signed URL's expiration\nconst URL_EXPIRATION_SECONDS = 300\n\n// Main Lambda entry point\nexports.handler = async event => {\n  return await getUploadURL(event)\n}\n\nconst { AWS_REGION: region } = process.env\n\nconst dynamodb = new AWS.DynamoDB({ apiVersion: '2012-08-10', region })\n\nasync function uploadPic({\n  timestamp,\n  filename,\n  message,\n  user,\n  date,\n  contentType,\n}) {\n  const params = {\n    Item: {\n      timestamp: {\n        N: `${timestamp}`,\n      },\n      filename: {\n        S: filename,\n      },\n      message: {\n        S: message,\n      },\n      user: {\n        S: user,\n      },\n      date: {\n        S: date,\n      },\n      contentType: {\n        S: contentType,\n      },\n    },\n    TableName: 'files',\n  }\n  return dynamodb.putItem(params).promise()\n}\n\nconst getUploadURL = async function (event) {\n  try {\n    const data = multipart.parse(event)\n    const { filename, contentType, user, message, date } = data\n    const timestamp = +Date.now()\n    const Key = `${timestamp}-${filename}` // Get signed URL from S3\n\n    const s3Params = {\n      Bucket: process.env.UploadBucket,\n      Key,\n      Expires: URL_EXPIRATION_SECONDS,\n      ContentType: contentType, // This ACL makes the uploaded object publicly readable. You must also uncomment // the extra permission for the Lambda function in the SAM template.\n\n      ACL: 'public-read',\n    }\n\n    const uploadURL = await s3.getSignedUrlPromise('putObject', s3Params)\n\n    await uploadPic({\n      timestamp,\n      filename: Key,\n      message,\n      user,\n      date,\n      contentType,\n    })\n\n    return JSON.stringify({\n      uploadURL,\n      Key,\n    })\n  } catch (e) {\n    const response = {\n      statusCode: 500,\n      body: JSON.stringify({ message: `${e}` }),\n    }\n    return response\n  }\n}\n</code></pre>\n<p>./lambdas/getFiles/app.js</p>\n<pre><code>// eslint-disable-next-line import/no-unresolved\nconst AWS = require('aws-sdk')\n\nconst { AWS_REGION: region } = process.env\n\nconst docClient = new AWS.DynamoDB.DocumentClient()\n\nconst getItems = function () {\n  const params = {\n    TableName: 'files',\n  }\n\n  return docClient.scan(params).promise()\n}\n\nexports.handler = async event => {\n  try {\n    const result = await getItems()\n    return {\n      statusCode: 200,\n      body: JSON.stringify(result),\n    }\n  } catch (e) {\n    return {\n      statusCode: 400,\n      body: JSON.stringify({ message: `${e}` }),\n    }\n  }\n}\n</code></pre>\n<p>./frontend/src/App.tsx (excerpt)</p>\n<pre><code>async function myfetch(params: string, opts?: any) {\n  const response = await fetch(params, opts)\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}\n ${response.statusText}`)\n  }\n  return response.json()\n}\n\nfunction UploadDialog({\n  open,\n  onClose,\n}: {\n  open: boolean\n  onClose: () => void\n}) {\n  const [images, setImages] = useState&#x3C;FileList>()\n  const [error, setError] = useState&#x3C;Error>()\n  const [loading, setLoading] = useState(false)\n  const [total, setTotal] = useState(0)\n  const [completed, setCompleted] = useState(0)\n  const [user, setUser] = useState('')\n  const [message, setMessage] = useState('')\n  const classes = useStyles()\n\n  const handleClose = () => {\n    setError(undefined)\n    setLoading(false)\n    setImages(undefined)\n    setCompleted(0)\n    setTotal(0)\n    setMessage('')\n    onClose()\n  }\n\n  return (\n    &#x3C;Dialog onClose={handleClose} open={open}>\n           &#x3C;DialogTitle>upload a file (supports picture or video)&#x3C;/DialogTitle> \n         &#x3C;DialogContent>\n               &#x3C;label htmlFor=\"user\">name (optional) &#x3C;/label>\n               &#x3C;input\n          type=\"text\"\n          value={user}\n          onChange={event => setUser(event.target.value)}\n          id=\"user\"\n        />\n               &#x3C;br />       &#x3C;label htmlFor=\"user\">message (optional) &#x3C;/label>\n               \n        &#x3C;input\n          type=\"text\"\n          value={message}\n          onChange={event => setMessage(event.target.value)}\n          id=\"message\"\n        />\n               &#x3C;br />\n               \n        &#x3C;input\n          multiple\n          type=\"file\"\n          onChange={e => {\n            let files = e.target.files\n            if (files &#x26;&#x26; files.length) {\n              setImages(files)\n            }\n          }}\n        />\n               {error ? (\n          &#x3C;div className={classes.error}>{`${error}`}&#x3C;/div>\n        ) : loading ? (\n          `Uploading...${completed}/${total}`\n        ) : completed ? (\n          &#x3C;h2>Uploaded &#x3C;/h2>\n        ) : null}       \n        &#x3C;DialogActions>\n                   \n          &#x3C;Button\n            style={{ textTransform: 'none' }}\n            onClick={async () => {\n              try {\n                if (images) {\n                  setLoading(true)\n                  setError(undefined)\n                  setCompleted(0)\n                  setTotal(images.length)\n                  await Promise.all(\n                    Array.from(images).map(async image => {\n                      const data = new FormData()\n                      data.append('message', message)\n                      data.append('user', user)\n                      data.append('date', new Date().toLocaleString())\n                      data.append('filename', image.name)\n                      data.append('contentType', image.type)\n                      const res = await myfetch(API_ENDPOINT + '/postFile', {\n                        method: 'POST',\n                        body: data,\n                      })\n\n                      await myfetch(res.uploadURL, {\n                        method: 'PUT',\n                        body: image,\n                      })\n\n                      setCompleted(completed => completed + 1)\n                    }),\n                  )\n                  setTimeout(() => {\n                    handleClose()\n                  }, 500)\n                }\n              } catch (e) {\n                setError(e)\n              }\n            }}\n            color=\"primary\"\n          >\n                       upload          \n          &#x3C;/Button>\n                   &#x3C;Button\n            onClick={handleClose}\n            color=\"primary\"\n            style={{ textTransform: 'none' }}\n          >\n                       cancel          \n          &#x3C;/Button>       \n        &#x3C;/DialogActions>\n             \n      &#x3C;/DialogContent>   \n    &#x3C;/Dialog>\n  )\n}\n</code></pre>\n<p>template.yaml for AWS</p>\n<pre><code> AWSTemplateFormatVersion: 2010-09-09\n Transform: AWS::Serverless-2016-10-31\n Description: S3 Uploader\n\n Resources:\n  filesDynamoDBTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      AttributeDefinitions:\n        - AttributeName: \"timestamp\"\n          AttributeType: \"N\"\n      KeySchema:\n        - AttributeName: \"timestamp\"\n          KeyType: \"HASH\"\n      ProvisionedThroughput:\n        ReadCapacityUnits: \"5\"\n        WriteCapacityUnits: \"5\"\n      TableName: \"files\"\n\n  # HTTP API\n  MyApi:\n    Type: AWS::Serverless::HttpApi\n    Properties:\n      # CORS configuration - this is open for development only and\n should be restricted in prod.\n      # See\n &#x3C;https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-httpapicorsconfiguration.html>\n      CorsConfiguration:\n        AllowMethods:\n          - GET\n          - POST\n          - DELETE\n          - OPTIONS\n        AllowHeaders:\n          - \"*\"\n        AllowOrigins:\n          - \"*\"\n\n  UploadRequestFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: lambdas/postFile/\n      Handler: app.handler\n      Runtime: nodejs12.x\n      Timeout: 3\n      MemorySize: 128\n      Environment:\n        Variables:\n          UploadBucket: !Ref S3UploadBucket\n      Policies:\n        - AmazonDynamoDBFullAccess\n        - S3WritePolicy:\n            BucketName: !Ref S3UploadBucket\n        - Statement:\n            - Effect: Allow\n              Resource: !Sub \"arn:aws:s3:::${S3UploadBucket}/\"\n              Action:\n                - s3:putObjectAcl\n      Events:\n        UploadAssetAPI:\n          Type: HttpApi\n          Properties:\n            Path: /postFile\n            Method: post\n            ApiId: !Ref MyApi\n\n\n  FileReadFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: lambdas/getFiles/\n      Handler: app.handler\n      Runtime: nodejs12.x\n      Timeout: 3\n      MemorySize: 128\n      Policies:\n        - AmazonDynamoDBFullAccess\n      Events:\n        UploadAssetAPI:\n          Type: HttpApi\n          Properties:\n            Path: /getFiles\n            Method: get\n            ApiId: !Ref MyApi\n\n  ## S3 bucket\n  S3UploadBucket:\n    Type: AWS::S3::Bucket\n    Properties:\n      CorsConfiguration:\n        CorsRules:\n          - AllowedHeaders:\n              - \"*\"\n            AllowedMethods:\n              - GET\n              - PUT\n              - HEAD\n            AllowedOrigins:\n              - \"*\"\n\n\n ## Take a note of the outputs for deploying the workflow templates\n in this sample application\n Outputs:\n  APIendpoint:\n    Description: \"HTTP API endpoint URL\"\n    Value: !Sub\n \"https://${MyApi}.execute-api.${AWS::Region}.amazonaws.com\"\n  S3UploadBucketName:\n    Description: \"S3 bucket for application uploads\"\n    Value: !Ref \"S3UploadBucket\"\n\n</code></pre>\n<p>To display all the pictures I use a switch from video or img tag based\non contentType.startsWith('video'). I also use the \"figcaption\" HTML tag\nto have a little caption on the pics/videos</p>\n<p>./frontend/src/App.tsx</p>\n<pre><code> function Media({\n  file,\n  style,\n  onClick,\n  children,\n }: {\n  file: File;\n  onClick?: Function;\n  style?: React.CSSProperties;\n  children?: React.ReactNode;\n }) {\n  const { filename, contentType } = file;\n  const src = `${BUCKET}/${filename}`;\n  return (\n    &#x3C;figure style={{ display: \"inline-block\" }}>\n      &#x3C;picture>\n        {contentType.startsWith(\"video\") ? (\n          &#x3C;video style={style} src={src} controls onClick={onClick as\n any} />\n        ) : (\n          &#x3C;img style={style} src={src} onClick={onClick as any} />\n        )}\n      &#x3C;/picture>\n      &#x3C;figcaption>{children}&#x3C;/figcaption>\n    &#x3C;/figure>\n  );\n }\n</code></pre>\n<p>Now the really fun part: if you get an image of a picture frame\nlike <a href=\"https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T\">https://www.amazon.com/Paintings-Frames-Antique-Shatterproof-Osafs2-Gld-A3/dp/B06XNQ8W9T</a></p>\n<p>You can make it a border for any image or video using border-image CSS</p>\n<pre><code>     style = {\n         border: \"30px solid\",\n         borderImage: `url(borders/${border}) 30 round`\n     }\n</code></pre>\n<p><img src=\"/media/638602799897329664_0.png\" alt=\"\"></p>\n<p>Summary</p>\n<p>The template.yaml automatically deploys the lambdas for postFile/getFile\nand the files table in dynamoDB</p>\n<p>The React app uses postFile for each file in an <code>&#x3C;input type=\"file\"/></code>,\nthe code uses React hooks and functional components but is hopefully not\ntoo complex</p>\n<p>I also added commenting on photos. The code is not shown here but you\ncan look in the source code for details</p>\n<p><img src=\"/media/638602799897329664_1.png\" alt=\"\"></p>\n<p>Overall this has been a good experience learning to develop this app and\nlearning to automate the cloud deployment is really good for ensuring\nreliability and fast iteration.</p>\n<p>Also quick note on serverless CLI vs aws-sam. I had tried a serverless\nCLI tutorial from another user but it didn't click with me, while the\naws-sam tutorial from\n<a href=\"https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1\">https://searchvoidstar.tumblr.com/post/638408397901987840/making-a-serverless-website-for-photo-upload-pt-1</a> was\na great kick start for me. I am sure the serverless CLI is great too and\nit ensures a bit less vendor lock in, but then is also a little bit\nremoved from the native aws config schemas. Probably fine though</p>\n<p>Source code <a href=\"https://github.com/cmdcolin/aws_photo_gallery/\">https://github.com/cmdcolin/aws_photo_gallery/</a></p>\n"}},"__N_SSG":true}