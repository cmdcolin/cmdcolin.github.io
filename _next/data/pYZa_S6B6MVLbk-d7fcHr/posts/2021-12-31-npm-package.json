{"pageProps":{"post":{"title":"How to make your own npm package with typescript","date":"2021-12-31","slug":"2021-12-31-npm-package","mdxSource":{"compiledSource":"var c=Object.defineProperty,u=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var s=(n,a,t)=>a in n?c(n,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[a]=t,e=(n,a)=>{for(var t in a||(a={}))p.call(a,t)&&s(n,t,a[t]);if(o)for(var t of o(a))r.call(a,t)&&s(n,t,a[t]);return n},l=(n,a)=>u(n,m(a));var d=(n,a)=>{var t={};for(var i in n)p.call(n,i)&&a.indexOf(i)<0&&(t[i]=n[i]);if(n!=null&&o)for(var i of o(n))a.indexOf(i)<0&&r.call(n,i)&&(t[i]=n[i]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var i=t,{components:n}=i,a=d(i,[\"components\"]);return mdx(MDXLayout,l(e(e({},layoutProps),a),{components:n,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"There is a lot of mystery around making your own \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` package. Every package\nlikely does it a bit differently, and it can be tricky to get a setup you like.\nShould you use a \"starter kit\" or a boilerplate example? Or just roll your own?\nShould you use a bundler? How do you use typescript?`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"*\",\"Record scratch \",\"*\",\"*\")),mdx(\"p\",null,\"Why don't we try starting from scratch and seeing where we can get?\"),mdx(\"p\",null,`TLDR: here is a github repo with a template package\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cmdcolin/npm-package-tutorial/\"}),\"https://github.com/cmdcolin/npm-package-tutorial/\")),mdx(\"h2\",null,\"Introduction\"),mdx(\"p\",null,\"An \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` package can be very bare bones. In some sense, npmjs.com is just an\narbitrary file host, and you can upload pretty much anything you want to it.`),mdx(\"p\",null,\"The magic is in the package.json file, which tells npm:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"what files are part of your package\"),mdx(\"li\",{parentName:\"ul\"},`what to use as the \"entry point\" (e.g. the file that should be referenced\nwhen you say `,mdx(\"inlineCode\",{parentName:\"li\"},\"const lib = require('mypackage')\"),\")\"),mdx(\"li\",{parentName:\"ul\"},`what pre- and post- processing steps should be done when the package is being\npublished`),mdx(\"li\",{parentName:\"ul\"},\"and more!\")),mdx(\"p\",null,\"Let's try an experiment...\"),mdx(\"h2\",null,\"Initializing a package\"),mdx(\"p\",null,\"Open up a terminal, and run\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`mkdir mypackage\ncd mypackage\ngit init # make mypackage version controlled\nnpm init\n# or\nyarn init\n`)),mdx(\"p\",null,\"This init command outputs something like this, and we accept the defaults\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`This utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee \\`npm help init\\` for definitive documentation on these fields\nand exactly what they do.\n\nUse \\`npm install <pkg>\\` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\npackage name: (mypackage)\nversion: (1.0.0)\ndescription:\nentry point: (index.js)\ntest command:\ngit repository:\nkeywords:\nlicense: (ISC)\nAbout to write to /home/cdiesh/mypackage/package.json:\n\n{\n  \"name\": \"mypackage\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\\\"Error: no test specified\\\\\" && exit 1\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\"\n}\n\n`)),mdx(\"p\",null,\"Then, you can create a file named \",mdx(\"inlineCode\",{parentName:\"p\"},\"index.js\"),` (in your package.json it says\n`,mdx(\"inlineCode\",{parentName:\"p\"},'\"main\": \"index.js\"'),\" to refer to this file, the entrypoint)\"),mdx(\"p\",null,\"In your \",mdx(\"inlineCode\",{parentName:\"p\"},\"index.js\"),` file, generally, you would do things like export a function\nor functions. I will use commonjs exports here for maximum compatibility:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`module.exports = {\n  hello: () => {\n    console.log('hello world')\n  },\n}\n`)),mdx(\"h2\",null,\"Publishing a package\"),mdx(\"p\",null,\"This npm package, \",mdx(\"inlineCode\",{parentName:\"p\"},\"mypackage\"),\" can now be published to \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` with a simple\ncommand.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm publish\n# or\nyarn publish\n`)),mdx(\"p\",null,`This will prompt you for your npmjs.com username, password, email, and if\nneeded, 2FA token (highly recommended)`),mdx(\"h2\",null,\"Using your package after it is published\"),mdx(\"p\",null,`Once it is published, you can use it in your create-react-app app or other npm\npackage.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm install mypackage\n# or\nyarn add mypackage\n`)),mdx(\"p\",null,\"Then you can use\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`import { hello } from 'mypackage'\n`)),mdx(\"p\",null,\"in any of your other codebases\"),mdx(\"h2\",null,\"Summary of the simplest NPM package\"),mdx(\"p\",null,\"This all seems pretty boring thus far but it tells us a couple things\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"packages can be very very bare bones\"),mdx(\"li\",{parentName:\"ol\"},\"no transpiler or bundler is needed for publishing an npm package\"),mdx(\"li\",{parentName:\"ol\"},`our package can consist of a single file and it is uploaded to npm, and the\n\"main\" field in package.json provides an entry point`),mdx(\"li\",{parentName:\"ol\"},`the filename index.js is not special, probably it is a hangover from the\nname index.html. you can use whatever name you want`)),mdx(\"h2\",null,\"Publishing a package that contains multiple files\"),mdx(\"p\",null,`More often than not, we may actually want a little more complexity. We may not\nwant all our code to exist in a single file. So, in this case, we can actually\npublish a folder of files to `,mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),\".\"),mdx(\"p\",null,\"So inside of our \",mdx(\"inlineCode\",{parentName:\"p\"},\"mypackage\"),\" folder, let's make a src directory\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`mkdir src\ntouch src/index.js\ntouch src/util.js\n`)),mdx(\"p\",null,\"And we can then have a \",mdx(\"inlineCode\",{parentName:\"p\"},\"util.js\"),\" file\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`//util.js\nmodule.exports = {\n  getMessage: () => {\n    return 'hello'\n  },\n}\n`)),mdx(\"p\",null,\"And a \",mdx(\"inlineCode\",{parentName:\"p\"},\"index.js\"),\" file\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`//index.js\nconst { getMessage } = require('./util')\nmodule.exports = {\n  sayMessage: () => {\n    console.log(getMessage())\n  },\n}\n`)),mdx(\"p\",null,`In our package.json, we can edit it to have a \"files\" field, and make the main\nto refer to \"src/index.js\"`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"name\": \"mypackage2\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"src/index.js\",\n  \"files\": [\"src\"],\n  \"scripts\": {\n    \"test\": \"echo \\\\\"Error: no test specified\\\\\" && exit 1\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\"\n}\n`)),mdx(\"p\",null,\"Then when we publish this package, it will upload the \",mdx(\"inlineCode\",{parentName:\"p\"},\"src\"),` directory\nspecifically, including both `,mdx(\"inlineCode\",{parentName:\"p\"},\"src/index.js\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"src/util.js\"),` in their raw\nform, and tell it that the entry point is `,mdx(\"inlineCode\",{parentName:\"p\"},\"src/index.js\"),\".\"),mdx(\"p\",null,`This may still be in the \"duh, this is too simple territory\", I just wanted to\nlay the groundwork for uploading a directory of files for what a `,mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),` package\ncan be.`),mdx(\"h2\",null,\"Adding typescript\"),mdx(\"p\",null,`Let's try adding typescript. We will compile a directory of files in our \"src\"\ndirectory to a new set of files in a \"dist\" directory`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm install --save-dev typescript\n# or\nyarn add -D typescript\n`)),mdx(\"p\",null,\"Our package.json now will have \",mdx(\"inlineCode\",{parentName:\"p\"},\"typescript\"),\" in it's \",mdx(\"inlineCode\",{parentName:\"p\"},\"devDependencies\"),` (this\nmeans that when someone installs your package, it they don't get typescript as\na dependency, it is just a dependency for while you are developing the library\nlocally).`),mdx(\"p\",null,\"Then we need to create a tsconfig.json for typescript to use\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`yarn tsc --init\n# or\nnpx tsc --init\n`)),mdx(\"p\",null,\"This will generate a \",mdx(\"inlineCode\",{parentName:\"p\"},\"tsconfig.json\"),\" file (needed by \",mdx(\"inlineCode\",{parentName:\"p\"},\"typescript\"),`) with a bunch of\noptions, but I have stripped it down in my projects to look like this`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"moduleResolution\": \"node\",\n    \"declaration\": true, // generate .d.ts files\n    \"sourceMap\": true, // generate source map\n    \"outDir\": \"dist\", // output compiled js, d.ts, and source map to dist folder\n    \"strict\": true,\n    \"esModuleInterop\": true\n  }\n}\n`)),mdx(\"p\",null,\"Now, we want to change our \",mdx(\"inlineCode\",{parentName:\"p\"},\"js\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"ts\"),\" files to use \",mdx(\"inlineCode\",{parentName:\"p\"},\"typescript\"),`, let's change them\nto use normal ESM import/exports`),mdx(\"p\",null,\"util.ts\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`export function getMessage() {\n  return 'hello'\n}\n`)),mdx(\"p\",null,\"index.ts\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`import { getMessage } from './util'\nexport function sayMessage() {\n  console.log(getMessage())\n}\n`)),mdx(\"p\",null,\"And then we will add a \",mdx(\"inlineCode\",{parentName:\"p\"},'\"build\"'),\" script to \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),` to compile the\nlibrary, and refer to the `,mdx(\"inlineCode\",{parentName:\"p\"},'\"dist\"'),\" directory for the \",mdx(\"inlineCode\",{parentName:\"p\"},'\"files\"'),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},'\"main\"'),`\nfields in `,mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"name\": \"mypackage\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"src/index.js\",\n  \"files\": [\"dist\"],\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^4.5.4\"\n  }\n}\n`)),mdx(\"p\",null,\"We can now run\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm run build\n# or\nyarn build\n`)),mdx(\"p\",null,\"And this will run the \",mdx(\"inlineCode\",{parentName:\"p\"},'\"build\"'),` script we created, which in turn, just runs\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"tsc\"),\" with no arguments.\"),mdx(\"p\",null,\"You can also add a \",mdx(\"inlineCode\",{parentName:\"p\"},'\"prebuild\"'),` script that clears out the old contents. In fact,\nnpm scripts generalizes the naming system -- you can make scripts with whatever name you want, e.g.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  \"scripts\": {\n    \"preparty\": \"echo preparty\",\n    \"party\": \"echo party\",\n    \"postparty\": \"echo postparty\"\n  }\n}\n`)),mdx(\"p\",null,\"Then running\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`$ yarn party\npreparty\nparty\npostparty\n`)),mdx(\"p\",null,\"To make this useful, we will use \",mdx(\"inlineCode\",{parentName:\"p\"},\"rimraf\"),` (a node package) to make a\ncross-platform removal of the `,mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),\" directory\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm install --save-dev rimraf\n# or\nyarn add -D rimraf\n`)),mdx(\"p\",null,\"and then update your package.json\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  ...\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"prebuild\": \"npm run clean\",\n    \"build\": \"tsc\"\n  },\n  \"devDependencies\": {\n    \"rimraf\": \"^3.0.2\",\n    \"typescript\": \"^4.5.4\"\n  }\n}\n`)),mdx(\"p\",null,`We could make it say \"rm -rf dist\" instead of \"rimraf dist\" (e.g. run arbitrary\nshell commands), but rimraf allows it to be cross-platform`),mdx(\"h2\",null,\"Making sure you create a fresh build before you publish\"),mdx(\"p\",null,\"Without extra instructions, your \",mdx(\"inlineCode\",{parentName:\"p\"},\"yarn publish\"),` command would not create a\nfresh build and you could publish an older version that was lingering in the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),\" folder.\"),mdx(\"p\",null,\"We can use a \",mdx(\"inlineCode\",{parentName:\"p\"},\"preversion\"),` script that will automatically get invoked when you\nrun `,mdx(\"inlineCode\",{parentName:\"p\"},\"yarn publish\"),\" to make sure you get a fresh build in the \",mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),` folder\nbefore you publish`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  ...\n  \"scripts\": {\n    ...\n    \"preversion\": \"npm run build\",\n  },\n}\n`)),mdx(\"h2\",null,\"Making sure you push your tag to github after publish\"),mdx(\"p\",null,\"When you run \",mdx(\"inlineCode\",{parentName:\"p\"},\"yarn publish\"),`, npm will automatically create a commit with the\nversion name and a git tag, it `,mdx(\"em\",{parentName:\"p\"},\"will not\"),` automatically push tag to your\nrepository.`),mdx(\"p\",null,\"Add a \",mdx(\"inlineCode\",{parentName:\"p\"},\"postversion\"),\" script that pushes the tag to your repo after your publish\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),`{\n  ...\n  \"scripts\": {\n    ...\n    \"postversion\": \"git push --follow-tags\",\n  },\n}\n`)),mdx(\"h2\",null,\"Incremental builds\"),mdx(\"p\",null,\"We can use this to do incremental/watch builds\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`npm run build --watch\n# or\nyarn build --watch\n`)),mdx(\"h2\",null,\"Adding testing with ts-jest\"),mdx(\"p\",null,\"You can use ts-jest to test your code. This involves installing jest, typescript, ts-jest, @types/jest, and then initializing a jest.config.json\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm i -D jest typescript\n# or\nyarn add --dev jest typescript\n`)),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npm i -D ts-jest @types/jest\n# or\nyarn add --dev ts-jest @types/jest\n`)),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-sh\"}),`npx ts-jest config:init\n# or\nyarn ts-jest config:init\n`)),mdx(\"p\",null,\"We can then create a test\"),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"test/util.spec.ts\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),`import { getMessage } from '../src/util'\ntest('expected message returned', () => {\n  expect(getMessage()).toBe('hello')\n})\n`)),mdx(\"p\",null,\"Then we can then create a script in the package.json that says \",mdx(\"inlineCode\",{parentName:\"p\"},'\"test\": \"jest\"'),\", and then we can say\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`npm run test\n# or\nyarn test\n`)),mdx(\"p\",null,\"You can also create an alternative system where you use \",mdx(\"inlineCode\",{parentName:\"p\"},\"babel-eslint\"),` and\nvarious babel strategies to test your code, but if you are using typescript,\nts-jest+typescript works great.`),mdx(\"h2\",null,\"Add a .gitignore\"),mdx(\"p\",null,\"Create a .gitignore with just a line that references this \",mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),\" folder and \",mdx(\"inlineCode\",{parentName:\"p\"},\"node_modules\"),\" folder\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`dist\nnode_modules\n`)),mdx(\"h2\",null,\"The future of ESM modules\"),mdx(\"p\",null,`There is a shift happening where modules are changing to be pure ESM rather\nthan keeping commonjs equivalents`),mdx(\"p\",null,mdx(\"a\",e({parentName:\"p\"},{href:\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\"}),\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\")),mdx(\"p\",null,`There are many challenges here, and will not be discussed, but it may be a\nuseful further reading page`),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`This tutorial shows you how you can create a basic package that you can publish\nto `,mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),\". This little boilerplate includes these features:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Makes clean build when running \",mdx(\"inlineCode\",{parentName:\"li\"},\"yarn build\"),\" or \",mdx(\"inlineCode\",{parentName:\"li\"},\"yarn publish\")),mdx(\"li\",{parentName:\"ul\"},\"Pushes to github after publish\"),mdx(\"li\",{parentName:\"ul\"},\"Uses ts-jest for testing\"),mdx(\"li\",{parentName:\"ul\"},\"Uses esm modules\")),mdx(\"p\",null,`You also have full control, and understand the decisions we took to get to this\npoint. This package does not use any bundling (rollup or webpack or otherwise).\nIt just uses `,mdx(\"inlineCode\",{parentName:\"p\"},\"tsc\"),\" is used to compile the files to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"dist\"),` folder, and the\ndist folder is published to `,mdx(\"inlineCode\",{parentName:\"p\"},\"npm\"),`! If you need your package to be usable by\nconsumers that don't themselves use bundlers, consider looking into `,mdx(\"inlineCode\",{parentName:\"p\"},'<script type=\"module\">'),` for importing ESM modules in the browser, or you can bundle\nyour library using rollup or webpack and output e.g. a UMD bundle`),mdx(\"h2\",null,\"Final product\"),mdx(\"p\",null,\"See \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cmdcolin/npm-package-tutorial/\"}),\"https://github.com/cmdcolin/npm-package-tutorial/\")))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true}