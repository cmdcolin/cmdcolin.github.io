{"pageProps":{"post":{"title":"Querying InterMine databases using R","date":"2016-06-17","slug":"2016-06-17","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"In the past, I had found some ways to do simple queries on InterMine web\\nservices using basic HTTP commands with R (see\\nhttps://gist.github.com/cmdcolin/4758167bdd89e6c9c055)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"However, the InterMineR (https://github.com/intermine/intermineR)\\npackage automates some of these features and makes it easier to load the\\ndata in R.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Installation\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One way to install InterMineR is to install from github with\\nhadley/devtools\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"install.packages(\\\"devtools\\\")\\ndevtools::install_github(\\\"hadley/devtools\\\")\\ndevtools::install_github(\\\"intermine/intermineR\\\")\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Usage\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Basic usage includes loading theÂ \\\"intermine URL\\\" using the initInterMine\\nfunction. Then various functions can be called on this result.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"library(InterMineR)\\nmine=initInterMine(\\\"http://bovinegenome.org/bovinemine/\\\")\\ngetVersion(mine) #18, intermine API version\\ngetRelease(mine) #1.0, our data release version\\ngetTemplates(mine) # lists all templates on interminer\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Run a template query\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"From the getTemplates function, if you see a template query that you\\nwant to run, you can use the getTemplateQuery function with it's name,\\nand run it with the runQuery function\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"getTemplateQuery(mine,\\\"TQ_protein_to_gene\\\") # see what template looks like\\ntemplate=getTemplateQuery(mine,\\\"TQ_protein_to_gene\\\") # save template\\nrunQuery(mine,template) # run the template query with default params, receive data.frame\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This method is good, but some improvement could be added to change\\ndefault parameters in the template query, etc.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Run query XML\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another option for running queries is to use the query XML that you can\\ndownload from the InterMine query result pages.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \" # get all Ensembl genes on chr28 from bovinemine\\n query='<query model=\\\"genomic\\\" view=\\\"Gene.primaryIdentifier\\n Gene.secondaryIdentifier Gene.symbol Gene.name Gene.source\\n Gene.organism.shortName Gene.chromosome.primaryIdentifier\\\"\\n sortOrder=\\\"Gene.primaryIdentifier ASC\\\" ><constraint\\n path=\\\"Gene.organism.shortName\\\" op=\\\"=\\\" value=\\\"B. taurus\\\"\\n /><constraint path=\\\"Gene.chromosome.primaryIdentifier\\\" op=\\\"=\\\"\\n value=\\\"GK000028.2\\\" /></query>'\\n\\n results=runQuery(mine, query)\\n\\n head(results)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Conclusion\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The InterMineR package has a couple of nice features for getting\\nInterMine data with a couple of functions for looking at templates. For\\nmany use cases, copying the Query XML from a InterMine webpage and\\npasting that into the runQuery function is sufficient and produces a\\ndata frame that can be analyzed.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PS it is not easy to post XML on tumblr after editing the post in\\nmarkdown mode. You have to add the lt and gt shortcuts and even after\\nthat it gets filtered?!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}