{"pageProps":{"post":{"title":"Plotting a coordinate on the screen","date":"2017-02-16","slug":"2017-02-16","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      pre: \"pre\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"I always end up having to remember the math for plotting a coordinate on the\\nscreen, for example an HTML5 canvas and end up stitching it together manually\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you step through the math it becomes very simple though\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Say you have a coordinate range of 1000 to 2000 that you want to plot in a\\nHTML5 canvas of size 100px\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Let's do a quick example and then generalize. Let's say you want to plot the\\nvalue 1500, and put it into screen coordinates, so you take that and subtract\\nthe minimum of the range\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"1500-1000\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Second, you know your point is going to be halfway in the range, and in\\ngeneral, to get this position, you divide now by the size of the interval you\\nare plotting in, e.g. 2000-1000\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"(1500-1000)/(2000-1000) = 0.5\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We get 0.5 as expected. Then you multiply this proportion times the width of\\nbox you are rendering in, e.g. 100 pixels wide, and get that you put your pixel\\nat position 50px\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"To summarize, the general formula for plotting a point x in a range (x1,x2) on\\na screen of width w is\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"w*(x -  x1) / (x2 - x1)\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Of course same thing applies for y\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"h*(y - y1) / (y2 - y1)\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This does not take into account small possible adjustments for closed vs open\\nranges, which could be important to avoid subpixel rendering on a canvas, but\\nthat can be a further exercise\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}