{"pageProps":{"post":{"title":"Handling async errors with React (or, remember that props can change)","date":"2022-10-10","slug":"2022-10-10-reentry-react","html":"<p>If you make a React component that has, say, a prop for a item id, and an async\naction in a useEffect to fetch data for that item from an API, then you will\nlikely implement error handling on it most likely. That error handling may be a\nuseState.</p>\n<p><strong>The key to remember that the props of your component can change, and you then\nhave to reset all the state related to your old props</strong></p>\n<p>Working codesandbox</p>\n<p><a href=\"https://codesandbox.io/s/practical-rubin-l2d5el?file=/src/App.tsx:0-2003\">https://codesandbox.io/s/practical-rubin-l2d5el?file=/src/App.tsx:0-2003</a></p>\n<div class=\"highlight highlight-text-xml\"><pre>import { useState, useEffect } from 'react'\n\ninterface PokemonType {\n  type: {\n    name: string\n  }\n}\ninterface PokemonInfo {\n  name: string\n  types: PokemonType\n}\n\n// util fetch function to throw if !response.ok, I use this util often\nasync function myfetch(url: string, opts?: RequestInit) {\n  const response = await fetch(url, opts)\n  if (!response.ok) {\n    throw new Error(\n      `Error fetching ${url}: HTTP ${response.status} ${await response.text()}`,\n    )\n  }\n  return response.json()\n}\n\nfunction ErrorMessage({ error }: { error: unknown }) {\n  return &#x3C;<span class=\"pl-ent\">div</span> <span class=\"pl-e\">style</span>={{ background: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>red<span class=\"pl-pds\">'</span></span> }}>{`${error}`}&#x3C;/<span class=\"pl-ent\">div</span>>\n}\n\nfunction PokemonCard({ pokemonName }: { pokemonName: string }) {\n  const [error, setError] = useState&#x3C;<span class=\"pl-ent\">unknown</span>>()\n  const [pokemonInfo, setItemInfo] = useState&#x3C;<span class=\"pl-ent\">PokemonInfo</span>>()\n  useEffect(() => {\n    let cancelled = false\n    ;(async () => {\n      try {\n        // important to reset the error and item state of the app\n        setError(undefined)\n        setItemInfo(undefined)\n\n        const data = await myfetch(\n          `https://pokeapi.co/api/v2/pokemon/${pokemonName}`,\n        )\n        if (!cancelled) {\n          setItemInfo(data)\n        }\n      } catch (e) {\n        console.error(e)\n        if (!cancelled) {\n          setError(e)\n        }\n      }\n    })()\n\n    return () => {\n      cancelled = true\n    }\n  }, [pokemonName])\n\n  return (\n    &#x3C;<span class=\"pl-ent\">div</span>>\n      {error ? (\n        &#x3C;<span class=\"pl-ent\">ErrorMessage</span> <span class=\"pl-e\">error</span>={error} />\n      ) : pokemonInfo ? (\n        &#x3C;<span class=\"pl-ent\">div</span>>\n          {pokemonInfo.name} is of type{' '}\n          {pokemonInfo.types.map(t => t.type.name).join(', ')}\n        &#x3C;/<span class=\"pl-ent\">div</span>>\n      ) : (\n        &#x3C;<span class=\"pl-ent\">div</span>>Loading...&#x3C;/<span class=\"pl-ent\">div</span>>\n      )}\n    &#x3C;/<span class=\"pl-ent\">div</span>>\n  )\n}\n\nexport default function App() {\n  const [value, setValue] = useState('oddish')\n  return (\n    &#x3C;<span class=\"pl-ent\">div</span> <span class=\"pl-e\">className</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>App<span class=\"pl-pds\">\"</span></span>>\n      &#x3C;<span class=\"pl-ent\">label</span> <span class=\"pl-e\">htmlFor</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>pokemon_name<span class=\"pl-pds\">\"</span></span>>Pokemon name&#x3C;/<span class=\"pl-ent\">label</span>>\n      &#x3C;<span class=\"pl-ent\">input</span>\n        <span class=\"pl-e\">id</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>pokemon_name<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-e\">type</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>text<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-e\">value</span>={value}\n        <span class=\"pl-e\">onChange</span>={e => setValue(e.target.value)}\n      />\n      &#x3C;<span class=\"pl-ent\">PokemonCard</span> <span class=\"pl-e\">pokemonName</span>={value} />\n    &#x3C;/<span class=\"pl-ent\">div</span>>\n  )\n}\n</pre></div>\n<p>Can we make a hook to make this easier? Hooks are claimed to allow lots of\nre-usable code but the amount of instances I actually take advantage of this\nare low. This does not drastically affect our approach, but the handling is not\ncontained. We can call <code>usePokemonInfo(pokemonName)</code> and error handling and\nfetching is handled for us</p>\n<div class=\"highlight highlight-text-xml\"><pre>import { useState, useEffect } from 'react'\n\ninterface PokemonType {\n  type: {\n    name: string\n  }\n}\ninterface PokemonInfo {\n  name: string\n  types: PokemonType\n}\n\n// util fetch function to throw if !response.ok, I use this util often\nasync function myfetch(url: string, opts?: RequestInit) {\n  const response = await fetch(url, opts)\n  if (!response.ok) {\n    throw new Error(\n      `Error fetching ${url}: HTTP ${response.status} ${await response.text()}`,\n    )\n  }\n  return response.json()\n}\n\nfunction usePokemonInfo(pokemonName: string) {\n  const [error, setError] = useState&#x3C;<span class=\"pl-ent\">unknown</span>>()\n  const [pokemonInfo, setItemInfo] = useState&#x3C;<span class=\"pl-ent\">PokemonInfo</span>>()\n  useEffect(() => {\n    let cancelled = false\n    ;(async () => {\n      try {\n        setItemInfo(undefined) // &#x3C;<span class=\"pl-ent\">--</span> important to reset the state of the app\n        setError(undefined) // &#x3C;-- important to reset the state of the app\n        const data = await myfetch(\n          `https://pokeapi.co/api/v2/pokemon/${pokemonName}`,\n        )\n        if (!cancelled) {\n          setItemInfo(data)\n        }\n      } catch (e) {\n        console.error(e)\n        if (!cancelled) {\n          setError(e)\n        }\n      }\n    })()\n\n    return () => {\n      cancelled = true\n    }\n  }, [pokemonName])\n\n  return [error, pokemonInfo]\n}\n\nfunction ErrorMessage({ error }: { error: unknown }) {\n  return &#x3C;<span class=\"pl-ent\">div</span> <span class=\"pl-e\">style</span>={{ background: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>red<span class=\"pl-pds\">'</span></span> }}>{`${error}`}&#x3C;/<span class=\"pl-ent\">div</span>>\n}\n\nfunction PokemonCard({ pokemonName }: { pokemonName: string }) {\n  const [error, pokemonInfo] = usePokemonInfo(pokemonName)\n\n  return (\n    &#x3C;<span class=\"pl-ent\">div</span>>\n      {error ? (\n        &#x3C;<span class=\"pl-ent\">ErrorMessage</span> <span class=\"pl-e\">error</span>={error} />\n      ) : pokemonInfo ? (\n        &#x3C;<span class=\"pl-ent\">div</span>>\n          {pokemonInfo.name} is of type{' '}\n          {pokemonInfo.types.map(t => t.type.name).join(', ')}\n        &#x3C;/<span class=\"pl-ent\">div</span>>\n      ) : (\n        &#x3C;<span class=\"pl-ent\">div</span>>Loading...&#x3C;/<span class=\"pl-ent\">div</span>>\n      )}\n    &#x3C;/<span class=\"pl-ent\">div</span>>\n  )\n}\n\nexport default function App() {\n  const [value, setValue] = useState('oddish')\n  return (\n    &#x3C;<span class=\"pl-ent\">div</span> <span class=\"pl-e\">className</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>App<span class=\"pl-pds\">\"</span></span>>\n      &#x3C;<span class=\"pl-ent\">label</span> <span class=\"pl-e\">htmlFor</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>pokemon_name<span class=\"pl-pds\">\"</span></span>>Pokemon name&#x3C;/<span class=\"pl-ent\">label</span>>\n      &#x3C;<span class=\"pl-ent\">input</span>\n        <span class=\"pl-e\">id</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>pokemon_name<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-e\">type</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>text<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-e\">value</span>={value}\n        <span class=\"pl-e\">onChange</span>={e => setValue(e.target.value)}\n      />\n      &#x3C;<span class=\"pl-ent\">PokemonCard</span> <span class=\"pl-e\">pokemonName</span>={value} />\n    &#x3C;/<span class=\"pl-ent\">div</span>>\n  )\n}\n</pre></div>\n<h2 id=\"conclusion\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#conclusion\"><a href=\"#conclusion\" style=\"margin-right: 10px\">#</a></a>Conclusion</h2>\n<p>I think it's sometimes common to forget error handling in async JS code\n(useEffect async or many other contexts, etc), and it's not linted well wither,\nleaving errors uncaught. If you don't manually handle the error in the\nuseEffect, your user will literally never see that an error occured. But, the\nflipside to this, is you also have to reset your \"error state\", those are the\nkey lines where I call setError(undefined) and setPokemonInfo(undefined) before\nI fetch a new pokemon from my API.</p>"}},"__N_SSG":true}