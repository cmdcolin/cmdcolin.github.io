{"pageProps":{"post":{"title":"How to make your own npm package with typescript","date":"2021-12-31","slug":"2021-12-31-npm-package","html":"<p>There is a lot of mystery around making your own <code>npm</code> package. Every package\nlikely does it a bit differently, and it can be tricky to get a setup you like.\nShould you use a \"starter kit\" or a boilerplate example? Or just roll your own?\nShould you use a bundler? How do you use typescript?</p>\n<p><strong>*Record scratch **</strong></p>\n<p>Why don't we try starting from scratch and seeing where we can get?</p>\n<p>TLDR: here is a github repo with a template package\n<a href=\"https://github.com/cmdcolin/npm-package-tutorial/\">https://github.com/cmdcolin/npm-package-tutorial/</a></p>\n<h2>Introduction</h2>\n<p>An <code>npm</code> package can be very bare bones. In some sense, npmjs.com is just an\narbitrary file host, and you can upload pretty much anything you want to it.</p>\n<p>The magic is in the package.json file, which tells npm:</p>\n<ul>\n<li>what files are part of your package</li>\n<li>what to use as the \"entry point\" (e.g. the file that should be referenced\nwhen you say <code>const lib = require('mypackage')</code>)</li>\n<li>what pre- and post- processing steps should be done when the package is being\npublished</li>\n<li>and more!</li>\n</ul>\n<p>Let's try an experiment...</p>\n<h2>Initializing a package</h2>\n<p>Open up a terminal, and run</p>\n<pre><code class=\"language-sh\">mkdir mypackage\ncd mypackage\ngit init # make mypackage version controlled\nnpm init\n# or\nyarn init\n</code></pre>\n<p>This init command outputs something like this, and we accept the defaults</p>\n<pre><code class=\"language-sh\">This utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee `npm help init` for definitive documentation on these fields\nand exactly what they do.\n\nUse `npm install &#x3C;pkg>` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\npackage name: (mypackage)\nversion: (1.0.0)\ndescription:\nentry point: (index.js)\ntest command:\ngit repository:\nkeywords:\nlicense: (ISC)\nAbout to write to /home/cdiesh/mypackage/package.json:\n\n{\n  \"name\": \"mypackage\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\"\n}\n\n</code></pre>\n<p>Then, you can create a file named <code>index.js</code> (in your package.json it says\n<code>\"main\": \"index.js\"</code> to refer to this file, the entrypoint)</p>\n<p>In your <code>index.js</code> file, generally, you would do things like export a function\nor functions. I will use commonjs exports here for maximum compatibility:</p>\n<pre><code class=\"language-js\">module.exports = {\n  hello: () => {\n    console.log('hello world')\n  },\n}\n</code></pre>\n<h2>Publishing a package</h2>\n<p>This npm package, <code>mypackage</code> can now be published to <code>npm</code> with a simple\ncommand.</p>\n<pre><code class=\"language-sh\">npm publish\n# or\nyarn publish\n</code></pre>\n<p>This will prompt you for your npmjs.com username, password, email, and if\nneeded, 2FA token (highly recommended)</p>\n<h2>Using your package after it is published</h2>\n<p>Once it is published, you can use it in your create-react-app app or other npm\npackage.</p>\n<pre><code class=\"language-sh\">npm install mypackage\n# or\nyarn add mypackage\n</code></pre>\n<p>Then you can use</p>\n<pre><code class=\"language-js\">import { hello } from 'mypackage'\n</code></pre>\n<p>in any of your other codebases</p>\n<h2>Summary of the simplest NPM package</h2>\n<p>This all seems pretty boring thus far but it tells us a couple things</p>\n<ol>\n<li>packages can be very very bare bones</li>\n<li>no transpiler or bundler is needed for publishing an npm package</li>\n<li>our package can consist of a single file and it is uploaded to npm, and the\n\"main\" field in package.json provides an entry point</li>\n<li>the filename index.js is not special, probably it is a hangover from the\nname index.html. you can use whatever name you want</li>\n</ol>\n<h2>Adding typescript</h2>\n<p>Let's try adding typescript</p>\n<p>To do this, we will use the typescript compiler to compile a directory of files\nin our \"src\" directory and output the compiled files to a directory named\n\"dist\"</p>\n<p>To start, let's add typescript</p>\n<pre><code class=\"language-sh\">npm install --save-dev typescript\n# or\nyarn add -D typescript\n</code></pre>\n<p>Our package.json now will have <code>typescript</code> in it's <code>devDependencies</code> (this\nmeans that when someone installs your package, it they don't get typescript as\na dependency, it is just a dependency for while you are developing the library\nlocally).</p>\n<p>Then we need to create a tsconfig.json for typescript to use</p>\n<pre><code class=\"language-sh\">yarn tsc --init\n# or\nnpx tsc --init\n</code></pre>\n<p>This will generate a <code>tsconfig.json</code> file (needed by <code>typescript</code>) with a bunch of\noptions, but I have stripped it down in my projects to look like this</p>\n<pre><code class=\"language-json\">{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"moduleResolution\": \"node\",\n    \"declaration\": true, // generate .d.ts files\n    \"sourceMap\": true, // generate source map\n    \"outDir\": \"dist\", // output compiled js, d.ts, and source map to dist folder\n    \"strict\": true,\n    \"esModuleInterop\": true\n  }\n}\n</code></pre>\n<p>Now, we want to change our <code>js</code> to <code>ts</code> files to use <code>typescript</code>, let's change them\nto use normal ESM import/exports</p>\n<p>util.ts</p>\n<pre><code class=\"language-typescript\">export function getMessage() {\n  return 'hello'\n}\n</code></pre>\n<p>index.ts</p>\n<pre><code class=\"language-typescript\">import { getMessage } from './util'\nexport function sayMessage() {\n  console.log(getMessage())\n}\n</code></pre>\n<p>And then we will add a <code>\"build\"</code> script to <code>package.json</code> to compile the\nlibrary, and refer to the <code>\"dist\"</code> directory for the <code>\"files\"</code> and <code>\"main\"</code>\nfields in <code>package.json</code></p>\n<pre><code class=\"language-json\">{\n  \"name\": \"mypackage\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"src/index.js\",\n  \"files\": [\"dist\"],\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"author\": \"Colin\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"typescript\": \"^4.5.4\"\n  }\n}\n</code></pre>\n<p>We can now run</p>\n<pre><code class=\"language-sh\">npm run build\n# or\nyarn build\n</code></pre>\n<p>And this will run the <code>\"build\"</code> script we created, which in turn, just runs\n<code>tsc</code> with no arguments.</p>\n<p>You can also add a <code>\"prebuild\"</code> script that clears out the old contents. In fact,\nnpm scripts generalizes the naming system -- you can make scripts with whatever name you want, e.g.</p>\n<pre><code class=\"language-json\">{\n  \"scripts\": {\n    \"preparty\": \"echo preparty\",\n    \"party\": \"echo party\",\n    \"postparty\": \"echo postparty\"\n  }\n}\n</code></pre>\n<p>Then running</p>\n<pre><code class=\"language-sh\">$ yarn party\npreparty\nparty\npostparty\n</code></pre>\n<p>To make this useful, we will use <code>rimraf</code> (a node package) to make a\ncross-platform removal of the <code>dist</code> directory</p>\n<pre><code class=\"language-sh\">npm install --save-dev rimraf\n# or\nyarn add -D rimraf\n</code></pre>\n<p>and then update your package.json</p>\n<pre><code class=\"language-json\">{\n  ...\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"prebuild\": \"npm run clean\",\n    \"build\": \"tsc\"\n  },\n  \"devDependencies\": {\n    \"rimraf\": \"^3.0.2\",\n    \"typescript\": \"^4.5.4\"\n  }\n}\n</code></pre>\n<p>We could make it say \"rm -rf dist\" instead of \"rimraf dist\" (e.g. run arbitrary\nshell commands), but rimraf allows it to be cross-platform</p>\n<h2>Making sure you create a fresh build before you publish</h2>\n<p>Without extra instructions, your <code>yarn publish</code> command would not create a\nfresh build and you could publish an older version that was lingering in the\n<code>dist</code> folder.</p>\n<p>We can use a <code>preversion</code> script that will automatically get invoked when you\nrun <code>yarn publish</code> to make sure you get a fresh build in the <code>dist</code> folder\nbefore you publish</p>\n<pre><code class=\"language-json\">{\n  ...\n  \"scripts\": {\n    ...\n    \"preversion\": \"npm run build\",\n  },\n}\n</code></pre>\n<h2>Making sure you push your tag to github after publish</h2>\n<p>When you run <code>yarn publish</code>, npm will automatically create a commit with the\nversion name and a git tag, it <em>will not</em> automatically push tag to your\nrepository.</p>\n<p>Add a <code>postversion</code> script that pushes the tag to your repo after your publish</p>\n<pre><code class=\"language-json\">{\n  ...\n  \"scripts\": {\n    ...\n    \"postversion\": \"git push --follow-tags\",\n  },\n}\n</code></pre>\n<h2>Incremental builds</h2>\n<p>We can use this to do incremental/watch builds</p>\n<pre><code>npm run build --watch\n# or\nyarn build --watch\n</code></pre>\n<h2>Adding testing with ts-jest</h2>\n<p>You can use ts-jest to test your code. This involves installing jest, typescript, ts-jest, @types/jest, and then initializing a jest.config.json</p>\n<pre><code class=\"language-sh\">npm i -D jest typescript\n# or\nyarn add --dev jest typescript\n</code></pre>\n<pre><code class=\"language-sh\">npm i -D ts-jest @types/jest\n# or\nyarn add --dev ts-jest @types/jest\n</code></pre>\n<pre><code class=\"language-sh\">npx ts-jest config:init\n# or\nyarn ts-jest config:init\n</code></pre>\n<p>We can then create a test</p>\n<p><code>test/util.spec.ts</code></p>\n<pre><code class=\"language-typescript\">import { getMessage } from '../src/util'\ntest('expected message returned', () => {\n  expect(getMessage()).toBe('hello')\n})\n</code></pre>\n<p>Then we can then create a script in the package.json that says <code>\"test\": \"jest\"</code>, and then we can say</p>\n<pre><code>npm run test\n# or\nyarn test\n</code></pre>\n<p>You can also create an alternative system where you use <code>babel-eslint</code> and\nvarious babel strategies to test your code, but if you are using typescript,\nts-jest+typescript works great.</p>\n<h2>Add a .gitignore</h2>\n<p>Create a .gitignore with just a line that references this <code>dist</code> folder and <code>node_modules</code> folder</p>\n<pre><code>dist\nnode_modules\n</code></pre>\n<h2>The future of ESM modules</h2>\n<p>There is a shift happening where modules are changing to be pure ESM rather\nthan keeping commonjs equivalents</p>\n<p><a href=\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></p>\n<p>There are many challenges here, and will not be discussed, but it may be a\nuseful further reading page</p>\n<h2>Conclusion</h2>\n<p>This tutorial shows you how you can create a basic package that you can publish\nto <code>npm</code>. This little boilerplate includes these features:</p>\n<ul>\n<li>Makes clean build when running <code>yarn build</code> or <code>yarn publish</code></li>\n<li>Pushes to github after publish</li>\n<li>Uses ts-jest for testing</li>\n<li>Uses esm modules</li>\n</ul>\n<p>You also have full control, and understand the decisions we took to get to this\npoint. This package does not use any bundling (rollup or webpack or otherwise).\nIt just uses <code>tsc</code> is used to compile the files to the <code>dist</code> folder, and the\ndist folder is published to <code>npm</code>! If you need your package to be usable by\nconsumers that don't themselves use bundlers, consider looking into <code>&#x3C;script type=\"module\"></code> for importing ESM modules in the browser, or you can bundle\nyour library using rollup or webpack and output e.g. a UMD bundle</p>\n<h2>Final product</h2>\n<p>See <a href=\"https://github.com/cmdcolin/npm-package-tutorial/\">https://github.com/cmdcolin/npm-package-tutorial/</a></p>"}},"__N_SSG":true}