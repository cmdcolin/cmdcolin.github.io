{"pageProps":{"post":{"title":"Using Rust/WASM in a monorepo with create-react-app","date":"2022-08-22","slug":"2022-08-22-rustwasm","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Behold, the buzzwords:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Rust / WASM / wasm-bindgen\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"React\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Monorepo / Yarn workspaces\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Webpack 5 / create-react-app 5\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Typescript\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TLDR: https://github.com/cmdcolin/rust_react_monorepo_template\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main goal though? To use Rust + WASM in a react app, inside a monorepo.\\nHere is a template you can use to set this up\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Basic steps\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Create repo\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"mkdir template\\ncd template\\ngit init\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Create root package.json\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then put this in the monorepo's root package.json,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"private\\\": true,\\n  \\\"workspaces\\\": [\\\"hello-wasm\\\", \\\"app\\\"]\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This sets our repo up as a \\\"monorepo\\\" with two \\\"workspaces\\\". one will be the wasm code, in \\\"hello-wasm\\\", one will be an instance of create-react-app\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Create a create-react-app instance inside the monorepo\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"npx create-react-app --template typescript app\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is app will exist as a subfolder inside our monorepo\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Download the hello world rust \", _jsx(_components.code, {\n        children: \"wasm-bindgen\"\n      }), \" example\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Download https://github.com/rustwasm/wasm-bindgen/tree/main/examples/hello_world to the hello-wasm folder\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This link will help https://download-directory.github.io/?url=https%3A%2F%2Fgithub.com%2Frustwasm%2Fwasm-bindgen%2Ftree%2Fmain%2Fexamples%2Fhello_world\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Add some extra fields to the wasm-bindgen's package.json\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"name\\\": \\\"hello-wasm\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"files\\\": [\\\"pkg\\\"],\\n  \\\"main\\\": \\\"pkg/index.js\\\"\\n  ... rest\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Add the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" package to the app's dependencies\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Add \", _jsx(_components.code, {\n        children: \"\\\"hello-wasm\\\":\\\"^1.0.0\\\"\"\n      }), \" to the \", _jsx(_components.code, {\n        children: \"dependencies\"\n      }), \" array in \", _jsx(_components.code, {\n        children: \"app/package.json\"\n      }), \". This\\nwill refer to our local monorepo's rust wasm package!\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Build the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" pkg\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Go into the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder and run \", _jsx(_components.code, {\n        children: \"yarn build\"\n      }), \". This creates a directory\\nnamed \", _jsx(_components.code, {\n        children: \"pkg\"\n      }), \" which has \", _jsx(_components.code, {\n        children: \".wasm\"\n      }), \" files and \", _jsx(_components.code, {\n        children: \".js\"\n      }), \" files. Now, the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \"\\nfolder is effectively a node package. We could publish this to \", _jsx(_components.code, {\n        children: \"NPM\"\n      }), \" (see\\nfootnote 1)\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Create craco config for \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As of writing, you have to customize the \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" to add extra webpack flags.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, \", _jsx(_components.code, {\n        children: \"yarn add @craco/craco\"\n      }), \" in the app folder, then create this \", _jsx(_components.code, {\n        children: \"craco.config.js\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"const path = require(\\\"path\\\");\\nconst webpack = require(\\\"webpack\\\");\\n\\nmodule.exports = {\\n  webpack: {\\n    configure: (config) => {\\n      const wasmExtensionRegExp = /\\\\.wasm$/;\\n      config.resolve.extensions.push(\\\".wasm\\\");\\n      config.experiments = {\\n        syncWebAssembly: true,\\n      };\\n\\n      config.module.rules.forEach((rule) => {\\n        (rule.oneOf || []).forEach((oneOf) => {\\n          if (oneOf.type === \\\"asset/resource\\\") {\\n            oneOf.exclude.push(wasmExtensionRegExp);\\n          }\\n        });\\n      });\\n\\n      return config;\\n    },\\n  },\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note: this thread helped me to create the craco config\\n\", _jsx(_components.a, {\n        href: \"https://github.com/Emurgo/cardano-serialization-lib/issues/295\",\n        children: \"https://github.com/Emurgo/cardano-serialization-lib/issues/295\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Modify the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" example to return a value instead of making an alert\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I changed the rust code to return a String value instead of making the alert\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"#[wasm_bindgen]\\npub fn greet(name: &str) -> String {\\n    format!(\\\"Hello {}\\\", name)\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Final step: Use async \", _jsx(_components.code, {\n        children: \"import()\"\n      }), \" to import the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" greeting\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We use a \", _jsx(_components.code, {\n        children: \"useEffect\"\n      }), \" hook to import the code asynchronously, and can call our\\nrust function, \", _jsx(_components.code, {\n        children: \"greet\"\n      }), \", from javascript!\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"function App() {\\n  const [greeting, setGreeting] = useState<string>();\\n  useEffect(() => {\\n    (async () => {\\n      try {\\n        const wasm = await import(\\\"hello-wasm\\\");\\n        const greeting = wasm.greet(\\\"Colin\\\");\\n        setGreeting(greeting);\\n      } catch (e) {\\n        console.error(e);\\n      }\\n    })();\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h1>rust monorepo wasm demo</h1>\\n      <h2>Greeting from wasm: {!greeting ? \\\"Loading...\\\" : greeting}</h2>\\n    </div>\\n  );\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Run the create-react-app\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Go into the \", _jsx(_components.code, {\n        children: \"app\"\n      }), \" folder, and then run \", _jsx(_components.code, {\n        children: \"yarn start\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Result!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/media/rust_wasm_demo.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"My main aim was to demonstrate with a \\\"simple\\\" monorepo setup how you can\\nintegrate Rust+WASM and React\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Other resources\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This article is quite helpful also, but uses a file:/ reference in their\\npackage.json while this article uses a monorepo, it is fundamentally quite\\nsimilar though!\\nhttps://tkat0.github.io/posts/how-to-create-a-react-app-with-rust-and-wasm\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"Footnote 1: The \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder IS a npm package with wasm files\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder can be published to NPM by itself. When consumers of\\nthe package import the module, they would receive \", _jsx(_components.code, {\n        children: \"pkg/index.js\"\n      }), \" from the\\n\", _jsx(_components.code, {\n        children: \"main\"\n      }), \" field in \", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \", and then \", _jsx(_components.code, {\n        children: \"pkg/index.js\"\n      }), \" in turn imports the\\n\", _jsx(_components.code, {\n        children: \"index.wasm\"\n      }), \" file. Then it is up to the consumers bundler to package that\\ncorrectly.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 2: Bundlers and wasm\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As of writing, I am using \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" v5 (part of \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" v5), which has\\n\\\"native support\\\" for wasm. Still, it is hidden behind a flag called\\n\\\"experiments\\\" (see first google result for webpack wasm here\\n\", _jsx(_components.a, {\n        href: \"https://webpack.js.org/configuration/experiments/\",\n        children: \"https://webpack.js.org/configuration/experiments/\"\n      }), \")\\nso I use \", _jsx(_components.code, {\n        children: \"@craco/craco\"\n      }), \" to modify the \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" config of \", _jsx(_components.code, {\n        children: \"create-react-app\"\n      }), \" v5 to\\nadd this.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note also: The first time I wrote this, I used \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" v4, which used a\\nslightly different workflow (used a special \", _jsx(_components.code, {\n        children: \"webpack\"\n      }), \" loader called\\n\", _jsx(_components.code, {\n        children: \"wasm-loader\"\n      }), \")\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 3: Why do I have to use async imports?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Fundamentally, the \", _jsx(_components.code, {\n        children: \".wasm\"\n      }), \" file has to be fetched asynchronously before it can\\nbe run (it is not in my experience e.g. embedded as binary data inside a js\\nfile) which means it would be difficult to use the wasm code as a synchronous\\nimport.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are hints that this may be possible but it would rely on the bundler\\nembedding the wasm code in the js itself, or maybe top level imports or\\nsomething(???) If anyone has more info, feel free to leave a comment\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Footnote 4: Build setup\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" package does not automatically recompile when we are running\\ne.g. \", _jsx(_components.code, {\n        children: \"yarn start\"\n      }), \" in the \", _jsx(_components.code, {\n        children: \"app\"\n      }), \" folder. Therefore, changes to the rust requires\\nyou to manually run \", _jsx(_components.code, {\n        children: \"yarn build\"\n      }), \" in the \", _jsx(_components.code, {\n        children: \"hello-wasm\"\n      }), \" folder. Just something to\\nbe aware of\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}