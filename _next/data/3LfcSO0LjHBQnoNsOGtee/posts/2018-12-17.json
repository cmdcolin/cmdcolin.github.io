{"pageProps":{"post":{"title":"Behind the release - the story of the bugs and features in JBrowse 1.16.0","date":"2018-12-17","slug":"2018-12-17","mdxSource":{"compiledSource":"var u=Object.defineProperty,p=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(e,t,a)=>t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,i=(e,t)=>{for(var a in t||(t={}))n.call(t,a)&&l(e,a,t[a]);if(s)for(var a of s(t))r.call(t,a)&&l(e,a,t[a]);return e},d=(e,t)=>p(e,c(t));var h=(e,t)=>{var a={};for(var o in e)n.call(e,o)&&t.indexOf(o)<0&&(a[o]=e[o]);if(e!=null&&s)for(var o of s(e))t.indexOf(o)<0&&r.call(e,o)&&(a[o]=e[o]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var o=a,{components:e}=o,t=h(o,[\"components\"]);return mdx(MDXLayout,d(i(i({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Every once in awhile, you might see that your favorite program, JBrowse,\\xA0 has a\nnew release. There are a ton of little snippets in the release notes, you might\nas well just go ahead and upgrade, but what went into all those little fixes?\nGoing to the blog post has links to the github\nissues,\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"http://jbrowse.org/blog/2018/12/13/jbrowse-1-16-0.html\"}),\"http://jbrowse.org/blog/2018/12/13/jbrowse-1-16-0.html\"),`\\xA0but I felt\nlike maybe I'd add a little more context for some of them:`),mdx(\"p\",null,`PS This is sort of motivated by @zcbenz blog on Electron\n(`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://twitter.com/zcbenz\"}),\"https://twitter.com/zcbenz\"),\"\\xA0\",mdx(\"a\",i({parentName:\"p\"},{href:\"http://cheng.guru/\"}),\"http://cheng.guru/\"),`) which tells the software in\nterms of actual commit messages and such.`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},`The webpack build doing a production build by default. This seems pretty\nstraightforward, but was also difficult because I use WSL and the UglifyJs\nplugin had trouble on WSL using the parallel: 4 option to use multiple\nprocessors. This was really annoying and resulted in the webpack build just\nhanging for no reason and only careful google-fu really uncovered other\npeople having this issue. I removed the parallelism as the speed gain wasn't\neven really justifiable\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/gmod/jbrowse/pull/1223\"}),\"https://github.com/gmod/jbrowse/pull/1223\"))),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"The incorporation of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/bam\"),` module. This was an almost 2 months\nprocess after my first module, `,mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/indexedfasta\"),`. It required really\ngetting down to the binary level for BAM and was pretty tough. The module\nhas already itself had 12 releases `,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/GMOD/bam-js/blob/master/CHANGELOG.md\"}),\"here\")))),mdx(\"p\",null,`-\\xA0Added support for indexing arbitrary fields from GFF3Tabix files. This was\nfairly straightforward but required making design decisions about this.\nPreviously flatfile-to-json.pl files would have a command line flag to index\narbitrary fields. Since gff3tabix files are specified via config, I allowed\nspecifying arbitrary fields via config.`),mdx(\"p\",null,`-\\xA0Added ability to render non-coding transcript types to the default Gene\nglyph. This one was a nice feature and enables you to see non-coding types, but\nrequired some weird design decisions because I could not override\nthe\\xA0`,mdx(\"inlineCode\",{parentName:\"p\"},\"box->style->color\"),` from a higher level type simply using the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"_defaultConfig\"),\" function, so I needed to override the \",mdx(\"inlineCode\",{parentName:\"p\"},\"getStyle\"),` callback\nthat was passed down to the lower levels, so that it was able to use the\ndefault lower level style and also our non-coding transcript style. See this\npart of the code for\ndetails\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/GMOD/jbrowse/commit/ec638ea1cc62c8727#diff-a14e88322d8f4e8e940f995417277878R22\"}),\"https://github.com/GMOD/jbrowse/commit/ec638ea1cc62c8727#diff-a14e88322d8f4e8e940f995417277878R22\")),mdx(\"p\",null,\"-\\xA0Added \",mdx(\"inlineCode\",{parentName:\"p\"},\"hideImproperPairs\"),` filter. This was fairly straightforward but it is one\nof these bugs that went unnoticed for years...the `,mdx(\"inlineCode\",{parentName:\"p\"},\"hideMissingMatepairs\"),` flag\nwould hide things didn't have the sam 0x02 flag for \"read mapped in proper\npair\", but reads with this flag could still be paired. Doing the 1.16 release\nthat focused on paired reads helped focus on this issue and now\nhideMissingMatepairs filters on \"mate unmapped\" and `,mdx(\"inlineCode\",{parentName:\"p\"},\"hideImproperPairs\"),` is\nthe\\xA0\"read mapped in proper pair\"`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Added \",mdx(\"inlineCode\",{parentName:\"li\"},\"useTS\"),` flag. This one is fairly straightforward, it is similar to\n`,mdx(\"inlineCode\",{parentName:\"li\"},\"useXS\"),` which colors reads based on their alignment in canonical splice site\norientations. I figured I could just copy the `,mdx(\"inlineCode\",{parentName:\"li\"},\"useXS\"),\" to the \",mdx(\"inlineCode\",{parentName:\"li\"},\"useTS\"),` since I\nfigured they are the same, but I went ahead and manually generated RNA-seq\nalignments with minimap2 and found that the useTS is actually flipped the\nopposite of `,mdx(\"inlineCode\",{parentName:\"li\"},\"useXS\"),\", so it was valuable to get actual test data here.\")),mdx(\"p\",null,\"-\\xA0Fixed issue where some \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-names\"),` setups would fail to index features.\nThis was a bad bug that was brought to light by a user. I was kind of mind\nboggled when I saw it. In JBrowse 1.13-JBrowse 1.15 a change was introduced to\nname indexing with a memory leak. In JBrowse 1.15 that was removed. But, there\nwas another change where refseqs could return empty name records, because they\nwere handled separately. But if the initial fill up of the name buffer of 50000\nwas exceeded by the reference sequence, then there would be empty name records\nafter this point and cause the name indexing to stop. Therefore this bug would\nonly happen when the reference sequence indexing buffer exceeded 50000 items\nwhich could happen even when there are less than 50000 refseqs due to\nautocompletions`),mdx(\"p\",null,`-\\xA0 Fixed issue with getting feature density from BAM files via the index stats\nestimation. This involved parsing the\\xA0\"dummy bin\" from index files, and I found\nit was failing on certain 1000 genomes files. I actually don't really know what\nthe story behind this was, but our tabix code was better at parsing the dummy\nbins than my bam code, and it was the same concept, so I took a note from their\ncodebase to use it in bam-js code. Commit\nhere\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/GMOD/bam-js/commit/d5796dfc8750378ac8b875615ae0a7e81371af76\"}),\"https://github.com/GMOD/bam-js/commit/d5796dfc8750378ac8b875615ae0a7e81371af76\")),mdx(\"p\",null,`-\\xA0 Fixed issue with some GFF3Tabix tracks having some inconsistent layout of\nfeatures. This is a persistently annoying fact in tabix files where we cannot\nreally get a unique ID of a feature based on it's file offset. Therefore this\ntakes the full crc32 of a line as it's unique ID.`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`Fixed CRAM store not renaming reference sequences in the same way as other\nstores. This one was interesting because rbuels made a fix but it caused\nfeatures from one chromosome to show up on the wrong ones, so chr1 reads\nwhere showing up on chrMT. This happened because it was falling back to the\nrefseq index if it chrMT wasn't in the embedded \"sam header\" in the CRAM\nfile, but it should only fallback to refseq index if there is not any\nembedded\\xA0\"sam header\" in the CRAM file.`)),mdx(\"p\",null,`-\\xA0 Fixed bug where older browsers e.g. IE11 were not being properly supported\nvia babel. This was a absolutely terrible bug that I found over thanksgiving\nbreak. It was a regression from 1.15 branch of JBrowse. Previous versions from\n1.13 when webpack was up until 1.15 used `,mdx(\"inlineCode\",{parentName:\"p\"},\"@babel/env\"),`. It was changed to\nbabel-preset-2015 but it was not being run correctly. Then I found that even if\nI did get it running correctly, it was unable to properly babel-ify the\nlru-cache module because it used something called\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"Object.defineProperty('length', ...)\"),` to change how the length property was\nintepreted which was illegal in IE11. The 'util.promisify' NPM module also did\nthis in some contexts. I found that I could use the quick-lru module and the\nes6-promisify module instead of lru-cache and util.promisify as a workaround.\nThen I had to update all `,mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/tabix\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/vcf\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/bgzf-filehandle\"),`,\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/indexedfasta\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/tribble-index\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"@gmod/bam\"),`, and JBrowse proper to\nuse these modules instead, and make the bable chain, which typically does not\nparse node_modules, to build these modules specifically (I didn't want to setup\nbabel toolchains for every single one of these modules, just one in the jbrowse\nmain codebase...). This was really a lot of work to support IE11 but now that\nworks so ...ya`),mdx(\"p\",null,`-\\xA0 Fixed bug where some files were not being fetched properly when changing\nrefseqs. This was actually fixed when I changed out lru-cache for quick-lru and\nfixed a bug where the cache size was set to 0 due to a erroneous comment that\nsaid\\xA0`,mdx(\"inlineCode\",{parentName:\"p\"},\"50*1024 // 50MB\"),\"...of course it should have said\\xA0\",mdx(\"inlineCode\",{parentName:\"p\"},\"50*1024*1024 // 50MB\"),\"\\xA0\",mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/GMOD/jbrowse/commit/2025dc0aa0091b70\"}),\"https://github.com/GMOD/jbrowse/commit/2025dc0aa0091b70\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},`Fixed issue where JBrowse would load the wrong area of the refseq on startup\nresulting in bad layouts and excessive data fetches. This was actually a\nheinous bug where jbrowse upon loading would just navigateTo the start of the\nreference sequence automatically and then to wherever was specified by the\nuser. This resulted in track data to start downloading immediately from the\nstart of the chromosome and resulted in for example 350 kilobases of\nreference sequence from all tracks to start downloading, which when I was\nimplementing view as pairs, was causing me to download over 100MB routinely.\nThis was terrible, and after fixing I only download about 10MB over even\nlarge regions for most BAM files. Additionally, this bug was causing the\ntrack heights to be calculated incorrectly because the track heights would\nactually be calculated based on distorted canvas\nbitmaps.\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/gmod/jbrowse/issues/1187\"}),\"https://github.com/gmod/jbrowse/issues/1187\"))),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},`JBrowse Desktop was not fetching remote files. This was a weird issue where\nremote file requests were considered a CORS requests to any external remote.\nThis was solved by changing the usage of the fetch API in JBrowse for\nnode-fetch which does not obey CORS. Note that electron-fetch was also\nconsidered, which uses Chromiums network stack instead of node's, but that\nhad specific assumptions about the context in which it was called.`))),mdx(\"p\",null,`-\\xA0 Fixed issue where some parts of a CRAM file would not be displayed in\nJBrowse due to a CRAM index parsing issue. This was based on a sort of binary\nsearch that was implemented in JBrowse where the elements of the lists were\nnon-overlapping regions, and the query was a region, and the output should be a\nlist of the non-overlapping regions that overlap the query. Most algorithms for\nbinary search don't really tell you how to do searches on ranges so needed to\nroll up my sleeves and write a little custom code. An interval tree could have\nbeen used but this is too heavy-weight for non-overlapping regions from the\nindex\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/GMOD/cram-js/pull/10\"}),\"https://github.com/GMOD/cram-js/pull/10\")),mdx(\"p\",null,`-\\xA0 Fixed an issue where BAM features were not lazily evaluating their tags.\nWhen a function `,mdx(\"inlineCode\",{parentName:\"p\"},\"feature.get('blahblah')\"),` is called on a BAM feature, it checks\nto see if it's part of a default list of things that are parsed like feature\nstart, end, id, but if not, it has to parse all the BAM tags to see if it is a\ntag. Since they are called\\xA0\"lazy features\" the tag processing is deferred until\nit is absolutely needed. As it turned out, the incorporation of CRAM in 1.15\nwas calling a function to try to get the CRAM's version of CIGAR/MD on the BAM\nfeatures unnecessarily invoking the tag parsing on every feature up front and\ntherefore making the feature not really lazy anymore. This restored\nthe\\xA0\"lazyness\" aspect of BAM.`),mdx(\"p\",null,`-\\xA0 Fixed issue where CRAM layout and mouseover would be glitchy due to ID\ncollisions on features. In the 1.15 releases, CRAM was introduced, and we\nthought that the concept of taking CRC32 of the entire feature data days were\nover because there is the concept of a\\xA0\"unique ID\" on the features. However,\nthis ID was only unique within the slices, so around the slice boundaries there\nwere a lot of bad feature layouts and mouseovers would fail because they would\nmap to multiple features, etc. I found a way to unique-ify this by giving it\nthe sliceHeader file offset.\\xA0`,mdx(\"a\",i({parentName:\"p\"},{href:\"https://github.com/GMOD/cram-js/pull/10\"}),\"https://github.com/GMOD/cram-js/pull/10\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},`We also had behind the scenes work by igv.js team member jrobinso who helped\non the CRAM codebase to incorporate a feature where for lossy read names, so\nthat a read and it's mate pair would consistently be assigned the same read\nname based on the unique ID mentioned above. There was also a rare issue\nwhere sometimes the mate pair's orientation was incorrectly reported based on\nthe CRAM flags, but the embedded BAM flags correctly reported it.`)),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},`Finally the paired reads feature. This was a feature that I really wanted to\nget right. It started when garrett and rbuels were going to san diego for the\nCIVIC hackathon, and we talked about doing something that matched a\\xA0\"variant\nreview system\" that they had done for the IGV codebase, which involved\ndetailed inspection of reads. I thought it would probably be feasible for\njbrowse to do this, but I thought essentially at some point that enhancing\njbrowse's read visualizations with paired reads would be a big win. I had\nthought about this at the JBrowse hackathon also and my discussions then were\nthat this was very hard. Overall, I invented a compromise that I thought was\nreasonable which was that there can be a\\xA0\"maxInsertSize\" for the pileup view\nbeyond which the pairing wouldn't be resolved. This allowed (a) a significant\nreduction in data fetches because I implemented a\\xA0\"read redispatcher\" that\nwould actually literally resolve the read pairs in the separate chunks and\n(b) a cleaner view because the layout wouldn't be polluted by very long read\ninserts all the time and also, for example, if you scrolled to the right, and\nsuddenly a read was paired to the left side of your view, it would result in\na bad layout (but with max insert size, the window of all reads within\nmaxinsertsize are always resolved so this does not happen) and finally ( c)\nthe paired arc view was incorporated which does not use read redispatching\nand which can do very long reads. All of these things took time to think\nthrough and resolve, but it is now I think a pretty solid system and I look\nforward to user feedback!`))))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true}