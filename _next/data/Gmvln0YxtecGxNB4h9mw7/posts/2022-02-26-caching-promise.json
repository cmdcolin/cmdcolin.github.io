{"pageProps":{"post":{"title":"Caching or memoizing promises","date":"2022-02-26","slug":"2022-02-26-caching-promise","mdxSource":{"compiledSource":"var u=Object.defineProperty,l=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(e,t,o)=>t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,n=(e,t)=>{for(var o in t||(t={}))r.call(t,o)&&c(e,o,t[o]);if(s)for(var o of s(t))i.call(t,o)&&c(e,o,t[o]);return e},p=(e,t)=>l(e,m(t));var h=(e,t)=>{var o={};for(var a in e)r.call(e,a)&&t.indexOf(a)<0&&(o[a]=e[a]);if(e!=null&&s)for(var a of s(e))t.indexOf(a)<0&&i.call(e,a)&&(o[a]=e[a]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var a=o,{components:e}=a,t=h(a,[\"components\"]);return mdx(MDXLayout,p(n(n({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Caching promises in javascript can be somewhat confusing. I think searching for\ninfo about it online is often misguided and results are often very specific to\nsomeones application Here is a method I have used to cache promises, or to\nmemoize an async function. It may not handle all cases, but it helps with some\nscenarios I have seen`),mdx(\"p\",null,\"Example async function: fetch from the pokemon API\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getPokemon() {\n  const id = Math.floor(Math.random() * 150)\n  const url = 'https://pokeapi.co/api/v2/pokemon/' + id\n  const ret = await fetch(url)\n  if (!ret.ok) {\n    throw new Error(\n      \\`Failed to fetch \\${url} HTTP \\${ret.status} \\${ret.statusText}\\`,\n    )\n  }\n  return ret.json()\n}\n`)),mdx(\"p\",null,\"How can we cache this function so that we only get one result\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`async function getCachedPokemon() {\n  if (!this.res) {\n    this.res = getPokemon().catch(e => {\n      this.res = undefined\n    })\n  }\n  return this.res\n}\n`)),mdx(\"p\",null,\"Whether you like the fact that I use \",mdx(\"inlineCode\",{parentName:\"p\"},\"this\"),` in the function is not the\nimportant part necessarily`),mdx(\"p\",null,\"The important part is that when I get an error, I clear the resource\"),mdx(\"p\",null,`This demo also demonstrates some basic fetch error handling, and uses\nstatusText which happens to not exist in HTTP/2. You could wait for the error's\nJSON or text response using an await ret.json() or await ret.text() inside the\ncatch clause note that it could cause yet another error to be thrown`),mdx(\"p\",null,\"See \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cmdcolin.github.io/pokemon.html\"}),\"https://cmdcolin.github.io/pokemon.html\"),\" for demo\"),mdx(\"p\",null,`Footnote: you could also keep a cache in a global variable, and I have found it\nis useful to have a specific function for clearing the cache, so you can get a\nclean slate each time a test runs in unit testing or similar`),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-javascript\"}),`let res\nasync function getCachedPokemon() {\n  if (!res) {\n    res = getPokemon().catch(e => {\n      res = undefined\n    })\n  }\n  return res\n}\nfunction clearCache() {\n  res = undefined\n}\n`)))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true}