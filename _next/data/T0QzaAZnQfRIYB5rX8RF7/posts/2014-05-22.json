{"pageProps":{"post":{"title":"High DPI rendering on HTML5 canvas - some problems and solutions","date":"2014-05-22","slug":"2014-05-22","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      img: \"img\",\n      em: \"em\",\n      strong: \"strong\",\n      ol: \"ol\",\n      li: \"li\",\n      code: \"code\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Recently our code has been moving towards the use of HTML5 canvas, as it has\\nmany benefits. I felt that if we were going to keep this going towards canvas,\\nthe rendering needed to match the quality of regular HTML based tracks.\\nUnfortunately, the HTML5 canvas by default looks very \\\"fuzzy\\\" on a high\\nresolution display (Figure 1).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/86542847038_0.jpg\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"Figure 1.\"\n        }), \" An example of really bad font rendering before and after enabling\\nhigh resolution on the HTML5 canvas.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"**Background **\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Major credit goes to the tutorial at\\nhttp://www.html5rocks.com/en/tutorials/canvas/hidpi/ for pioneering this!\\n The html5rocks tutorial, written in 2010 it still remains relevant. The major\\nthing it introduces is these browser variables called devicePixelRatio and\\nbackingStoreRatio that can be used to adjust your canvas drawing. In my\\ninterpretation, these two variables have the following purpose:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"devicePixelRatio\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"On high DPI displays, screen pixels are actually abstracted away from the\\nphysical pixels, so, when you create some HTML element with width 100, height\\n100, that element actually takes up a larger number of pixels than 100x100. The\\nactual ratio of the pixels that it takes up is 100\", _jsx(_components.em, {\n          children: \"devicePixelRatio x\\n100\"\n        }), \"devicePixelRatio. On a high DPI platform like Retina, the devicePixelRatio\\nis normally 2 at 100% zoom.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"backingStoreRatio\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The backing store ratio doesn't seem to change as much from platform to\\nplatform, but my interpretation of this value is that it essentially gives the\\nsize of the memory buffer for the canvas. On my platform, the backingStoreRatio\\nis \\\"1\\\". I think this value had more historical use, but it may not really be\\nused anymore (update aug 7th, 2015 deprecated?\\nhttp://stackoverflow.com/questions/24332639/why-context2d-backingstorepixelratio-deprecated)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So, what are the consequences of the backing store ratio and the device pixel\\nratio? If the backing store ratio equals the device pixel ratio, then no\\nscaling takes place, but what we often see is that they are not equal, so the\\nimage is up-scaled from the backing store to the screen, and then it is\\nstretched and blurred.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"So, how do you enable the high DPI mode?\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The solution to properly scale your HTML5 canvas content involves a couple of\\nsteps that are described in the tutorial here\\nhttp://www.html5rocks.com/en/tutorials/canvas/hidpi/, but here is the\\nessence:\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Use the canvas.scale method, which tells the canvas's drawing area to become\\nbigger, but keeps drawing operations consistent.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"The scaling factor for the canvas.scale method is\\ndevicePixelRatio/backingStoreRatio. This will be 2 for instance on a Retina\\nscreen at a typical 100% zoom level. The zoom level is relevant which will be\\ndiscussed later in this post...\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Multiply the width and height attributes of the canvas by\\ndevicePixelRatio/backingStoreRatio, so that the \\\"canvas object\\\" is as big as\\nthe scaled size.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Here's the tricky part: set the CSS width and height attributes to be the\\nUNSCALED size that you want.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: you can also set CSS width:100% or something and then the canvas will be\\nsized appropriately. Normally though, what you will have is something like\\n\", _jsx(_components.code, {\n          children: \"<canvas width=640 height=480 style=\\\"width:320px;height:240px\\\">\"\n        }), \" so you can see\\nthat the canvas size is larger than what the CSS actually resizes it to be.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"**Issues: Browser zoom and fractional devicePixelRatios **\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When I first started this project, the benefit of this high resolution\\nrendering seemed limited to the fancy people who had Retina or other High DPI\\nscreens. However, what I didn't even realize is that the devicePixelRatio value\\nchanges depending on browser zoom settings, so even people with a regular\\nscreen can have improved rendering of the HTML5 canvas. (Update: we even saw\\nthat if you have customized canvas renderings, then you an generate good\\nscreenshots of the canvas with PhantomJS too. See \", _jsx(_components.a, {\n          href: \"http://searchvoidstar.tumblr.com/post/112494997473/creating-high-resolution-screenshots-of-jbrowse\",\n          children: \"my other more recent\\narticle\"\n        }), \")\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The issue with these zoom settings though is that when you change the zoom\\nlevel, especially on chrome and firefox browsers, the devicePixelRatio can end\\nup being a fractional value e.g. 2.223277 which can result in sub-pixel\\nrendering problems.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Remember that when we scaled the canvas, it also scales the drawing functions\\nto be consistent, so that essentially if you draw a 1 pixel width line on a\\nscaled canvas, it might draw a 2.223277 pixel width line. Hence, we can get\\nfuzzy rendering issues.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This issue is very noticeable if you draw many 1px wide lines right next to\\neach other. In this case, there will be noticeable gaps between the lines due\\nto the imperfect rendering (see green box below).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/86542847038_1.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"Figure 2.\"\n        }), \" Examples of 1px wide lines rendered next to each other when there\\nis fractional devicePixelRatio.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Bottom Green box: 1px wide lines drawn 1px apart. (note: bad rendering! tiny\\ngaps)  Middle Blue box: 1px wide line rendered every 2 px (intentional gaps for\\ndemonstration).  Top Red box: 1.3px wide lines (a fudge factor is used to make\\neliminate the tiny gaps).\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"**My solution: The Red Box -- add a fudge factor **\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"As you can see in the above figure, my solution to the sub-pixel rendering is\\nto add a \\\"fudge factor\\\" to the line width to make it render lines that are\\n1.3px wide instead of 1px wide when the devicePixelRatio is not a whole number,\\nwhich effectively eliminates any gaps due to the sub-pixel rendering problem.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I heuristically determined the value 1.3px to be sufficient, as testing values\\nlike 1.1px, 1.2px and even 1.25px were too small. I'd love to see a proof of\\ndetermining this value empirically, or even better, something that isn't this\\nbig of a hack, but for now that's what I have.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You can see the effect of the fudge factor (red box) vs the bad rendering\\n(green box) in Figure 2. You can also try this out yourself here\\nhttp://jsfiddle.net/4xe4d/, just zoom your browser and then refresh (zooming\\nand not refreshing doesn't modify device pixel ratio) to test out different\\nvalues of devicePixelRatio.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Conclusion\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In conclusion...we now have high resolution rendering on canvas! The solution\\nfor drawing lots of lines right next to each other is sort of suboptimal, so\\nthe question continues...what shall be done in this case?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Maybe someone could implement some sort of library that replaces the\\ncanvas.scale method to do better layout and obtain more pixel perfect\\nrendering. Alternatively, you could force the scaling factor to always round to\\na whole number. This is actually not a bad solution, because the canvas is\\nalready being resized, and then you can control your rendering better.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Thanks for reading\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}