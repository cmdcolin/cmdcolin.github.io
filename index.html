<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Misc scribblings</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="favicon.ico"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta name="description" content="Blogging for the future"/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js" integrity="sha512-hpZ5pDCF2bRCweL5WoA0/N1elet1KYL5mx3LP555Eg/0ZguaHawxNvEjF6O3rufAChs16HVNhEc6blF/rZoowQ==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="preload" href="/_next/static/css/0e13ae09fdc48bba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0e13ae09fdc48bba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-3e9e72f6d5fa0854.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-896947e153b7d53e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d6e6a35eb3960502.js" defer=""></script><script src="/_next/static/chunks/996-9e3c12b77542c098.js" defer=""></script><script src="/_next/static/chunks/pages/index-42ab42ff96d8b22f.js" defer=""></script><script src="/_next/static/Qd9k61jryXOi2V44T17ep/_buildManifest.js" defer=""></script><script src="/_next/static/Qd9k61jryXOi2V44T17ep/_ssgManifest.js" defer=""></script><script src="/_next/static/Qd9k61jryXOi2V44T17ep/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><main><div><div style="margin-bottom:100px"><a href="/">Misc scribbles</a></div><h2>Colin Diesh</h2>
<!-- --><p>I&#x27;m a software developer and bioinformatician attempting to blog stuff.</p><section><h1>Posts</h1><ul><li><a href="/posts/2022-05-27-youmaynotneedabundler">2022-05-27<!-- --> - <!-- -->You may not need a bundler for your NPM library<!-- --></a></li><li><a href="/posts/2022-05-10-performanceprofiling">2022-05-10<!-- --> - <!-- -->Notes on performance profiling JS applications<!-- --></a></li><li><a href="/posts/2022-05-04-findseddangerous">2022-05-04<!-- --> - <!-- -->Using find . -exec sed is dangerous in a git repo<!-- --></a></li><li><a href="/posts/2022-03-02-dont-let-it-get-to-you">2022-03-03<!-- --> - <!-- -->Cognitive reframing<!-- --></a></li><li><a href="/posts/2022-02-26-memoize-async">2022-02-26<!-- --> - <!-- -->Memoizing async functions so that you don&#x27;t cache errors<!-- --></a></li><li><a href="/posts/2022-02-24-ukraine">2022-02-24<!-- --> - <!-- -->Ukraine<!-- --></a></li><li><a href="/posts/2022-02-15-noise">2022-02-15<!-- --> - <!-- -->Back when I was a noise musician...<!-- --></a></li><li><a href="/posts/2022-02-06-sv-sam">2022-02-06<!-- --> - <!-- -->Structural variants and the SAM format - the long (reads) and short (reads) of it<!-- --></a></li></ul></section><a href="/archive">More posts...</a></div></main></div><footer style="margin-top:100px"><a href="/">Home</a> <!-- --><a href="/archive">Blog archive</a> <!-- --><a href="https://github.com/cmdcolin/">Github</a> <!-- --><a href="https://twitter.com/cmdcolin">Twitter</a> <!-- --><a href="/projects">Projects</a> <!-- --><a href="/photos">Photos</a> <!-- --><a href="/rss.xml">RSS</a><a href="/about">About</a> <!-- --></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPosts":[{"title":"You may not need a bundler for your NPM library","date":"2022-05-27","slug":"2022-05-27-youmaynotneedabundler","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\",\n      code: \"code\",\n      h2: \"h2\",\n      em: \"em\",\n      h3: \"h3\",\n      pre: \"pre\",\n      h4: \"h4\",\n      strong: \"strong\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"I have seen a couple threads on twitter where people complain about the\\ndifficulty with publishing NPM libraries or ask what starter kit they should\\nuse (or, people recommended starter packs anyways)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Example threads\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/cramforce/status/1513903035197526017\",\n            children: \"https://twitter.com/cramforce/status/1513903035197526017\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/oleg008/status/1510006191296061441\",\n            children: \"https://twitter.com/oleg008/status/1510006191296061441\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/iansu/status/1524860613943382017\",\n            children: \"https://twitter.com/iansu/status/1524860613943382017\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://twitter.com/mpocock1/status/1525075901905522691\",\n            children: \"https://twitter.com/mpocock1/status/1525075901905522691\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"One thing that is notable to me in these threads is that people often recommend\\nthat you use a bundler (a program that combines multiple src files into a\\nsingle or fewer output files) when developing a library\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Examples of starter packs suggested in these threads that use bundlers\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"microbundle\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/developit/microbundle\",\n            children: \"https://github.com/developit/microbundle\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"esno\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://www.npmjs.com/package/esno\",\n            children: \"https://www.npmjs.com/package/esno\"\n          }), \" - uses esbuild\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"unbuild\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/unjs/unbuild\",\n            children: \"https://github.com/unjs/unbuild\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"preconstruct\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/preconstruct/preconstruct\",\n            children: \"https://github.com/preconstruct/preconstruct\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"tsup\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/egoist/tsup\",\n            children: \"https://github.com/egoist/tsup\"\n          }), \" - uses esbuild\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"tsdx\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/jaredpalmer/tsdx\",\n            children: \"https://github.com/jaredpalmer/tsdx\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"vite library mode\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://vitejs.dev/guide/build.html#library-mode\",\n            children: \"https://vitejs.dev/guide/build.html#library-mode\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"packemon\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/milesj/packemon\",\n            children: \"https://github.com/milesj/packemon\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"ts-library-template\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/shortercode/ts-library-template\",\n            children: \"https://github.com/shortercode/ts-library-template\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"parcel\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://twitter.com/devongovett/status/1524944991402999810\",\n            children: \"https://twitter.com/devongovett/status/1524944991402999810\"\n          }), \" - uses parcel\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"dts\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://weiran-zsd.github.io/dts-cli/\",\n            children: \"https://weiran-zsd.github.io/dts-cli/\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"pkgroll\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/privatenumber/pkgroll\",\n            children: \"https://github.com/privatenumber/pkgroll\"\n          }), \" - uses rollup\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"mkdist\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/unjs/mkdist\",\n            children: \"https://github.com/unjs/mkdist\"\n          }), \" - referenced by \", _jsx(_components.code, {\n            children: \"unbuild\"\n          }), \", uses esbuild\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Not using bundlers\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"gts\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/google/gts\",\n            children: \"https://github.com/google/gts\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"ts-react-toolbox\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/zzarcon/ts-react-toolbox/\",\n            children: \"https://github.com/zzarcon/ts-react-toolbox/\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In summary 2/15 do not use a bundler, 13/15 do use a bundler. Sidenote: webpack notably absent\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"Why would you \", _jsx(_components.em, {\n          children: \"NOT\"\n        }), \" want a bundler for your library?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"My main argument is that the consumer of your library is the one that should\\nuse a bundler if it is relevant to them. If the library uses a bundler:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"in the best case, it has no impact on the consumer\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"in the worst case, it affects the complexity of your library and makes\\npossible limitations for your consumers also.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"An example where it can actually create limitations, you might consider code\\nsplitting with async \", _jsx(_components.code, {\n          children: \"import()\"\n        }), \". If you create a single file bundle, then the\\nconsumer of your library may not be able to do code splitting properly via\\nasync \", _jsx(_components.code, {\n          children: \"import()\"\n        })]\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"Why would you \", _jsx(_components.em, {\n          children: \"MAYBE\"\n        }), \" want a bundler for your library\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you really care about producing a \", _jsx(_components.code, {\n          children: \"UMD\"\n        }), \" bundle that can be used in a script\\ntag, maybe you want a bundler, but the future does not seem to be in \", _jsx(_components.code, {\n          children: \"UMD\"\n        }), \".\\nOne other possible bundle type is maybe you like the idea of a single file\\n\", _jsx(_components.code, {\n          children: \"ESM\"\n        }), \" module. It is similar where you could maybe reference this from a script\\ntag with type module, but this seems like a niche usage. For example, you\\nwould still have to consider:\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"If you are not bundling dependencies, then what is the benefit of using a\\nbundler?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"If you are bundling dependencies, you are not allowing people to get updates\\nto your sub-dependencies with semver!\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Add-on: Another concern brought up by users in discussion thread: There is a\\ncost to having many small files, e.g. in app startup cost on serverless or any\\nnodejs application to loading many small files off disk. To me, this is an app\\nlevel concern, similar to bundling for the browser though.\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"My suggestion: no bundler, no starter pack, just \", _jsx(_components.code, {\n          children: \"tsc\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I'd recommend just compiling your code with \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \", no bundler involved. This\\nway, you can develop with typescript, it will output \", _jsx(_components.code, {\n          children: \"js\"\n        }), \" files, and you can\\ndirectly deploy a \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" folder of \", _jsx(_components.code, {\n          children: \"js\"\n        }), \" files to NPM.\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"Example \", _jsx(_components.code, {\n          children: \"package.json\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"name\\\": \\\"yourlib\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"main\\\": \\\"dist/index.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"clean\\\": \\\"rimraf dist\\\",\\n    \\\"prebuild\\\": \\\"npm run clean\\\",\\n    \\\"build\\\": \\\"tsc\\\",\\n    \\\"preversion\\\": \\\"npm run build\\\",\\n    \\\"postversion\\\": \\\"git push --follow-tags\\\"\\n  },\\n  \\\"files\\\": [\\\"dist\\\", \\\"src\\\"],\\n  \\\"devDependencies\\\": {\\n    \\\"rimraf\\\": \\\"^3.0.2\\\",\\n    \\\"typescript\\\": \\\"^4.6.2\\\"\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h4, {\n        children: [\"Features of the above \", _jsx(_components.code, {\n          children: \"package.json\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"We can use a single command, \", _jsx(_components.code, {\n            children: \"yarn publish\"\n          }), \" to publish to npm\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The single \", _jsx(_components.code, {\n            children: \"yarn publish\"\n          }), \" automatically runs \", _jsx(_components.code, {\n            children: \"clean\"\n          }), \" and \", _jsx(_components.code, {\n            children: \"build\"\n          }), \" via\\n\", _jsx(_components.code, {\n            children: \"preversion\"\n          }), \", then \", _jsx(_components.code, {\n            children: \"postversion\"\n          }), \", which pushes the tag to the remote repo\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"The \", _jsx(_components.code, {\n            children: \"\\\"files\\\": [\\\"dist\\\", \\\"src\\\"]\"\n          }), \" refers to publishing the \", _jsx(_components.code, {\n            children: \"dist\"\n          }), \" and \", _jsx(_components.code, {\n            children: \"src\"\n          }), \"\\ndirectories, and src is used for the \", _jsx(_components.code, {\n            children: \"sourceMap\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"Example\", _jsx(_components.code, {\n          children: \" tsconfig.json\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"include\\\": [\\\"src\\\"],\\n  \\\"compilerOptions\\\": {\\n    \\\"target\\\": \\\"es2018\\\",\\n    \\\"outDir\\\": \\\"dist\\\",\\n    \\\"lib\\\": [\\\"dom\\\", \\\"esnext\\\"],\\n    \\\"declaration\\\": true,\\n    \\\"moduleResolution\\\": \\\"node\\\",\\n    \\\"sourceMap\\\": true,\\n    \\\"strict\\\": true,\\n    \\\"esModuleInterop\\\": true\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.h4, {\n        children: [\"Features of the above \", _jsx(_components.code, {\n          children: \"tsconfig.json\"\n        })]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Uses \", _jsx(_components.code, {\n            children: \"\\\"moduleResolution\\\": \\\"node\\\"\"\n          }), \" - this is not pure-ESM because pure-ESM\\nexpects you to import filenames with their file extension, while node module\\nresolution can import extensionless paths, but node module resolution\\ngenerally works well with consumers that use bundlers themselves\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Uses \", _jsx(_components.code, {\n            children: \"\\\"target\\\": \\\"es2018\\\"\"\n          }), \" - This is does a small amount of transpilation of\\nsuper modern features, but would generally not require your users to\\nbabel-ify their \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" if they consume your library\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"What about testing?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Adding testing is not immediately solved by the above, but bundling doesn't\\nreally help testing anyways. It's just a starter pack feature we can add on.\\nSome options you have include\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"ts-jest\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"jest\"\n          }), \" on it's own, plus a \", _jsx(_components.code, {\n            children: \"babel\"\n          }), \" config with \", _jsx(_components.code, {\n            children: \"@babel/preset-typescript\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"jest\"\n          }), \" on it's own, run over the compiled output without a \", _jsx(_components.code, {\n            children: \"babel\"\n          }), \" config\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"vitest\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Possibly something else? Node now has a built-in test runner. It will be a\\nslow road to adoption but might become more popular over time\\n\", _jsx(_components.a, {\n            href: \"https://fusebit.io/blog/node-testing-comes-to-core/\",\n            children: \"https://fusebit.io/blog/node-testing-comes-to-core/\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Conclusion\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"It is tempting to have nice zero-config solutions and starter kits, but to me,\\nit is not really beneficial to use the bundler aspect of many of these for\\npublishing to NPM. Am I wrong? Let me know if I am.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Also, these starter kits may not be maintained for perpetuity. Our team used\\n\", _jsx(_components.code, {\n          children: \"tsdx\"\n        }), \" for some time, but it was not maintained well, and used old typescript\\nversion 3.x, and it ended up being hard to remove from our codebase. Learning\\nthe basic tools like \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" will help\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 1: Shipping pure-ESM\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Do you want to make a pure-ESM package? Then you do not want to use\\n\", _jsx(_components.code, {\n          children: \"\\\"moduleResolution\\\": \\\"node\\\"\"\n        }), \" in \", _jsx(_components.code, {\n          children: \"tsconfig.json\"\n        }), \", and you will want to set\\n\", _jsx(_components.code, {\n          children: \"\\\"type\\\": \\\"module\\\"\"\n        }), \" in \", _jsx(_components.code, {\n          children: \"package.json\"\n        }), \". You may also need to explicitly import\\nwith \", _jsx(_components.code, {\n          children: \".js\"\n        }), \" extensions in your source code, even if you write \", _jsx(_components.code, {\n          children: \".ts\"\n        }), \". This is\\nawkward, and something the community is still grappling with.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you have ever stumbled on this topic, you will probably want to see this\\nlink\\n\", _jsx(_components.a, {\n          href: \"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\",\n          children: \"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\"\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 2: Learning your tools\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Several people on the\\n\", _jsx(_components.a, {\n          href: \"https://cmdcolin.github.io/posts/2022-05-04-findseddangerous\",\n          children: \"my recent post\"\n        }), \"\\npost suggested that I did not understand my tools, and that I should just learn\\nthe tools correctly and I wouldn't have the problem I had.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Indeed, what I am now telling people to do in this post is similar: I am saying\\n\\\"just use \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" by itself! Understand you tools! You may have to do more\\nresearch and create more boilerplate, but it's \", _jsx(_components.strong, {\n          children: \"better\"\n        }), \"\\\".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Ultimately though, it's up to you to choose your tools and starter packs and\\nwhatnot.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 3: What does it look like when you compile with tsc?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When I refer to compiling with tsc above, I compile a \", _jsx(_components.code, {\n          children: \"src\"\n        }), \" directory into a\\n\", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" directory\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So if I have:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"src/index.ts\\nsrc/util.ts\\nsrc/components/Button.ts\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Running \", _jsx(_components.code, {\n          children: \"tsc\"\n        }), \" will output:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"dist/index.js\\ndist/index.d.ts\\ndist/index.js.map\\ndist/util.js\\ndist/util.d.ts\\ndist/util.js.map\\ndist/components/Button.js\\ndist/components/Button.d.ts\\ndist/components/Button.js.map\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Then, the \", _jsx(_components.code, {\n          children: \"dist\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"src\"\n        }), \" directories are published to npm which enables the\\n\", _jsx(_components.code, {\n          children: \"sourceMaps\"\n        }), \" to work.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: We do not need to explicitly say where the typescript types are with\\n\\\"types\\\" in \", _jsx(_components.code, {\n          children: \"package.json\"\n        }), \", many starter packs do this but it is unneeded for\\nthis package as the d.ts files are automatically found.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"See\\n\", _jsx(_components.a, {\n          href: \"https://cmdcolin.github.io/posts/2021-12-31-npm-package\",\n          children: \"https://cmdcolin.github.io/posts/2021-12-31-npm-package\"\n        }), \"\\nfor my article on creating a typescript package for npm\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 4: Other things people recommend\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Other things people recommend in the starter pack threads\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"deno\"\n          }), \" - not clear to me how this helps when deploying to npm, but I still gotta try deno\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"ts-node \"\n          }), \" - not clear to me how this helps when deploying to npm\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"nx\"\n          }), \" - heavy monorepo-based solution\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"elm\"\n          }), \" - that's just a different thing\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"Typescript-Node-Starter\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/microsoft/TypeScript-Node-Starter\",\n            children: \"https://github.com/microsoft/TypeScript-Node-Starter\"\n          }), \" - not a library, full stack framework\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"joystick\"\n          }), \" - \", _jsx(_components.a, {\n            href: \"https://github.com/CheatCode/joystick\",\n            children: \"https://github.com/CheatCode/joystick\"\n          }), \" - not a library, full stack framework\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 5:\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Similar things happen if you take on dependencies of starter kits like\\n\", _jsx(_components.code, {\n          children: \"create-react-app\"\n        }), \". You become very committed to their particular way of doing\\nthings, and can only modify their config with things like \", _jsx(_components.code, {\n          children: \"rescripts\"\n        }), \", \", _jsx(_components.code, {\n          children: \"craco\"\n        }), \"\\nor \", _jsx(_components.code, {\n          children: \"rewired\"\n        }), \". If you crafted your setup with just \", _jsx(_components.code, {\n          children: \"webpack\"\n        }), \", you may not be so\\ntied down. But, I still use things like \", _jsx(_components.code, {\n          children: \"create-react-app\"\n        }), \" because they do seem\\nto help me significantly. Now though, the tide seems to be turning other\\ndirections like next.js which can do static site generation at a basic level\\nand extend to multiple pages more easily.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Notes on performance profiling JS applications","date":"2022-05-10","slug":"2022-05-10-performanceprofiling","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      h2: \"h2\",\n      a: \"a\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Keeping your program fast is important for\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"user satisfaction in everyday apps\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"making certain things tractable\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In our application, we visualize some large-ish datasets using the browser and\\njavascript\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"The Chrome profiler\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I use the Chrome DevTools \\\"Performance\\\" profiler, which is a\\nstatistical/sampling profiler\\n\", _jsx(_components.a, {\n          href: \"https://en.wikipedia.org/wiki/Profiling_(computer_programming)#Statistical_profilers\",\n          children: \"https://en.wikipedia.org/wiki/Profiling_(computer_programming)#Statistical_profilers\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This means it samples at some rate and see's where in the callstack the program\\nis executing.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"If you see large rectangles in the profiler, you may have a long running\\nfunction\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"If you see many small rectangles, your small function may be called many\\ntimes\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Note: sometimes your function may be so fast, it is rarely or never encountered\\nby the sampling. It is a good thing (TM) to be this fast, but I mention it to\\nnote that the sampling profiler does not give us a complete log of all function\\ncalls.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Creating a flamegraph from the Chrome profiler results\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: sometimes, it is also useful to see the results as a \\\"flamegraph\\\" (see\\n\", _jsx(_components.a, {\n          href: \"https://www.brendangregg.com/flamegraphs.html\",\n          children: \"https://www.brendangregg.com/flamegraphs.html)\"\n        }), \")\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The website \", _jsx(_components.a, {\n          href: \"https://www.speedscope.app/\",\n          children: \"https://www.speedscope.app/\"\n        }), \" can\\ncreate \\\"flamegraph\\\" style figures for Chrome profiling results\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Stacking up many small optimizations\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Working with large datasets, sometimes your program will take a long time to\\ncomplete. Especially if you work with javascript in the browser, it is a\\nchallenge to make things go fast. But you can use micro optimizations to help\\nimprove performance over time.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"For example, say a program takes 30 seconds to run on a certain dataset\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you do profiling and find a couple microoptimizations that give you a 15%,\\n10% and 5% performance improvement, then you program now takes 20 seconds to\\nrun. That is still not instantaneous, but it is saving users a good 10 seconds.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Examples of micro optimizations\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Using \", _jsx(_components.code, {\n            children: \"Map\"\n          }), \" instead of \", _jsx(_components.code, {\n            children: \"Object\"\n          }), \" can often get small performance boosts\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Comparing value against \", _jsx(_components.code, {\n            children: \"undefined\"\n          }), \" e.g. \", _jsx(_components.code, {\n            children: \"if(val===undefined)\"\n          }), \" vs just\\ncomparing against falsy e.g. \", _jsx(_components.code, {\n            children: \"if(!val)\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Using \", _jsx(_components.code, {\n            children: \"TypedArray\"\n          }), \"/\", _jsx(_components.code, {\n            children: \"Uint8Array\"\n          }), \" natively instead of \", _jsx(_components.code, {\n            children: \"Buffer\"\n          }), \" polyfill. This\\none is a kicker for me because we relied on \", _jsx(_components.code, {\n            children: \"Buffer\"\n          }), \" polyfill, and webpack 5\\nstopped bundling polyfills by default which made us wake up to this\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"When converting \", _jsx(_components.code, {\n            children: \"Uint8Array\"\n          }), \" to string, use \", _jsx(_components.code, {\n            children: \"TextDecoder\"\n          }), \" for large strings, and\\njust small string concatenations of \", _jsx(_components.code, {\n            children: \"String.fromCharCode\"\n          }), \" for small ones.\\nThere is an inflection point for string size where one is faster\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"for\"\n          }), \" loops instead of \", _jsx(_components.code, {\n            children: \"Array.prototype.forEach\"\n          }), \"/\", _jsx(_components.code, {\n            children: \"Array.prototype.map\"\n          }), \". I\\nthink similar to above, there is an inflection point (not where it gets\\nfaster in the \", _jsx(_components.code, {\n            children: \"forEach\"\n          }), \"/\", _jsx(_components.code, {\n            children: \"map\"\n          }), \" case, but where you can choose to care whether\\nthe small performance diff matters) based on number of elements in your array\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Pre-allocate an array with \", _jsx(_components.code, {\n            children: \"new Array(N)\"\n          }), \" instead of just \", _jsx(_components.code, {\n            children: \"[]\"\n          }), \" if possible\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I have tried to keep track of more microoptimizations here, but they are pretty\\nspecific to small examples and may not generalize across browsers or browser\\nversions \", _jsx(_components.a, {\n          href: \"https://gist.github.com/cmdcolin/ef57d2783e47b16aa07a03967fd870d8\",\n          children: \"https://gist.github.com/cmdcolin/ef57d2783e47b16aa07a03967fd870d8\"\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Examples of macro optimizations\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Oftentimes, large scale re-workings of your code or \\\"macro\\\" optimizations are\\nthe way to make progress.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"A macro optimization may be revealed if you are looking at your performance\\nprofiling result and you think: this entire section of the program could be\\nreworked to remove this overhead\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In this case, it is hard to advise on because most of these will be very\\nspecific to your particular app.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Just as a specific example of a macro optimization I undertook:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We use web workers, and had to serialize a lot of data from the web worker to\\nthe main thread. I did a large re-working of the codebase to allow, in\\nparticular examples, the main thread to request smaller snippets of data from\\nthe web worker thread on-demand (the web worker is kept alive indefinitely)\\ninstead of serializing all the web worker data and sending to the main thread.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This change especially pays off with large datasets, where all that\\nserialization/data duplication is computationally and memory expensive. Fun\\nfact: I remember sitting at a table at a conference in Jan 2020 talking with my\\nteam at the Plant and Animal Genome conference, thinking that we should make\\nthis change -- finally did it, just took 2 years. [1]\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"End-to-end optimization testing\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In order to comprehensively measure whether micro or macro optimizations are\\nactually improving your real world performance, it can be useful to create an\\nend-to-end test\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"For our app, I created a \", _jsx(_components.code, {\n          children: \"puppeteer\"\n        }), \" based test where I loaded the website and\\nwaited for a \\\"DONE\\\" condition. I created a variety of different tests which\\nallowed me to see e.g. some optimizations may only affect certain conditions.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Developing the end-to-end test suite tool awhile to develop (read: weeks to\\nmature, though some earlier result were available), but it let me compare the\\ncurrent release vs experimental branches, and over time, the experimental\\nbranches were merged and things got faster. [2]\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Note that memory usage can be very important to your programs performance.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Excessive allocations will increase \\\"GC pressure\\\" (the garbage collector will\\ninvoke more Minor and Major GC, which you will see in your performance\\nprofiling reuslts as yellow boxes)\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Conclusion\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"It is really important to look at the profiling to see what your program\\nactually is spending time on. You can make hypothetical optimizations all day\\nand dream of rewriting in rust but you may just have a slow hot path in your JS\\ncode that, if optimized, can get big speedups.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Let me know about your favorite optimizations in the comments!\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnotes\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"[1] Note that things like SharedArrayBuffer also offer a means to share data\\nbetween worker and main thread, but these come with many security limitations\\nfrom the browser (and was even removed for a time while these security\\nimplications were sussed out, due to Spectre/Meltdown vulnerabilities)\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"[2] I still have not found a good way to get automated memory usage profiling\\nvia puppeteer. You can access window.process.memory in puppeteer, but this\\nvariable does not provide info about webworker memory usage\\n\", _jsx(_components.a, {\n          href: \"https://github.com/puppeteer/puppeteer/issues/8258\",\n          children: \"https://github.com/puppeteer/puppeteer/issues/8258\"\n        })]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Using find . -exec sed is dangerous in a git repo","date":"2022-05-04","slug":"2022-05-04-findseddangerous","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      pre: \"pre\",\n      code: \"code\",\n      h2: \"h2\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"You want to find and replace all instances of a string in your repo, so you\\ngoogle \\\"find replace directory linux command\\\". You end up here\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.a, {\n          href: \"https://stackoverflow.com/a/6759339/2129219\",\n          children: \"https://stackoverflow.com/a/6759339/2129219\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"They tell us\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"find ./ -type f -exec sed -i -e 's/apple/orange/g' {} \\\\;\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Ignoring the fact that this syntax is very long and hard to type, this command\\nis dangerous to use in a git repository. Specifically, this can corrupt your\\n.git contents.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Why?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This command is dangerous because, find . will enumerate dotfiles, including\\nthe .git directory, and then of course will run the find and replace inside\\nthem. We can see this in the following session\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"\u003e mkdir corruptme\\n\u003e cd corruptme\\n\u003e git init\\n\u003e echo \\\"# README\\\" \u003e README.md\\n\u003e git add README.md\\n\u003e git commit -m \\\"Initial commit\\\"\\n\u003e echo \\\"Hello world, it is a beautiful day. I sure hope someone doesn't corrupt this git repository\\\" \u003e\u003e README.md\\n\u003e git commit -am \\\"Update README.md\\\"\\n\u003e find .\\n.\\n./README.md\\n./.git\\n./.git/branches\\n./.git/config\\n./.git/COMMIT_EDITMSG\\n...more stuff...good indication the next command might be dangerous....\\n\u003e find ./ -type f -exec sed -i -e \\\"s/README/CORRUPTME/g\\\" {} \\\\;\\n\u003e git status\\nerror: index uses md extension, which we do not understand\\nfatal: index file corrupt\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In this case, you may be able to recover it e.g. with\\nhttps://stackoverflow.com/questions/1115854/how-to-resolve-error-bad-index-fatal-index-file-corrupt-when-using-git\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you happened to replace some random text that is actually in an object file though e.g. .git/objects\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"\u003e find ./ -type f -exec sed -i -e \\\"s/VHTHJM/OOOOOO/g\\\" {} \\\\;\\n\u003e git status\\nerror: inflate: data stream error (incorrect data check)\\nerror: corrupt loose object '26cfc5964dfa5355a1747eb6eec6250aab5212d5'\\nfatal: unable to read 26cfc5964dfa5355a1747eb6eec6250aab5212d5\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"What is better?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"My take: Use ruplacer \", _jsx(_components.a, {\n          href: \"https://github.com/dmerejkowsky/ruplacer\",\n          children: \"https://github.com/dmerejkowsky/ruplacer\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This tool won't try to replace stuff in your .git directory. It will also skip\\nanything in .gitignore including e.g. node_modules. I was delighted to discover\\nthis tool so, just spreading the word\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Addendum: Reddit /u/Snarwin also recommended using git ls-files instead of find\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"git ls-files | xargs sed -i -e 's/apple/orange/g'\\n\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cognitive reframing","date":"2022-03-03","slug":"2022-03-02-dont-let-it-get-to-you","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"A big part of my recent career has not been technical but emotional learning\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This has been very hard, but the benefits are worth it\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"A lot of it is mental reframing\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Meetings\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Make a mental note of things you are grateful for, can do this before a\\nmeeting to make sure you go in with a positive attitude\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Deep breathing, especially if you feel anxious\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Try not to drop bombs of negativity during a meeting, and at least consider\\nyour tone when saying things\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Don't try to complain about things that are broken too much. It is\\nmean and cruel and demoralizes everyone\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"In your off time\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Try not to dwell on the things that are broken. You are smart. You will fix\\nthem in time. It doesn't help to put your anxiety levels so high\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Remote work anxieties/feeling appreciated\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"If someone isn't getting back to your issues, don't take it personally. Try\\nreviewing their code, or check in with them\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"If you don't feel appreciated, also try not to take it personally. Instead,\\ntry to exude positivity in your own life\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Try not to be a hero programmer https://incident.io/blog/no-capes\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This cognitive reframing is extremely important and you can apply it to\\nmany areas of your life. You tell your own personal story, and what goes on\\nin your head makes it to the real world through your behavior.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Memoizing async functions so that you don't cache errors","date":"2022-02-26","slug":"2022-02-26-memoize-async","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      pre: \"pre\",\n      code: \"code\",\n      h2: \"h2\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"There are two hard problems in computer science: \", _jsx(_components.a, {\n          href: \"https://martinfowler.com/bliki/TwoHardThings.html\",\n          children: \"Cache invalidation and naming\\nthings\"\n        }), \". In this post we'll\\nshow how memoize an async function, and how to invalidate the memoization when\\nthe promise throws an error.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This helps us with being able to re-try because since the error is not cached,\\ncalling it again after an error retries automatically.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Example async function: fetch from the pokemon API\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"async function getPokemon() {\\n  const id = Math.floor(Math.random() * 150)\\n  const url = 'https://pokeapi.co/api/v2/pokemon/' + id\\n  const ret = await fetch(url)\\n  if (!ret.ok) {\\n    throw new Error(\\n      `Failed to fetch ${url} HTTP ${ret.status} ${ret.statusText}`,\\n    )\\n  }\\n  return ret.json()\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Here is a technique that can be used to memoize this function\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"function getPokemonMemoized() {\\n  if (!this.promise) {\\n    this.promise = getPokemon().catch(e =\u003e {\\n      this.promise = undefined\\n      throw e\\n    })\\n  }\\n  return this.promise\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The promise is held in this.promise, and the important part of this function is\\nthat when I get an error, I clear this.promise and re-throw the error. The caller\\nof the function, on error, will receive the error message, but caching will not\\ntake place, allowing retries to take place later on.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"See https://cmdcolin.github.io/pokemon.html for demo\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 0: Arguments to function\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If your function takes arguments, then you can use a hashmap associating the\\nargument with the promise. You may also consider using an LRU cache so that\\nyour hashmap doesn't grow infinitely in size\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Generally you need a way to stringify or otherwise make them able to be stored\\nin a Map or Object to do this.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"See https://github.com/nodeca/promise-memoize for example\"\n      }), \"\\n\", _jsxs(_components.h2, {\n        children: [\"Footnote 1: Error handling of \", _jsx(_components.code, {\n          children: \"fetch\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This demo also demonstrates some basic fetch error handling, and uses\\n\", _jsx(_components.code, {\n          children: \"statusText\"\n        }), \" \", _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText\",\n          children: \"which happens to not exist in\\nHTTP/2\"\n        }), \".\\nIf you want a semblence of status message text in HTTP/2 you can try to use\\nawait ret.json() (if the API returns json error messages) or await ret.text()\\ninside the catch clause, but note that it could cause yet another error to be\\nthrown\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 2: Global cache\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You could also keep a cache in a global variable, or as a property on a class,\\nor other methods. I have also found it useful to have a specific function for\\nclearing the cache, so you can get a clean slate each time a test runs in unit\\ntesting or similar\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"let promise\\nasync function getPokemonMemoized() {\\n  if (!promise) {\\n    promise = getPokemon().catch(e =\u003e {\\n      promise = undefined\\n      throw e\\n    })\\n  }\\n  return promise\\n}\\nfunction clearCache() {\\n  promise = undefined\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"You can also make a general purpose utility to memoize any promise function\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"function memoize(fn) {\\n  let promise\\n  return () =\u003e {\\n    if (!promise) {\\n      promise = fn().catch(e =\u003e {\\n        promise = undefined\\n        throw e\\n      })\\n    }\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 3 - Aborting\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you want to handle aborting, it is a bit trickier. Aborting in javascript is\\nhandled by\\n\", _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/API/AbortController/AbortController\",\n          children: \"AbortController\"\n        }), \".\\nThis is an object that gives you an\\n\", _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\",\n          children: \"AbortSignal\"\n        }), \"\\nthat can be passed to fetch calls and the like to stop a big download from\\nhappening.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In our above example, if we passed an abort signal to the first call to fetch,\\nand then aborted it, it would abort the fetch, \", _jsx(_components.a, {\n          href: \"https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\",\n          children: \"which throws a DOMException\\ncalled\\n\\\"AbortError\\\"\"\n        }), \".\\nYou can detect that it is an AbortError like this, and may choose not to\\ndisplay or re-throw the abort exception\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"function isAbortException(e) {\\n  return e instanceof Error \u0026\u0026 exception.name === 'AbortError'\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now, what if 5 functions call getPokemonMemoized(), all passing different abort\\nsignals. What if the first one aborts? Then all the rest will get aborted also.\\nBut what if we only want to abort the cached call if literally all of them\\naborted? Then we may have to synthesize an abortcontroller inside our function\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"let promise\\nlet abortcontroller\\nlet listeners = 0\\nasync function getPokemonMemoized(signal) {\\n  if (!promise) {\\n    abortcontroller = new AbortController()\\n\\n    // synthesize a new signal instead of using the passed in signal\\n    promise = getPokemon(abortcontroller.signal).catch(e =\u003e {\\n      promise = undefined\\n      throw e\\n    })\\n  }\\n  if (signal) {\\n    listeners++\\n    // add listener to the passed in signal\\n    signal.addEventListener('abort', () =\u003e {\\n      listeners--\\n      if (listeners === 0) {\\n        abortcontroller.abort()\\n      }\\n    })\\n  }\\n  return promise\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A library my team created,\\n\", _jsx(_components.a, {\n          href: \"https://github.com/GMOD/abortable-promise-cache\",\n          children: \"abortable-promise-cache\"\n        }), \",\\ntries to help with this scenario with a cleaner abstraction.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 4\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I have been playing through Pokemon Yellow and find it really amusing hence the\\npokemon theme\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Fun stuff: The cutting room floor wiki with unused moves, sounds, and sprites\\nin Pokemon Yellow https://tcrf.net/Pok%C3%A9mon_Yellow\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Footnote 5\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This blog post mentioned in a comment thread https://zansh.in/memoizer.html has\\ngreat interactive examples and shows the \\\"invalidate on .catch()\\\" behavior!\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Ukraine","date":"2022-02-24","slug":"2022-02-24-ukraine","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"As Russia is actively invading Ukraine my heart goes out to them.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Even if I had no personal connection with Ukraine, I would find this abhorrent,\\nbut I do have personal connections to Ukraine in various ways that makes me\\nthink of them more fondly\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"My first, and so far only, consulting job was with a company in Ukraine, around 2012. I helped them configure JBrowse, and prepared an official looking word\\ndocument with recommendations and hours (a total of like...2 hours) and they\\nwere very nice.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Stand strong Ukraine\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Lesser_Coat_of_Arms_of_Ukraine.svg/172px-Lesser_Coat_of_Arms_of_Ukraine.svg.png\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Back when I was a noise musician...","date":"2022-02-15","slug":"2022-02-15-noise","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      ul: \"ul\",\n      li: \"li\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Found this photo of myself from a photo book published by john cates called\\nauditory depravation...great documentation of michigan area noise activity. I\\nam actually the last photo in the book amongst so many amazing\\nartists...totally honored. I forgot I was even in the book when I picked it up\\nrandomly.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"thank you john cates!!!\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"/photos/noise/cover-crop-fs8.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"cover\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"/photos/noise/out20-crop-fs8.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"index p1\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"/photos/noise/out21-crop-fs8.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"index p2\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"/photos/noise/out22-crop-fs8.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"index p3, i'm last as xephedradap\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"/photos/noise/out15-crop-fs8.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"me\"\n      }), \"\\n\", _jsx(\"img\", {\n        src: \"/photos/noise/out16-crop-fs8.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"abstract b/w\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"some photos from the book here https://www.johncatesphoto.com/noise\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.a, {\n            href: \"https://soundcloud.com/xephedradap/amazingnoisetreasure\",\n            children: \"lightyear fluctuations\"\n          }), \" (hnw)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.a, {\n            href: \"https://soundcloud.com/xephedradap/symptomatic-of-extreme-decay\",\n            children: \"symptomatic of extreme decay\"\n          }), \" (circuit bent hnw)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.a, {\n            href: \"https://soundcloud.com/xephedradap/2016-10-10-13-35-49a\",\n            children: \"2016-10-10-13-35-49a\"\n          }), \" (circuit bent drum machine)\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I will make more noise soon...stay tuned\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Structural variants and the SAM format - the long (reads) and short (reads) of it","date":"2022-02-06","slug":"2022-02-06-sv-sam","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      a: \"a\",\n      h2: \"h2\",\n      h3: \"h3\",\n      ul: \"ul\",\n      li: \"li\",\n      strong: \"strong\",\n      em: \"em\",\n      img: \"img\",\n      pre: \"pre\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" specification is pretty amazing\\n(\", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n          children: \"https://samtools.github.io/hts-specs/SAMv1.pdf\"\n        }), \")\\nbut it is also fairly terse and abstract. True understanding might come from\\nplaying with real world data. I will try to relay some things I have learned\\ngenerally from playing with real world data, with a little bit of an aim to\\nexplain how SAM concepts can relate to structural variants.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Disclaimer: I'm a developer of JBrowse 2. This document has some screenshots\\nand links for it, feel free to try it at\\n\", _jsx(_components.a, {\n          href: \"https://jbrowse.org\",\n          children: \"https://jbrowse.org\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Basics\"\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"What is a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file and how does it relate to \", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \"?\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"A \", _jsx(_components.code, {\n              children: \"SAM\"\n            }), \" file \", _jsx(_components.strong, {\n              children: \"generally\"\n            }), \" contains \\\"reads\\\" from a sequencer, with information\\nabout how they are mapped to a reference genome [1][2].\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"A \", _jsx(_components.code, {\n              children: \"SAM\"\n            }), \" file is \", _jsx(_components.strong, {\n              children: \"generally\"\n            }), \" produced when an aligner takes in raw unaligned reads\\n(often stored in \", _jsx(_components.code, {\n              children: \"FASTQ\"\n            }), \" format files) and aligns them to a reference genome [3].\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"A \", _jsx(_components.code, {\n              children: \"SAM\"\n            }), \" file is a text format that you can read with your text editor. \", _jsx(_components.code, {\n              children: \"BAM\"\n            }), \" and\\n\", _jsx(_components.code, {\n              children: \"CRAM\"\n            }), \" are compressed representations of the \", _jsx(_components.code, {\n              children: \"SAM\"\n            }), \" format.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You can convert \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \" with samtools\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"samtools view file.sam -o file.bam\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"You can also convert a \", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \" back to \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" with samtools view\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"samtools view -h file.bam -o file.sam\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The -h just makes sure to preserve the header.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you are converting \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \", it may require the -T argument to\\nspecify your reference sequence (this is because the \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" is \\\"reference\\ncompressed\\\")\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"samtools view -T reference.fa file.sam -o file.cram\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Also see Appendix C: piping FASTQ from \", _jsx(_components.code, {\n          children: \"minimap2\"\n        }), \" directly to CRAM\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"[1] \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" can contain any type of sequence, not specifically reads. If you\\ncreated a de novo assembly, you could align the contigs of the de novo assembly\\nto a reference genome and store the results in \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"[2] Does not always have to have information about mapping to a reference\\ngenome. You can also store unaligned data in \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" (so-called\\n\", _jsx(_components.code, {\n          children: \"uBAM\"\n        }), \" for example) but most of the time, the reads in \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" format are aligned\\nto a reference genome.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"[3] Examples of programs that do alignment include \", _jsx(_components.code, {\n          children: \"bwa\"\n        }), \", \", _jsx(_components.code, {\n          children: \"bowtie\"\n        }), \", and \", _jsx(_components.code, {\n          children: \"minimap2\"\n        }), \"\\n(there are many others). These programs all can produce \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" outputs\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"What is in a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file contains a header (\", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" files also have the \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \"\\nheader) and a series of records. A record is a single line in a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file, and\\nit generally corresponds to a single read, but as we will see, a split\\nalignment may produce multiple records that refer to the same source read.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: if a read failed to align to the reference genome, it may still be in\\nyour \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file, marked as unmapped using the flag column. Sometimes, \\\"dumpster\\ndiving\\\" (looking at the unmapped records from a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file) can be used to aid\\nstructural variant searches (e.g. there may be novel sequence in there not from\\nthe reference genome that could be assembled)\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"What are tags in a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A SAM file has a core set of required fields, and then an arbitrary list of\\nextra columns called tags. The tags have a two character abbreviation like \", _jsx(_components.code, {\n          children: \"MQ\"\n        }), \"\\n(mapping quality) or many others. They can be upper or lower case. Upper case\\nare reserved for official usages (except those with X, Y, or Z prefixed). See\\n\", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/SAMtags.pdf\",\n          children: \"SAMtags.pdf\"\n        }), \" for more\\ndetails\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"What is a \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" string\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" string is a \\\"compact idiosyncratic gapped alignment report\\\". It tells\\nyou about insertions, deletions, and clipping. It is a series of \\\"operators\\\" with lengths.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Insertion example:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"50M50I50M\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"That would be 50bp of matching bases (\", _jsx(_components.code, {\n          children: \"50M\"\n        }), \"), followed by a 50bp insertion\\n(\", _jsx(_components.code, {\n          children: \"50I\"\n        }), \"), followed by another 50bp of matches (\", _jsx(_components.code, {\n          children: \"50M\"\n        }), \"). The 50bp insertion means\\nthe read contains 50 bases in the middle which did not match the reference\\ngenome that you are comparing the read to.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Clipping example:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"50S50M50S\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This means that 50bp matched (\", _jsx(_components.code, {\n          children: \"50M\"\n        }), \" in the middle of the \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" string) and\\nboth sides of the read are soft clipped. The clipping means the aligner was not\\nable to align the reads on either side. You could imagine clipping being like\\n\\\"an insertion on either side of the read\\\" if you like: basically those bases on\\neither side did not align.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Notes:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.em, {\n              children: \"Finding mismatches\"\n            }), \": A \", _jsx(_components.code, {\n              children: \"CIGAR\"\n            }), \" string match like \", _jsx(_components.code, {\n              children: \"50M\"\n            }), \" means 50 bases\\n\\\"matched\\\" the reference genome, but that only means that there are no\\ninsertions or deletions in those 50 bases. There could be underlying\\nmismatches in the read compared to the reference. See Appendix D on the MD\\ntag and finding where the mismatches are.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.em, {\n              children: \"Ambiguity of representation\"\n            }), \": A \", _jsx(_components.code, {\n              children: \"CIGAR\"\n            }), \" string with insertions and deletions\\ncould be \", _jsx(_components.code, {\n              children: \"50M1D1I50M\"\n            }), \". This string had a 1bp deletion and a 1bp insertion\\nback-to-back. This could be just a mismatch! There is ambiguity in sequence\\nalignment representations. Downstream programs must accomodate this.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.em, {\n              children: \"Split records and soft-clipping\"\n            }), \": A \", _jsx(_components.code, {\n              children: \"CIGAR\"\n            }), \" string with soft-clipping\\n\", _jsx(_components.code, {\n              children: \"500S50M\"\n            }), \" this means that 500 bases of the read were not aligned at this\\nposition, but 50 bases were! Note that the alignment might have been a split\\nalignment (see seciton on split alignments below) so another record in the\\n\", _jsx(_components.code, {\n              children: \"SAM\"\n            }), \" file, linked by the \", _jsx(_components.code, {\n              children: \"SA\"\n            }), \" (supplmentary alignment) tag, might contain\\ninfo on where the other 500 bases aligned! (or, they might not map anywhere).\\nThe linked split or supplementary alignments all have the same read name\\n(\", _jsx(_components.code, {\n              children: \"QNAME\"\n            }), \").\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"See \", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n          children: \"SAMv1.pdf\"\n        }), \" for all the\\nCIGAR operators.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If you are working with \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" data, you will often write loops that directly\\nparse CIGAR strings. See Appendix B for handy functions for parsing \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \"\\nstrings. Don't fear the \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \"!\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Detecting SVs from long reads\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Long reads offer a wide array of methods for detecting SVs\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Small insertions/deletions: Long reads can completely span moderate sized\\ninsertions and deletions, indicated by \", _jsx(_components.code, {\n            children: \"I\"\n          }), \" or \", _jsx(_components.code, {\n            children: \"D\"\n          }), \" in a \", _jsx(_components.code, {\n            children: \"CIGAR\"\n          }), \" string.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Large insertions/deletions: If a long read does not completely an insertion\\nor deletion, it may be split alignment (for a deletion) or could be soft/hard\\nclipped where it can't align all the way through an insertion.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Translocations: A split long alignment can span long range or even\\ninter-chromosomal translocations, so part of the read maps to one chromosome\\nand one part maps to the other\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Inversions: A split alignment can span an inversion, the long read is split\\ninto multiple parts, one part of it aligns in the reverse orientation, while\\nthe other part aligns in the forward orientation\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Note that there are many different methods for detecting SVs from long reads,\\ne.g. not all use mapped reads from SAM files, some use de novo assembly, but\\nit is still useful to be familiar with mapped read methods.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"What are split alignments?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Split alignments, or chimeric alignments, are alignments where part of the read\\naligns to perhaps chr1, and part of it maps to perhaps chr4. It is worth\\nreading the definition of \\\"Chimeric alignment\\\" from\\n\", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n          children: \"SAMv1.pdf\"\n        }), \" when you get the\\nchance.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Split alignments are especially common with long reads, and it can indicate\\nthat there may be a structural variant where the two chromosomes are fused\\ntogether (which may create gene fusions, or other types of phenomena).\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"There is no limitation on how many splits might occur so the split can align to\\n3, 4, or more different places. Each part of the split puts a new line in the\\nSAM file, and note that all the records also have the same \", _jsx(_components.code, {\n          children: \"QNAME\"\n        }), \" (first\\ncolumn of \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \"). As\\n\", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n          children: \"SAMv1.pdf\"\n        }), \" tells us, one\\nrecord is marked as \\\"representative\\\", I call this the \\\"primary\\\" record, while\\nthe other components of the split read are maked supplementary, given the 2048\\nflag. Only the \\\"primary\\\" record generally has a \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \" field.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note: split alignments are different from \\\"multi-mappers\\\" where the entire read\\nmaps maps equally well to, say, chr4 and chr1. Split reads maps part to chr1,\\nand part to chr4. See again the\\n\", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/SAMv1.pdf\",\n          children: \"SAMv1.pdf\"\n        }), \" for the definition\\nof multi-mapping\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"What is the \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag?\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag is outputted on each part of the split alignment, e.g. the primary\\ncontains an \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag that refers to all the locations, \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" strings, and\\nmore for all the supplementary reads, and each of the supplementary reads also\\ncontains an \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag that refers to the primary alignment and each other\\nsupplementary alignment.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Fun fact: The \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag conceptually can result in a 'quadratic explosion' of\\ndata, because each part of the split contains references to every other part.\\nFor example, if a read is split into 4 pieces, then each record would would\\nhave an SA tag with 3 segments, so 3*4 segments will be documented in the\", _jsx(_components.code, {\n          children: \"SA\"\n        }), \"\\ntag. In many cases, this is not a problem, but if you imagine a finished\\nchromosome aligned to a draft assembly, it may get split so many times this\\ncould be a factor.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Visualizing split reads across a breakend or translocation\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This is a specialized JBrowse 2 feature, but if there is an inter-chromosomal\\ntranslocation, you can load this into JBrowse and visualize support for this\\nevent using our \\\"breakpoint split view\\\". This\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We also have a workflow called the \\\"SV inspector\\\" that helps you setup the\\n\\\"breakpoint split views\\\"\\n(\", _jsx(_components.a, {\n          href: \"https://jbrowse.org/jb2/docs/user_guide/#sv-inspector\",\n          children: \"https://jbrowse.org/jb2/docs/user_guide/#sv-inspector\"\n        }), \".\\nThe SV inspector works)\\nbest on Breakend spec events and \u003cTRA\u003e (translocation) events from VCF,\\nor BEDPE formatted SV calls, and you can launch the \\\"breakpoint split view\\\"\\nfrom the \\\"SV inspector\\\"\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/breakpoint_split_view.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Visualizing a 'read vs reference' view given a split alignment\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If we are given the the primary alignment of an arbitrary split read, then we\\ncan construct what that split looks like compared to the reference genome.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If we are not given the primary alignment (e.g. we are starting from a\\nsupplementary alignment) then we can search the \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" list for the one that is\\nprimary, because at least one will be.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Now that we have the primary alignment, it will have the \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \" (of the entire\\nread, the supplementary alignments typically have a blank \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \"!) and the \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \"\\ntag containing the \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" of all the different parts of the split. We can then\\nconstruct how the entire read, not just a particular record of the split\\nalignment, compares to the genome. In JBrowse 2 we implemented this and it uses\\na synteny-style rendering. This functionality also exists in GenomeRibbon\\n\", _jsx(_components.a, {\n          href: \"https://genomeribbon.org\",\n          children: \"https://genomeribbon.org)\"\n        }), \")\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/linear_alignment.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Figure showing JBrowse 2 piecing together a long read vs the reference genome\\nfrom a single read\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In order to do this reconstruction, JBrowse 2 takes the \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" strings of the\\nprimary alignment and each of the pieces of the \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag (it is a semi-colon\\nseparated list of chunks), sort them by the amount of softclipping (the\\nsoftclipping values will progressively trim off more of the \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \" telling you\\nit aligned further and further on in the long read), and then this tells me\\nwhere each piece of the split alignment came from in the original \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \", so we\\ncan plot the alignments of the read vs the reference genome using synteny style\\ndisplay.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"SAM vs VCF - Breakends vs split alignments\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"An interesting outcome (to me) is that from a single record in a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file, I\\ncan reconstruct the \\\"derived\\\" genome around a region of interest from a single\\nread.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If I was to try to do this with the \", _jsx(_components.code, {\n          children: \"VCF\"\n        }), \" Breakend specification (section 5.4\\nof \", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/VCFv4.3.pdf\",\n          children: \"VCF4.3.pdf\"\n        }), \"), it may\\nactually be more challenging than from a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" read. This is because a Breakend\\nin \", _jsx(_components.code, {\n          children: \"VCF\"\n        }), \" format is only an edge in a graph (and the sequences are nodes).\\nTherefore, in order to properly reconstruct a structural variant from a \", _jsx(_components.code, {\n          children: \"VCF\"\n        }), \"\\nwith Breakends, I would have to construct a graph and decode paths through it.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I like the ability to reconstruct the derived genome from a single read, but it\\ncan be noisy. That said, de novo assembled contigs can also be stored in \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \"\\nformat and is significantly less noisy (being composed of the aggregate\\ninformation of many reads).\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The point though is that interpretation of the \", _jsx(_components.code, {\n          children: \"VCF\"\n        }), \" breakend specification is\\nchallenging due to imposing a sequence graph on the genome, while the \", _jsx(_components.code, {\n          children: \"SA\"\n        }), \" tag\\nremains just a simple set of linear alignments that can easily be pieced\\ntogether, and you only need to refer to a single record in the \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file to do\\nso.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I am not aware of a lot of tools that work on the VCF Breakend graph, and\\nexpect more will need to be created to truly work with this standard. An\\ninversion for example may create 4 record in the VCF file (see section 5.4 in\\nthe \", _jsx(_components.a, {\n          href: \"https://samtools.github.io/hts-specs/VCFv4.3.pdf\",\n          children: \"VCF4.3.pdf\"\n        }), \" for\\nexample), and needs careful interpretation.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Haplotype tagged reads\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A new trend has been to create \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \"/\", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" files with tagged reads,\\nwhich tells us which haplotype a read was inferred to have come from. This is\\ncommonly done with the \", _jsx(_components.code, {\n          children: \"HP\"\n        }), \" tag, which might have \", _jsx(_components.code, {\n          children: \"HP=0\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"HP=1\"\n        }), \" for a\\ndiploid genome. Tools like \", _jsx(_components.code, {\n          children: \"whatshap\"\n        }), \" can add these tags to a \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" file, and\\nIGV and JBrowse 2 can color and sort by these tags.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/color_by_tag.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Screenshot of JBrowse 2 with the \\\"Color by tag\\\" and \\\"Sort by tag\\\" setting\\nenabled (coloring and sorting by the HP tag) letting us see that only one\\nhaplotype has a deletion. Tutorial for how to do this in JBrowse 2 here\\n\", _jsx(_components.a, {\n          href: \"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\",\n          children: \"https://jbrowse.org/jb2/docs/user_guide/#sort-color-and-filter-by-tag\"\n        })]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"How do you detect SVs with paired-end reads?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Paired-end reads are short reads, e.g. 150bp each. This makes them unable to\\nrecover some large structural variants.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"However, paired-end reads have a number of attributes that can be used to\\ndetect paired end reads\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Distance between pairs being abnormally large or short\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The distance between pairs is encoded by the \", _jsx(_components.code, {\n          children: \"TLEN\"\n        }), \" column in the \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" format.\\nThe distance between pairs with good mapping is relatively constant and called\\nthe \\\"insert length\\\". This comes from how the sequencing is done: paired-end\\nsequencing performs sequencing on both ends of a fragment.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"But, if you are mapping reads vs the reference genome, and you observe that\\nthey are abnormally far apart, say 50kb apart instead of 1kb apart, this may\\nindicate there your sample contains a deletion relative to the reference.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/aberrant_size.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Screenshot of JBrowse 1 with \\\"View as pairs\\\" enabled, and large insert size\\ncolored as red (from\\n\", _jsx(_components.a, {\n          href: \"https://jbrowse.org/docs/paired_reads.html\",\n          children: \"https://jbrowse.org/docs/paired_reads.html\"\n        }), \").\\nNote that some of JBrowse 1's View as pairs features are not yet available in\\nJBrowse 2\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"An abundance of reads being \\\"clipped\\\" at a particular position\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This can indicate that part of the reads map well, but then there was an abrupt\\nstop to the mapping. This might mean that there is a sequence that was an\\ninsertion at that position, or a deletion, or a translocation.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The clipping is indicated by the \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" string, either at the start or end of\\nit by an \", _jsx(_components.code, {\n          children: \"S\"\n        }), \" or an \", _jsx(_components.code, {\n          children: \"H\"\n        }), \". The \", _jsx(_components.code, {\n          children: \"S\"\n        }), \" indicates \\\"soft clipping\\\", and indicates that\\nthe sequence of the clipped portion can be found in the \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \" field of the\\nprimary alignment. The \", _jsx(_components.code, {\n          children: \"H\"\n        }), \" is hard clipped, and the sequence that is hard\\nclipped will not appear in the \", _jsx(_components.code, {\n          children: \"SEQ\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/clipping_pileup.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Screenshot of JBrowse 2 showing blue clipping indicator with a \\\"pileup\\\" of\\nsoft-clipping at a particular position shown in blue. The clipping is an\\n\\\"interbase\\\" operation (it occurs between base pair coordinates) so it is\\nplotted separately from the normal coverage histogram.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/show_soft_clipping.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Screenshot of JBrowse 2 showing an insertion with Nanopore (top), PacBio\\n(middle) and Illumina short reads. The long reads may completely span the\\ninsertion, so the CIGAR string on those have an \", _jsx(_components.code, {\n          children: \"I\"\n        }), \" operator and are indicated\\nby the purple triangle above the reads. For the short reads, the reads near the\\ninsertion will be clipped since they will not properly map to the reference\\ngenome and cannot span the sinsertion. The \\\"Show soft clipping\\\" setting in\\nJBrowse 2 and IGV can be used to show visually the bases that extend into the\\ninsertion (shown on the bottom track).\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Unexpected pair orientation\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"With standard paired end sequencing, the pairs normally point at each other\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"forward reverse\\n ---\u003e    \u003c---\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If the stranded-ness of the pair is off, then it could indicate a structural\\nvariant. See Appendix A for a handy function for calculating pair orientation.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This guide from IGV is helpful for interpreting the pair directionality with\\npatterns of SVs using \\\"Color by pair orientation\\\"\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.a, {\n          href: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\",\n          children: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/inverted_duplication.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Figure: This shows an inverted (tandem) duplication in 1000 genomes data. The\\ntandem duplication can produce green arrows which have reads pointing in\\nopposite directions e.g. \", _jsx(_components.code, {\n          children: \"\u003c--\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"--\u003e\"\n        }), \", while blue arrows which can indicate\\nan inversion point in the same direction e.g. \", _jsx(_components.code, {\n          children: \"--\u003e\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"--\u003e\"\n        })]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Caveat about TLEN\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Note that \", _jsx(_components.code, {\n          children: \"TLEN\"\n        }), \" is a field in the SAM format that is somewhat ill defined,\\nat least in the sense that different tools may use it differently\\n\", _jsx(_components.a, {\n          href: \"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\",\n          children: \"https://github.com/pysam-developers/pysam/issues/667#issuecomment-381521767\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If needed, you can calculate \", _jsx(_components.code, {\n          children: \"TLEN\"\n        }), \" yourself if you process the file yourself\\n(e.g. process all reads, get the actual records for the pairs, and calculate\\ndistance) but I have not had trouble with relying on the \", _jsx(_components.code, {\n          children: \"TLEN\"\n        }), \" from the data\\nfiles themselves.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Calling copy number variants with your short or long reads\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Another type of SV that you can get from your \", _jsx(_components.code, {\n          children: \"SAM\"\n        }), \" files are copy number\\nvariants (CNVs). By looking at the depth-of-coverage for your data files, you\\ncan look for abnormalities that may indicate copy number variants. By using a\\ntool like \", _jsx(_components.code, {\n          children: \"mosdepth\"\n        }), \", you can quickly get a file showing the coverage across\\nthe genome.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Be aware that if you are comparing the coverage counts from different tools,\\nthat they have different defaults that may affect comparison. Some discard\\n\", _jsx(_components.code, {\n          children: \"QC_FAIL\"\n        }), \", \", _jsx(_components.code, {\n          children: \"DUP\"\n        }), \", and \", _jsx(_components.code, {\n          children: \"SECONDARY\"\n        }), \" flagged reads. This is probably appropriate,\\nand corresponds to what most genome browsers will display (see\\n\", _jsx(_components.a, {\n          href: \"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\",\n          children: \"https://gist.github.com/cmdcolin/9f677eca28448d8a7c5d6e9917fc56af\"\n        }), \" for a short\\nsummary of depth calculated from different tools)\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Note that both long and short reads can be used for CNV detection. Long reads\\nmay give more accurate measurements also, with their better ability to map\\nsmoothly through difficult regions of the genome.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/media/coverage_cnv.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Screenshot showing coverage in BigWig format from nanopore reads on normal and\\ntumor tissue from a melanoma cancer cell line (COLO829) plotted using JBrowse 2\\n(\", _jsx(_components.a, {\n          href: \"https://jbrowse.org/code/jb2/v1.6.4/?config=test_data%2Fconfig_demo.json\u0026session=share-MZj3d18lzH\u0026password=3X7bS\",\n          children: \"demo\"\n        }), \"\\nand\\n\", _jsx(_components.a, {\n          href: \"https://jbrowse.org/jb2/docs/user_guide/#viewing-whole-genome-coverage-for-profiling-cnv\",\n          children: \"tutorial\"\n        }), \")\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"The future, with graph genomes and de-novo assemblies\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Currently, SV visualization is highly based on comparing data versus a\\nreference genome (and the SAM format is a signature of this: it stores data in\\nterms of reference genome coordinates). In the future, SV visualization may\\nlook more similar to comparative genomics, where we compare an SV to a\\npopulation specific reference from a graph genomes or something like this.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"It is known that de-novo assembly has more power to detect SVs than some read\\noperations (\", _jsx(_components.a, {\n          href: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\",\n          children: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"\n        }), \")\\nas de novo assembled genomes improve and become more widespread, we may see a\\nshift in how SVs are called\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I would also like to see improved ability to do fast or 'on the fly' gene\\nprediction on the de novo assembled genomes, and we can see what SNPs or\\nmodified splicing might occur in CNV copies of genes.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Conclusion\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Algorithms that actually call structural variants face many challenges, but\\nunderstanding how the reads are encoded in SAM format, and seeing what they\\nlook like in the genome browser is a useful first step to gaining a better\\nunderstanding.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In summary, some of the signatures of SVs may include:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Aberrant insert size (\", _jsx(_components.code, {\n            children: \"TLEN\"\n          }), \") detection (longer for deletion, shorter for\\ninsertion)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Split-read detection (\", _jsx(_components.code, {\n            children: \"SA\"\n          }), \" tag)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"CIGAR string processing (\", _jsx(_components.code, {\n            children: \"D\"\n          }), \" operator for deletions, \", _jsx(_components.code, {\n            children: \"I\"\n          }), \" operator for\\ninsertions)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Over-abundance of clipping (\", _jsx(_components.code, {\n            children: \"S\"\n          }), \" or \", _jsx(_components.code, {\n            children: \"H\"\n          }), \" operators in \", _jsx(_components.code, {\n            children: \"CIGAR\"\n          }), \")\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Depth of coverage changes for CNVs\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"Aligning de novo assembly vs a reference genome\\n(\", _jsx(_components.a, {\n            href: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\",\n            children: \"https://twitter.com/lh3lh3/status/1362921612690010118/photo/1\"\n          }), \"\\nwhich can output \", _jsx(_components.code, {\n            children: \"SAM\"\n          }), \", but it can also output\\n\", _jsx(_components.a, {\n            href: \"https://github.com/lh3/miniasm/blob/master/PAF.md\",\n            children: _jsx(_components.code, {\n              children: \"PAF\"\n            })\n          }), \" format (which can\\nbe loaded in JBrowse 2 in the synteny views). Techniques of detecting SVs on\\nPAF will be fundamentally pretty similar to the techniques listed above but\\nmay look a bit different (see \", _jsx(_components.code, {\n            children: \"cs\"\n          }), \" tag in PAF for example)\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you have any ideas I should include here, let me know!\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Appendix A: Parsing CIGAR strings\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This is code that can help determine the pair orientation from a single BAM\\nrecord. Might be too much detail but follow along\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"// @param flags - flags from a single read\\n// @param ref - the string of the reference sequence, just used to determine if it matches rnext\\n// @param rnext - the string of the RNEXT, just used to determine if it matches ref\\n// @param tlen - the TLEN field from SAM\\n// @return e.g. F1R2 normal paired end orientation\\nfunction getPairOrientation(\\n  flags: number,\\n  ref: string,\\n  rnext: string,\\n  tlen: number,\\n) {\\n  // this read is not unmapped \u0026\u0026\\n  // this read's mate is also not unmapped \u0026\u0026\\n  // this read's mate is on the same reference genome\\n  if (!flags \u0026 4 \u0026\u0026 !flags \u0026 8 \u0026\u0026 ref === rnext) {\\n    const s1 = flags \u0026 16 ? 'R' : 'F'\\n    const s2 = flags \u0026 32 ? 'R' : 'F'\\n    let o1 = ' '\\n    let o2 = ' '\\n\\n    // if first in pair\\n    if (flags \u0026 64) {\\n      o1 = '1'\\n      o2 = '2'\\n    }\\n\\n    // else if second in pair\\n    else if (flags \u0026 128) {\\n      o1 = '2'\\n      o2 = '1'\\n    }\\n\\n    const tmp = []\\n    if (tlen \u003e 0) {\\n      tmp[0] = s1\\n      tmp[1] = o1\\n      tmp[2] = s2\\n      tmp[3] = o2\\n    } else {\\n      tmp[2] = s1\\n      tmp[3] = o1\\n      tmp[0] = s2\\n      tmp[1] = o2\\n    }\\n    return tmp.join('')\\n  }\\n  return null\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then this can be broken down further by orientation type\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Paired end reads are \\\"fr\\\"\\nMate pair reads are \\\"rf\\\"\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"So you can interpret e.g. F1R2 in relation to being a paired end read (fr) or mate pair (rf) below and with this link \", _jsx(_components.a, {\n          href: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\",\n          children: \"https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\"\n        })]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"fr\\\": {\\n    \\\"F1R2\\\": \\\"LR\\\",\\n    \\\"F2R1\\\": \\\"LR\\\",\\n\\n    \\\"F1F2\\\": \\\"LL\\\",\\n    \\\"F2F1\\\": \\\"LL\\\",\\n\\n    \\\"R1R2\\\": \\\"RR\\\",\\n    \\\"R2R1\\\": \\\"RR\\\",\\n\\n    \\\"R1F2\\\": \\\"RL\\\",\\n    \\\"R2F1\\\": \\\"RL\\\"\\n  },\\n\\n  \\\"rf\\\": {\\n    \\\"R1F2\\\": \\\"LR\\\",\\n    \\\"R2F1\\\": \\\"LR\\\",\\n\\n    \\\"R1R2\\\": \\\"LL\\\",\\n    \\\"R2R1\\\": \\\"LL\\\",\\n\\n    \\\"F1F2\\\": \\\"RR\\\",\\n    \\\"F2F1\\\": \\\"RR\\\",\\n\\n    \\\"F1R2\\\": \\\"RL\\\",\\n    \\\"F2R1\\\": \\\"RL\\\"\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Appendix B - CIGAR parsing\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"// @param cigar: CIGAR string in text form\\nfunction parseCigar(cigar: string) {\\n  return cigar.split(/([MIDNSHPX=])/)\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then parse the returned array two at a time\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-typescript\",\n          children: \"// this function does nothing, but is informative for how to parse interpret a\\n// CIGAR string\\n// @param cigar:CIGAR string from record\\n// @param readSeq: the SEQ from record\\n// @param refSeq: the reference sequence underlying the read\\nfunction interpretCigar(cigar: string, readSeq: string, refSeq: string) {\\n  const opts = parseCigar(cigar)\\n  let qpos = 0 // query position, position on the read\\n  let tpos = 0 // target position, position on the reference sequence\\n  for (let i = 0; i \u003c ops.length - 1; i += 2) {\\n    const length = parseInt(opts[i], 10)\\n    const operator = opts[i + 1]\\n    // do things. refer to the CIGAR chart in SAMv1.pdf for which operators\\n    // \\\"consume reference\\\" to see whether to increment\\n    if (op === 'M' || op === '=') {\\n      // matches consume query and reference\\n      qpos += len\\n      tpos += len\\n    }\\n    if (op === 'I') {\\n      // insertions only consume query\\n      // sequence of the insertion from the read is\\n      const insSeq = readSeq.slice(qpos, qpos + len)\\n      qpos += len\\n    }\\n    if (op === 'D') {\\n      // deletions only consume reference\\n      // sequence of the deletion from the reference is\\n      const delSeq = refSeq.slice(tpos, tpos + len)\\n      tpad += len\\n    }\\n    if (op === 'N') {\\n      // skips only consume reference\\n      // skips are similar to deletions but are related to spliced alignments\\n      tpad += len\\n    }\\n    if (op === 'X') {\\n      // mismatch using the extended CIGAR format\\n      // could lookup the mismatch letter in a string containing the reference\\n      const mismatch = refSeq.slice(tpos, tpos + len)\\n      qpos += len\\n      tpos += len\\n    }\\n    if (op === 'H') {\\n      // does not consume query or reference\\n      // hardclip is just an indicator\\n    }\\n    if (op === 'S') {\\n      // softclip consumes query\\n      // below gets the entire soft clipped portion\\n      const softClipStr = readSeq.slice(qpos, qpos + len)\\n      qpos += len\\n    }\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Note for example, that to determine how long a record is on the reference\\nsequence, you have to combine the records start position with the CIGAR string,\\nbasically parsing the CIGAR string to add up tpos and return tpos\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Appendix C - align FASTQ directly to CRAM\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This example from the htslib documentation\\n(http://www.htslib.org/workflow/fastq.html) shows how you can stream directly\\nfrom \", _jsx(_components.code, {\n          children: \"FASTQ\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" (and generate the index file .crai too)\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"minimap2 -t 8 -a -x sr reference.fa reads1.fq reads2.fq  | \\\\\\nsamtools fixmate -u -m - - | \\\\\\nsamtools sort -u -@2 - | \\\\\\nsamtools markdup -@8 --reference reference.fa - --write-index final.cram\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you want, you can make this a little shell script, easy_align.sh\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"#!/bin/bash\\nminimap2 -t 8 -a -x sr \\\"$1\\\" \\\"$2\\\" \\\"$3\\\"  | \\\\\\nsamtools fixmate -u -m - - | \\\\\\nsamtools sort -u -@2 - | \\\\\\nsamtools markdup -@8 --reference \\\"$1\\\" - --write-index \\\"$4\\\"\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then call\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-sh\",\n          children: \"bash easy_align.sh ref.fa reads1.fq reads2.fq out.cram\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This same concept works with other common aligners as well like bwa\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Appendix D - the MD tag\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tag helps tell you where the mismatches are without looking at the\\nreference genome. This is useful because as I mentioned, \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" can say \", _jsx(_components.code, {\n          children: \"50M\"\n        }), \"\\n(50 matches) but some letters inside those 50 matches can be mismatches, it\\nonly says there are no insertions/deletions in those 50 bases, but you have to\\ndetermine where in those 50 bases where the mismatches are. The \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tag can\\nhelp tell you where those are, but it is somewhat complicated to decode\\n(\", _jsx(_components.a, {\n          href: \"https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html\",\n          children: \"https://vincebuffalo.com/notes/2014/01/17/md-tags-in-bam-files.html\"\n        }), \").\\nYou have to combine it with the \", _jsx(_components.code, {\n          children: \"CIGAR\"\n        }), \" to get the position of the mismatches\\non the reference genome. If you have a reference genome to look at, you might\\njust compare all the bases within the 50M to the reference genome and look for\\nmismatches yourself and forget about the \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tag\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tag is also not required to exist, but the command \", _jsx(_components.code, {\n          children: \"samtools calmd yourfile.bam --reference reference.fa\"\n        }), \" can add \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tags to your \", _jsx(_components.code, {\n          children: \"BAM\"\n        }), \" file. It\\nis generally not useful for \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" because \", _jsx(_components.code, {\n          children: \"CRAM\"\n        }), \" actually does store\\nmismatches with the reference genome in it's compression format. Note that\\nthere are some oddities about \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tags leading to complaints (e.g.\\n\", _jsx(_components.a, {\n          href: \"https://github.com/samtools/hts-specs/issues/505\",\n          children: \"https://github.com/samtools/hts-specs/issues/505\"\n        }), \"\\nbut the \", _jsx(_components.code, {\n          children: \"MD\"\n        }), \" tag can be)\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}]},"__N_SSG":true},"page":"/","query":{},"buildId":"Qd9k61jryXOi2V44T17ep","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>