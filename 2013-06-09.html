<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-7c4c4c05609ee1ee2453.js" defer=""></script><script src="/_next/static/chunks/framework-7915ac2dcad08ccffd1a.js" defer=""></script><script src="/_next/static/chunks/main-d0187c47f4d0d1b19d72.js" defer=""></script><script src="/_next/static/chunks/pages/_app-51f94a4fd678a8c1801c.js" defer=""></script><script src="/_next/static/chunks/pages/2013-06-09-a861142dd046966be832.js" defer=""></script><script src="/_next/static/ir3stmELHQRvEOT9d_k92/_buildManifest.js" defer=""></script><script src="/_next/static/ir3stmELHQRvEOT9d_k92/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><a href="/">Return home</a><div style="margin:0 auto;width:75%"><h1>Adding a custom normalization to MACS</h1><p>One of the issues with ChIP-seq is that each dataset has it&#x27;s own
special characteristics. What works well on one might perform poorly on
another! There are variations in the sequencing depth as well as in the
enrichment of the protocol, and the protocols for ChIP can vary widely
themselves specialized for using small numbers of cells or other
scenarios.</p><p>In the paper &quot;Normalization of ChIP-seq with control&quot; (Liang and Keles,
2012), they make a convincing case for how to estimate the normalization
factor to scale the background distribution of reads. They analyzed a
couple different openly available ChIP-seq datasets, and I found these
figures to be very illustrative for the unique shapes that each dataset
has.</p><p><img src="https://64.media.tumblr.com/0320609f2578b7b1c1e1fbf374aeaf52/f0d5ac36bf6ed6c6-a2/s540x810/ba8bfea74ab5a40d516d766ddfe6f52bfcaa3458.png"/></p><p><img src="https://64.media.tumblr.com/f5715129b10d81cbc17508c3963028b7/f0d5ac36bf6ed6c6-a8/s540x810/cd53cfd832cdc808dfc076e9c9a4bc0dbeaa2ed4.png"/></p><p><img src="https://64.media.tumblr.com/5dc3ded50aaf36b426afd573f7908ae0/f0d5ac36bf6ed6c6-6e/s540x810/bdc88947dedfbc82eb9ff24f699aaa25e154776f.png"/></p><p><em>Supp Figures 1-3, from Liang et al. (2012) -</em> These figures show the
binned read counts of various ChIP-seq experiments versus their
controls. Each experiment has a unique shape that depends on the
sequencing depth and the enrichment of the protocols.</p><p><strong>How to estimate the normalization the NCIS way?</strong></p><p>In applications like MACS, the ChIP-seq and control is normalized by the
sequencing depth. However, we might not want to scale down the peaks
from the ChIP-seq data: we might only want to normalize the
&quot;background&quot;, the non-specific and noisey DNA-protein interactions.</p><p>We know that the binding sites are basically peaks in the data, so a
&quot;reasonable&quot; way to estimate the background is to use all binned read
counts that have less than &quot;<em>t&quot; reads</em>. This corresponds to the set
<em>Bw(t)</em> ofall bins <em>B</em> of width <em>w</em> that have less than <em>t</em> reads. With
that in mind, we can see the first figure of the NCIS paper and actually
make sense of it.</p><p><img src="https://64.media.tumblr.com/430f7e98dde0a2e97d47a23035f0260d/f0d5ac36bf6ed6c6-9f/s540x810/9125d7fa9a91fc74c010c430ca58ee0f1698c048.png"/></p><p><em>Figure 1. from Liang et al (2012)</em> - Shows the estimated ratio of the
background reads in the ChIP-seq/control for a given threshold <em>t</em>. The
optimal <em>t</em> is called when at least ¾ of the genome are included in the
background distribution and thereafter when the estimated ratio starts
&quot;going up&quot; (r(t)<!-- -->&gt;<!-- -->r(t-1)), indicating that we &#x27;grabbing&#x27; the chip-seq
signal and stopping there.</p><p><strong>How can we apply this technique to MACS?</strong></p><p>Originally, I found NCIS on the MACS mailing list and I wanted to figure
out how I can answer this question for myself. As it turns out, MACS can
perform pitifully on some datasets. This includes datasets like Zheng et
al which I have looked at in my previous posts. One particular
experiment with SEG1 produces some very troublesome results when MACS is
used to find peaks. Therefore, I wanted to see if we can use the NCIS
ratio estimates for MACS. Unfortunately, for MACS 1.4.2, there no way to
specify a custom normalization factor, so I made a quick hack that
ignores the affect of the default --to-small=BOOL flag if a new flag
that I specified, called --ratio=FLOAT, is set. The --ratio is a scaling
factor affects the control dataset, but i could have designed it to
affect the chip-seq dataset as well.</p><p><strong>Calculation of the of NCIS ratio for the SEG1 dataset</strong></p><p>As in the NCIS paper, I also tried to analyze the SEG1 dataset using
MACS. So first I tried to reproduce some of the results of NCIS in their
SEG1 application, but to do this, i had to do some guesswork about NCIS
methods. First, i deduced that they had pooled all the SEG1 replicates
together, which gives me a very close ratio estimate to their published
results.\
\
<em>SEG1 ratio given in NCIS paper\
</em>NCIS estimated ratio:<em>1.265\
</em>estimated background proportion:<em>0.763</em>\
\
<em>SEG1rep1,2,3 pooled ratio based on my calculation using NCIS</em>\
NCIS estimated ratio: <em>1.2627640</em>\
estimated background proportion: <em>0.7672308</em></p><p><em>Sidenote:</em> The NCIS package is very easy to use in R, which is great,
but i also ran into some memory problems. I would try using the MCS or
BED format instead of AlignedRead format. Personally, I used MACS script
elandresult2bed to convert the the eland<!-- -->_<!-- -->result files to BED instead of
using readAligned to get the eland<!-- -->_<!-- -->result files into memory directly\
\
<strong>Peak calling using the modified MACS</strong></p><p>After calculating the normalization, i did the peak calling with and
without the ratio parameters to see how this performed.  Again, I had to
guess the peak calling parameters because they aren&#x27;t given in NCIS, so
I kind of guessed. Unfortuantely, my numbers didn&#x27;t match their numbers,
but the effects of using the --ratio flag are clear. First, I called
peaks without the --ratio flag</p><p><em>macs14 -g 1.2e7 -m 4,30 -t SEGChIP<!-- -->_<!-- -->rep123u<!-- -->_<!-- -->eland<!-- -->_<!-- -->result.txt -c
SEG1inputu<!-- -->_<!-- -->eland<!-- -->_<!-- -->result.txt -n SEG1rep123</em></p><p>This command resulted in only <em>703 called peaks</em> and <em>971 negative
peaks</em> (yikes! bad fdr). I also tried adding the parameter --to-small,
which downscales the ChIP-seq data (6M reads) instead of upscaling the
control data (4M reads), but it didn&#x27;t improve much: <em>366 peaks</em> called
and <em>713 negative peaks</em> (yikes again!)</p><p>So, then using the --ratio flag that i added to MACS, I ran MACS using
the NCIS ratio estimate which is <em>r=1.2627640</em>. This is in comparison
with the raw sequencing depth ratio that MACS applies which is <em>r=1.64</em>.</p><p><em>macs14 -t SEG1ChIP<!-- -->_<!-- -->rep123u<!-- -->_<!-- -->eland<!-- -->_<!-- -->result.txt -c
SEG1inputu<!-- -->_<!-- -->eland<!-- -->_<!-- -->result.txt -m 4,30 -g 1.2e7 --ratio 1.26 -n
SEG1rep123-ncismod</em></p><p>This resulted in <em>991 peaks</em> and only <em>19 negative peaks</em>. Arguably,
this result is a lot better! Changing only the --ratio from <!-- -->~<!-- -->1.6 to
<!-- -->~<!-- -->1.2 creates a much better control of the FDR.</p><p><strong>Why is it so much of a better result?</strong></p><p>We can visually see how the different ratios compare based on figures
from Liang et al. again, and here the sequencing depth ratio (black)
greatly exceeds the the NCIS ratio (blue) which follows the background
distribution. If the sequencing depth ratio is used as a scaling factor,
then the control data will be amplified into the region where true peaks
can occur, so many negative peaks will be called, and many positive
peaks will be obscured!</p><p><img src="https://64.media.tumblr.com/40192ff1491a0b90777a0e4efb3128ca/f0d5ac36bf6ed6c6-92/s540x810/70bf1f948b3c018b5e1737345fb4df3d82169faf.png"/></p><p><em>Figure 4. from Liang et al (2012)</em> - The black line represents the
difference in sequencing depth, the blue line is the NCIS estimate</p><p><strong>Conclusion</strong></p><p>These are positive results for using the NCIS estimator with MACS, and
it only involved a very simple patch to the MACS source code to achieve.
Overall, I found that the new --ratio parameter combined with the NCIS
ratio  estimate was very effective at fixing the problems with the high
FDR and weak peak calling observed in SEG1.</p><p>I&#x27;m surprised I had not heard of this technique earlier, since it
appears to also be implemented to some degree by cisgenome and others. I
guess I like surprises though! There are additional results from the
NCIS paper regarding the control of the FDR that I would like to figure
out still. I also should probably try it on different datasets and see
how it compares.</p><p><strong>Download</strong></p><p>If you want to try out MACS 1.4.2 using the --ratio flag, I made a
github fork of the code and added a tag &quot;add-ratio-branch&quot; which let&#x27;s
you download the package as a zip here
<a href="https://github.com/tonto/MACS/tags">https://github.com/tonto/MACS/tags</a></p><p>You can also see the exact changes that I made to MACS using this commit
log here
<a href="https://github.com/tonto/MACS/commit/d1c9f9931871ee8706e0aca1041f647857b2f8e5">https://github.com/tonto/MACS/commit/d1c9f9931871ee8706e0aca1041f647857b2f8e5</a></p><p>::: {#footer}
<!-- -->[ June 9th, 2013 10:08pm ]<!-- -->{#timestamp} <!-- -->[python]<!-- -->{.tag} <!-- -->[chip-seq]<!-- -->{.tag}
<!-- -->[bioinformatics]<!-- -->{.tag} <!-- -->[genomics]<!-- -->{.tag} <!-- -->[statistics]<!-- -->{.tag}
:::</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/2013-06-09","query":{},"buildId":"ir3stmELHQRvEOT9d_k92","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>